{"version":3,"file":"index-BRpkBD8C.js","sources":["../../src/core/Scene.js","../../node_modules/three/examples/jsm/controls/OrbitControls.js","../../src/core/Camera.js","../../src/core/Renderer.js","../../src/gizmo/RotationGizmo.js","../../src/utils/MathUtils.js","../../src/core/InputHandler.js","../../node_modules/three/examples/jsm/utils/BufferGeometryUtils.js","../../node_modules/three/examples/jsm/loaders/GLTFLoader.js","../../src/utils/ModelLoader.js","../../node_modules/three-mesh-bvh/src/core/Constants.js","../../node_modules/three-mesh-bvh/src/utils/ArrayBoxUtilities.js","../../node_modules/three-mesh-bvh/src/core/utils/nodeBufferUtils.js","../../node_modules/three-mesh-bvh/src/core/build/computeBoundsUtils.js","../../node_modules/three-mesh-bvh/src/core/build/splitUtils.js","../../node_modules/three-mesh-bvh/src/core/BVHNode.js","../../node_modules/three-mesh-bvh/src/core/build/sortUtils.js","../../node_modules/three-mesh-bvh/src/core/build/buildUtils.js","../../node_modules/three-mesh-bvh/src/core/build/buildTree.js","../../node_modules/three-mesh-bvh/src/utils/PrimitivePool.js","../../node_modules/three-mesh-bvh/src/core/utils/BufferStack.js","../../node_modules/three-mesh-bvh/src/core/cast/shapecast.js","../../node_modules/three-mesh-bvh/src/core/cast/bvhcast.js","../../node_modules/three-mesh-bvh/src/core/BVH.js","../../node_modules/three-mesh-bvh/src/utils/BufferUtils.js","../../node_modules/three-mesh-bvh/src/core/build/geometryUtils.js","../../node_modules/three-mesh-bvh/src/core/GeometryBVH.js","../../node_modules/three-mesh-bvh/src/math/SeparatingAxisBounds.js","../../node_modules/three-mesh-bvh/src/math/MathUtilities.js","../../node_modules/three-mesh-bvh/src/math/ExtendedTriangle.js","../../node_modules/three-mesh-bvh/src/math/OrientedBox.js","../../node_modules/three-mesh-bvh/src/utils/ExtendedTrianglePool.js","../../node_modules/three-mesh-bvh/src/core/cast/closestPointToPoint.js","../../node_modules/three-mesh-bvh/src/utils/ThreeRayIntersectUtilities.js","../../node_modules/three-mesh-bvh/src/utils/TriangleUtilities.js","../../node_modules/three-mesh-bvh/src/core/utils/iterationUtils.generated.js","../../node_modules/three-mesh-bvh/src/core/cast/refit.generated.js","../../node_modules/three-mesh-bvh/src/core/utils/intersectUtils.js","../../node_modules/three-mesh-bvh/src/core/utils/iterationUtils_indirect.generated.js","../../node_modules/three-mesh-bvh/src/core/cast/raycast.generated.js","../../node_modules/three-mesh-bvh/src/core/cast/raycastFirst.generated.js","../../node_modules/three-mesh-bvh/src/core/cast/intersectsGeometry.generated.js","../../node_modules/three-mesh-bvh/src/core/cast/closestPointToGeometry.generated.js","../../node_modules/three-mesh-bvh/src/core/cast/refit_indirect.generated.js","../../node_modules/three-mesh-bvh/src/core/cast/raycast_indirect.generated.js","../../node_modules/three-mesh-bvh/src/core/cast/raycastFirst_indirect.generated.js","../../node_modules/three-mesh-bvh/src/core/cast/intersectsGeometry_indirect.generated.js","../../node_modules/three-mesh-bvh/src/core/cast/closestPointToGeometry_indirect.generated.js","../../node_modules/three-mesh-bvh/src/utils/GeometryRayIntersectUtilities.js","../../node_modules/three-mesh-bvh/src/core/MeshBVH.js","../../node_modules/three-bvh-csg/src/core/utils/hashUtils.js","../../node_modules/three-bvh-csg/src/core/utils/geometryUtils.js","../../node_modules/three-bvh-csg/src/core/utils/halfEdgeUtils.js","../../node_modules/three-bvh-csg/src/core/utils/RaySet.js","../../node_modules/three-bvh-csg/src/core/utils/computeDisjointEdges.js","../../node_modules/three-bvh-csg/src/core/HalfEdgeMap.js","../../node_modules/three-bvh-csg/src/core/Brush.js","../../node_modules/three-bvh-csg/src/core/utils/triangleUtils.js","../../node_modules/three-bvh-csg/src/core/TriangleSplitter.js","../../node_modules/three-bvh-csg/src/core/TypeBackedArray.js","../../node_modules/three-bvh-csg/src/core/TypedAttributeData.js","../../node_modules/three-bvh-csg/src/core/IntersectionMap.js","../../node_modules/three-bvh-csg/src/core/constants.js","../../node_modules/three-bvh-csg/src/core/operations/operationsUtils.js","../../node_modules/three-bvh-csg/src/core/debug/OperationDebugData.js","../../node_modules/three-bvh-csg/src/core/operations/operations.js","../../node_modules/three-bvh-csg/src/core/Evaluator.js","../../src/main.js"],"sourcesContent":["import * as THREE from 'three';\n\n/**\n * Scene manager for the 3D environment\n * Handles scene initialization and basic lighting setup\n */\nexport class SceneManager {\n  constructor() {\n    this.scene = new THREE.Scene();\n    this.scene.background = new THREE.Color(0x1a1a1a);\n    \n    this.setupLighting();\n  }\n\n  /**\n   * Sets up ambient and directional lighting\n   */\n  setupLighting() {\n    // Ambient light for overall illumination\n    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);\n    this.scene.add(ambientLight);\n\n    // Directional light for shadows and depth\n    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);\n    directionalLight.position.set(5, 10, 7);\n    this.scene.add(directionalLight);\n\n    // Additional fill light from opposite side\n    const fillLight = new THREE.DirectionalLight(0xffffff, 0.3);\n    fillLight.position.set(-5, 5, -7);\n    this.scene.add(fillLight);\n  }\n\n  /**\n   * Add an object to the scene\n   * @param {THREE.Object3D} object - Object to add\n   */\n  add(object) {\n    this.scene.add(object);\n  }\n\n  /**\n   * Remove an object from the scene\n   * @param {THREE.Object3D} object - Object to remove\n   */\n  remove(object) {\n    this.scene.remove(object);\n  }\n\n  /**\n   * Get the Three.js scene instance\n   * @returns {THREE.Scene}\n   */\n  getScene() {\n    return this.scene;\n  }\n}\n\n\n\n","import {\n\tControls,\n\tMOUSE,\n\tQuaternion,\n\tSpherical,\n\tTOUCH,\n\tVector2,\n\tVector3,\n\tPlane,\n\tRay,\n\tMathUtils\n} from 'three';\n\n/**\n * Fires when the camera has been transformed by the controls.\n *\n * @event OrbitControls#change\n * @type {Object}\n */\nconst _changeEvent = { type: 'change' };\n\n/**\n * Fires when an interaction was initiated.\n *\n * @event OrbitControls#start\n * @type {Object}\n */\nconst _startEvent = { type: 'start' };\n\n/**\n * Fires when an interaction has finished.\n *\n * @event OrbitControls#end\n * @type {Object}\n */\nconst _endEvent = { type: 'end' };\n\nconst _ray = new Ray();\nconst _plane = new Plane();\nconst _TILT_LIMIT = Math.cos( 70 * MathUtils.DEG2RAD );\n\nconst _v = new Vector3();\nconst _twoPI = 2 * Math.PI;\n\nconst _STATE = {\n\tNONE: - 1,\n\tROTATE: 0,\n\tDOLLY: 1,\n\tPAN: 2,\n\tTOUCH_ROTATE: 3,\n\tTOUCH_PAN: 4,\n\tTOUCH_DOLLY_PAN: 5,\n\tTOUCH_DOLLY_ROTATE: 6\n};\nconst _EPS = 0.000001;\n\n\n/**\n * Orbit controls allow the camera to orbit around a target.\n *\n * OrbitControls performs orbiting, dollying (zooming), and panning. Unlike {@link TrackballControls},\n * it maintains the \"up\" direction `object.up` (+Y by default).\n *\n * - Orbit: Left mouse / touch: one-finger move.\n * - Zoom: Middle mouse, or mousewheel / touch: two-finger spread or squish.\n * - Pan: Right mouse, or left mouse + ctrl/meta/shiftKey, or arrow keys / touch: two-finger move.\n *\n * ```js\n * const controls = new OrbitControls( camera, renderer.domElement );\n *\n * // controls.update() must be called after any manual changes to the camera's transform\n * camera.position.set( 0, 20, 100 );\n * controls.update();\n *\n * function animate() {\n *\n * \t// required if controls.enableDamping or controls.autoRotate are set to true\n * \tcontrols.update();\n *\n * \trenderer.render( scene, camera );\n *\n * }\n * ```\n *\n * @augments Controls\n * @three_import import { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n */\nclass OrbitControls extends Controls {\n\n\t/**\n\t * Constructs a new controls instance.\n\t *\n\t * @param {Object3D} object - The object that is managed by the controls.\n\t * @param {?HTMLElement} domElement - The HTML element used for event listeners.\n\t */\n\tconstructor( object, domElement = null ) {\n\n\t\tsuper( object, domElement );\n\n\t\tthis.state = _STATE.NONE;\n\n\t\t/**\n\t\t * The focus point of the controls, the `object` orbits around this.\n\t\t * It can be updated manually at any point to change the focus of the controls.\n\t\t *\n\t\t * @type {Vector3}\n\t\t */\n\t\tthis.target = new Vector3();\n\n\t\t/**\n\t\t * The focus point of the `minTargetRadius` and `maxTargetRadius` limits.\n\t\t * It can be updated manually at any point to change the center of interest\n\t\t * for the `target`.\n\t\t *\n\t\t * @type {Vector3}\n\t\t */\n\t\tthis.cursor = new Vector3();\n\n\t\t/**\n\t\t * How far you can dolly in (perspective camera only).\n\t\t *\n\t\t * @type {number}\n\t\t * @default 0\n\t\t */\n\t\tthis.minDistance = 0;\n\n\t\t/**\n\t\t * How far you can dolly out (perspective camera only).\n\t\t *\n\t\t * @type {number}\n\t\t * @default Infinity\n\t\t */\n\t\tthis.maxDistance = Infinity;\n\n\t\t/**\n\t\t * How far you can zoom in (orthographic camera only).\n\t\t *\n\t\t * @type {number}\n\t\t * @default 0\n\t\t */\n\t\tthis.minZoom = 0;\n\n\t\t/**\n\t\t * How far you can zoom out (orthographic camera only).\n\t\t *\n\t\t * @type {number}\n\t\t * @default Infinity\n\t\t */\n\t\tthis.maxZoom = Infinity;\n\n\t\t/**\n\t\t * How close you can get the target to the 3D `cursor`.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 0\n\t\t */\n\t\tthis.minTargetRadius = 0;\n\n\t\t/**\n\t\t * How far you can move the target from the 3D `cursor`.\n\t\t *\n\t\t * @type {number}\n\t\t * @default Infinity\n\t\t */\n\t\tthis.maxTargetRadius = Infinity;\n\n\t\t/**\n\t\t * How far you can orbit vertically, lower limit. Range is `[0, Math.PI]` radians.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 0\n\t\t */\n\t\tthis.minPolarAngle = 0;\n\n\t\t/**\n\t\t * How far you can orbit vertically, upper limit. Range is `[0, Math.PI]` radians.\n\t\t *\n\t\t * @type {number}\n\t\t * @default Math.PI\n\t\t */\n\t\tthis.maxPolarAngle = Math.PI;\n\n\t\t/**\n\t\t * How far you can orbit horizontally, lower limit. If set, the interval `[ min, max ]`\n\t\t * must be a sub-interval of `[ - 2 PI, 2 PI ]`, with `( max - min < 2 PI )`.\n\t\t *\n\t\t * @type {number}\n\t\t * @default -Infinity\n\t\t */\n\t\tthis.minAzimuthAngle = - Infinity;\n\n\t\t/**\n\t\t * How far you can orbit horizontally, upper limit. If set, the interval `[ min, max ]`\n\t\t * must be a sub-interval of `[ - 2 PI, 2 PI ]`, with `( max - min < 2 PI )`.\n\t\t *\n\t\t * @type {number}\n\t\t * @default -Infinity\n\t\t */\n\t\tthis.maxAzimuthAngle = Infinity;\n\n\t\t/**\n\t\t * Set to `true` to enable damping (inertia), which can be used to give a sense of weight\n\t\t * to the controls. Note that if this is enabled, you must call `update()` in your animation\n\t\t * loop.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.enableDamping = false;\n\n\t\t/**\n\t\t * The damping inertia used if `enableDamping` is set to `true`.\n\t\t *\n\t\t * Note that for this to work, you must call `update()` in your animation loop.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 0.05\n\t\t */\n\t\tthis.dampingFactor = 0.05;\n\n\t\t/**\n\t\t * Enable or disable zooming (dollying) of the camera.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.enableZoom = true;\n\n\t\t/**\n\t\t * Speed of zooming / dollying.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 1\n\t\t */\n\t\tthis.zoomSpeed = 1.0;\n\n\t\t/**\n\t\t * Enable or disable horizontal and vertical rotation of the camera.\n\t\t *\n\t\t * Note that it is possible to disable a single axis by setting the min and max of the\n\t\t * `minPolarAngle` or `minAzimuthAngle` to the same value, which will cause the vertical\n\t\t * or horizontal rotation to be fixed at that value.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.enableRotate = true;\n\n\t\t/**\n\t\t * Speed of rotation.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 1\n\t\t */\n\t\tthis.rotateSpeed = 1.0;\n\n\t\t/**\n\t\t * How fast to rotate the camera when the keyboard is used.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 1\n\t\t */\n\t\tthis.keyRotateSpeed = 1.0;\n\n\t\t/**\n\t\t * Enable or disable camera panning.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.enablePan = true;\n\n\t\t/**\n\t\t * Speed of panning.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 1\n\t\t */\n\t\tthis.panSpeed = 1.0;\n\n\t\t/**\n\t\t * Defines how the camera's position is translated when panning. If `true`, the camera pans\n\t\t * in screen space. Otherwise, the camera pans in the plane orthogonal to the camera's up\n\t\t * direction.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.screenSpacePanning = true;\n\n\t\t/**\n\t\t * How fast to pan the camera when the keyboard is used in\n\t\t * pixels per keypress.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 7\n\t\t */\n\t\tthis.keyPanSpeed = 7.0;\n\n\t\t/**\n\t\t * Setting this property to `true` allows to zoom to the cursor's position.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.zoomToCursor = false;\n\n\t\t/**\n\t\t * Set to true to automatically rotate around the target\n\t\t *\n\t\t * Note that if this is enabled, you must call `update()` in your animation loop.\n\t\t * If you want the auto-rotate speed to be independent of the frame rate (the refresh\n\t\t * rate of the display), you must pass the time `deltaTime`, in seconds, to `update()`.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.autoRotate = false;\n\n\t\t/**\n\t\t * How fast to rotate around the target if `autoRotate` is `true`. The default  equates to 30 seconds\n\t\t * per orbit at 60fps.\n\t\t *\n\t\t * Note that if `autoRotate` is enabled, you must call `update()` in your animation loop.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 2\n\t\t */\n\t\tthis.autoRotateSpeed = 2.0;\n\n\t\t/**\n\t\t * This object contains references to the keycodes for controlling camera panning.\n\t\t *\n\t\t * ```js\n\t\t * controls.keys = {\n\t\t * \tLEFT: 'ArrowLeft', //left arrow\n\t\t * \tUP: 'ArrowUp', // up arrow\n\t\t * \tRIGHT: 'ArrowRight', // right arrow\n\t\t * \tBOTTOM: 'ArrowDown' // down arrow\n\t\t * }\n\t\t * ```\n\t\t * @type {Object}\n\t\t */\n\t\tthis.keys = { LEFT: 'ArrowLeft', UP: 'ArrowUp', RIGHT: 'ArrowRight', BOTTOM: 'ArrowDown' };\n\n\t\t/**\n\t\t * This object contains references to the mouse actions used by the controls.\n\t\t *\n\t\t * ```js\n\t\t * controls.mouseButtons = {\n\t\t * \tLEFT: THREE.MOUSE.ROTATE,\n\t\t * \tMIDDLE: THREE.MOUSE.DOLLY,\n\t\t * \tRIGHT: THREE.MOUSE.PAN\n\t\t * }\n\t\t * ```\n\t\t * @type {Object}\n\t\t */\n\t\tthis.mouseButtons = { LEFT: MOUSE.ROTATE, MIDDLE: MOUSE.DOLLY, RIGHT: MOUSE.PAN };\n\n\t\t/**\n\t\t * This object contains references to the touch actions used by the controls.\n\t\t *\n\t\t * ```js\n\t\t * controls.mouseButtons = {\n\t\t * \tONE: THREE.TOUCH.ROTATE,\n\t\t * \tTWO: THREE.TOUCH.DOLLY_PAN\n\t\t * }\n\t\t * ```\n\t\t * @type {Object}\n\t\t */\n\t\tthis.touches = { ONE: TOUCH.ROTATE, TWO: TOUCH.DOLLY_PAN };\n\n\t\t/**\n\t\t * Used internally by `saveState()` and `reset()`.\n\t\t *\n\t\t * @type {Vector3}\n\t\t */\n\t\tthis.target0 = this.target.clone();\n\n\t\t/**\n\t\t * Used internally by `saveState()` and `reset()`.\n\t\t *\n\t\t * @type {Vector3}\n\t\t */\n\t\tthis.position0 = this.object.position.clone();\n\n\t\t/**\n\t\t * Used internally by `saveState()` and `reset()`.\n\t\t *\n\t\t * @type {number}\n\t\t */\n\t\tthis.zoom0 = this.object.zoom;\n\n\t\t// the target DOM element for key events\n\t\tthis._domElementKeyEvents = null;\n\n\t\t// internals\n\n\t\tthis._lastPosition = new Vector3();\n\t\tthis._lastQuaternion = new Quaternion();\n\t\tthis._lastTargetPosition = new Vector3();\n\n\t\t// so camera.up is the orbit axis\n\t\tthis._quat = new Quaternion().setFromUnitVectors( object.up, new Vector3( 0, 1, 0 ) );\n\t\tthis._quatInverse = this._quat.clone().invert();\n\n\t\t// current position in spherical coordinates\n\t\tthis._spherical = new Spherical();\n\t\tthis._sphericalDelta = new Spherical();\n\n\t\tthis._scale = 1;\n\t\tthis._panOffset = new Vector3();\n\n\t\tthis._rotateStart = new Vector2();\n\t\tthis._rotateEnd = new Vector2();\n\t\tthis._rotateDelta = new Vector2();\n\n\t\tthis._panStart = new Vector2();\n\t\tthis._panEnd = new Vector2();\n\t\tthis._panDelta = new Vector2();\n\n\t\tthis._dollyStart = new Vector2();\n\t\tthis._dollyEnd = new Vector2();\n\t\tthis._dollyDelta = new Vector2();\n\n\t\tthis._dollyDirection = new Vector3();\n\t\tthis._mouse = new Vector2();\n\t\tthis._performCursorZoom = false;\n\n\t\tthis._pointers = [];\n\t\tthis._pointerPositions = {};\n\n\t\tthis._controlActive = false;\n\n\t\t// event listeners\n\n\t\tthis._onPointerMove = onPointerMove.bind( this );\n\t\tthis._onPointerDown = onPointerDown.bind( this );\n\t\tthis._onPointerUp = onPointerUp.bind( this );\n\t\tthis._onContextMenu = onContextMenu.bind( this );\n\t\tthis._onMouseWheel = onMouseWheel.bind( this );\n\t\tthis._onKeyDown = onKeyDown.bind( this );\n\n\t\tthis._onTouchStart = onTouchStart.bind( this );\n\t\tthis._onTouchMove = onTouchMove.bind( this );\n\n\t\tthis._onMouseDown = onMouseDown.bind( this );\n\t\tthis._onMouseMove = onMouseMove.bind( this );\n\n\t\tthis._interceptControlDown = interceptControlDown.bind( this );\n\t\tthis._interceptControlUp = interceptControlUp.bind( this );\n\n\t\t//\n\n\t\tif ( this.domElement !== null ) {\n\n\t\t\tthis.connect( this.domElement );\n\n\t\t}\n\n\t\tthis.update();\n\n\t}\n\n\tconnect( element ) {\n\n\t\tsuper.connect( element );\n\n\t\tthis.domElement.addEventListener( 'pointerdown', this._onPointerDown );\n\t\tthis.domElement.addEventListener( 'pointercancel', this._onPointerUp );\n\n\t\tthis.domElement.addEventListener( 'contextmenu', this._onContextMenu );\n\t\tthis.domElement.addEventListener( 'wheel', this._onMouseWheel, { passive: false } );\n\n\t\tconst document = this.domElement.getRootNode(); // offscreen canvas compatibility\n\t\tdocument.addEventListener( 'keydown', this._interceptControlDown, { passive: true, capture: true } );\n\n\t\tthis.domElement.style.touchAction = 'none'; // disable touch scroll\n\n\t}\n\n\tdisconnect() {\n\n\t\tthis.domElement.removeEventListener( 'pointerdown', this._onPointerDown );\n\t\tthis.domElement.ownerDocument.removeEventListener( 'pointermove', this._onPointerMove );\n\t\tthis.domElement.ownerDocument.removeEventListener( 'pointerup', this._onPointerUp );\n\t\tthis.domElement.removeEventListener( 'pointercancel', this._onPointerUp );\n\n\t\tthis.domElement.removeEventListener( 'wheel', this._onMouseWheel );\n\t\tthis.domElement.removeEventListener( 'contextmenu', this._onContextMenu );\n\n\t\tthis.stopListenToKeyEvents();\n\n\t\tconst document = this.domElement.getRootNode(); // offscreen canvas compatibility\n\t\tdocument.removeEventListener( 'keydown', this._interceptControlDown, { capture: true } );\n\n\t\tthis.domElement.style.touchAction = 'auto';\n\n\t}\n\n\tdispose() {\n\n\t\tthis.disconnect();\n\n\t}\n\n\t/**\n\t * Get the current vertical rotation, in radians.\n\t *\n\t * @return {number} The current vertical rotation, in radians.\n\t */\n\tgetPolarAngle() {\n\n\t\treturn this._spherical.phi;\n\n\t}\n\n\t/**\n\t * Get the current horizontal rotation, in radians.\n\t *\n\t * @return {number} The current horizontal rotation, in radians.\n\t */\n\tgetAzimuthalAngle() {\n\n\t\treturn this._spherical.theta;\n\n\t}\n\n\t/**\n\t * Returns the distance from the camera to the target.\n\t *\n\t * @return {number} The distance from the camera to the target.\n\t */\n\tgetDistance() {\n\n\t\treturn this.object.position.distanceTo( this.target );\n\n\t}\n\n\t/**\n\t * Adds key event listeners to the given DOM element.\n\t * `window` is a recommended argument for using this method.\n\t *\n\t * @param {HTMLElement} domElement - The DOM element\n\t */\n\tlistenToKeyEvents( domElement ) {\n\n\t\tdomElement.addEventListener( 'keydown', this._onKeyDown );\n\t\tthis._domElementKeyEvents = domElement;\n\n\t}\n\n\t/**\n\t * Removes the key event listener previously defined with `listenToKeyEvents()`.\n\t */\n\tstopListenToKeyEvents() {\n\n\t\tif ( this._domElementKeyEvents !== null ) {\n\n\t\t\tthis._domElementKeyEvents.removeEventListener( 'keydown', this._onKeyDown );\n\t\t\tthis._domElementKeyEvents = null;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Save the current state of the controls. This can later be recovered with `reset()`.\n\t */\n\tsaveState() {\n\n\t\tthis.target0.copy( this.target );\n\t\tthis.position0.copy( this.object.position );\n\t\tthis.zoom0 = this.object.zoom;\n\n\t}\n\n\t/**\n\t * Reset the controls to their state from either the last time the `saveState()`\n\t * was called, or the initial state.\n\t */\n\treset() {\n\n\t\tthis.target.copy( this.target0 );\n\t\tthis.object.position.copy( this.position0 );\n\t\tthis.object.zoom = this.zoom0;\n\n\t\tthis.object.updateProjectionMatrix();\n\t\tthis.dispatchEvent( _changeEvent );\n\n\t\tthis.update();\n\n\t\tthis.state = _STATE.NONE;\n\n\t}\n\n\tupdate( deltaTime = null ) {\n\n\t\tconst position = this.object.position;\n\n\t\t_v.copy( position ).sub( this.target );\n\n\t\t// rotate offset to \"y-axis-is-up\" space\n\t\t_v.applyQuaternion( this._quat );\n\n\t\t// angle from z-axis around y-axis\n\t\tthis._spherical.setFromVector3( _v );\n\n\t\tif ( this.autoRotate && this.state === _STATE.NONE ) {\n\n\t\t\tthis._rotateLeft( this._getAutoRotationAngle( deltaTime ) );\n\n\t\t}\n\n\t\tif ( this.enableDamping ) {\n\n\t\t\tthis._spherical.theta += this._sphericalDelta.theta * this.dampingFactor;\n\t\t\tthis._spherical.phi += this._sphericalDelta.phi * this.dampingFactor;\n\n\t\t} else {\n\n\t\t\tthis._spherical.theta += this._sphericalDelta.theta;\n\t\t\tthis._spherical.phi += this._sphericalDelta.phi;\n\n\t\t}\n\n\t\t// restrict theta to be between desired limits\n\n\t\tlet min = this.minAzimuthAngle;\n\t\tlet max = this.maxAzimuthAngle;\n\n\t\tif ( isFinite( min ) && isFinite( max ) ) {\n\n\t\t\tif ( min < - Math.PI ) min += _twoPI; else if ( min > Math.PI ) min -= _twoPI;\n\n\t\t\tif ( max < - Math.PI ) max += _twoPI; else if ( max > Math.PI ) max -= _twoPI;\n\n\t\t\tif ( min <= max ) {\n\n\t\t\t\tthis._spherical.theta = Math.max( min, Math.min( max, this._spherical.theta ) );\n\n\t\t\t} else {\n\n\t\t\t\tthis._spherical.theta = ( this._spherical.theta > ( min + max ) / 2 ) ?\n\t\t\t\t\tMath.max( min, this._spherical.theta ) :\n\t\t\t\t\tMath.min( max, this._spherical.theta );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// restrict phi to be between desired limits\n\t\tthis._spherical.phi = Math.max( this.minPolarAngle, Math.min( this.maxPolarAngle, this._spherical.phi ) );\n\n\t\tthis._spherical.makeSafe();\n\n\n\t\t// move target to panned location\n\n\t\tif ( this.enableDamping === true ) {\n\n\t\t\tthis.target.addScaledVector( this._panOffset, this.dampingFactor );\n\n\t\t} else {\n\n\t\t\tthis.target.add( this._panOffset );\n\n\t\t}\n\n\t\t// Limit the target distance from the cursor to create a sphere around the center of interest\n\t\tthis.target.sub( this.cursor );\n\t\tthis.target.clampLength( this.minTargetRadius, this.maxTargetRadius );\n\t\tthis.target.add( this.cursor );\n\n\t\tlet zoomChanged = false;\n\t\t// adjust the camera position based on zoom only if we're not zooming to the cursor or if it's an ortho camera\n\t\t// we adjust zoom later in these cases\n\t\tif ( this.zoomToCursor && this._performCursorZoom || this.object.isOrthographicCamera ) {\n\n\t\t\tthis._spherical.radius = this._clampDistance( this._spherical.radius );\n\n\t\t} else {\n\n\t\t\tconst prevRadius = this._spherical.radius;\n\t\t\tthis._spherical.radius = this._clampDistance( this._spherical.radius * this._scale );\n\t\t\tzoomChanged = prevRadius != this._spherical.radius;\n\n\t\t}\n\n\t\t_v.setFromSpherical( this._spherical );\n\n\t\t// rotate offset back to \"camera-up-vector-is-up\" space\n\t\t_v.applyQuaternion( this._quatInverse );\n\n\t\tposition.copy( this.target ).add( _v );\n\n\t\tthis.object.lookAt( this.target );\n\n\t\tif ( this.enableDamping === true ) {\n\n\t\t\tthis._sphericalDelta.theta *= ( 1 - this.dampingFactor );\n\t\t\tthis._sphericalDelta.phi *= ( 1 - this.dampingFactor );\n\n\t\t\tthis._panOffset.multiplyScalar( 1 - this.dampingFactor );\n\n\t\t} else {\n\n\t\t\tthis._sphericalDelta.set( 0, 0, 0 );\n\n\t\t\tthis._panOffset.set( 0, 0, 0 );\n\n\t\t}\n\n\t\t// adjust camera position\n\t\tif ( this.zoomToCursor && this._performCursorZoom ) {\n\n\t\t\tlet newRadius = null;\n\t\t\tif ( this.object.isPerspectiveCamera ) {\n\n\t\t\t\t// move the camera down the pointer ray\n\t\t\t\t// this method avoids floating point error\n\t\t\t\tconst prevRadius = _v.length();\n\t\t\t\tnewRadius = this._clampDistance( prevRadius * this._scale );\n\n\t\t\t\tconst radiusDelta = prevRadius - newRadius;\n\t\t\t\tthis.object.position.addScaledVector( this._dollyDirection, radiusDelta );\n\t\t\t\tthis.object.updateMatrixWorld();\n\n\t\t\t\tzoomChanged = !! radiusDelta;\n\n\t\t\t} else if ( this.object.isOrthographicCamera ) {\n\n\t\t\t\t// adjust the ortho camera position based on zoom changes\n\t\t\t\tconst mouseBefore = new Vector3( this._mouse.x, this._mouse.y, 0 );\n\t\t\t\tmouseBefore.unproject( this.object );\n\n\t\t\t\tconst prevZoom = this.object.zoom;\n\t\t\t\tthis.object.zoom = Math.max( this.minZoom, Math.min( this.maxZoom, this.object.zoom / this._scale ) );\n\t\t\t\tthis.object.updateProjectionMatrix();\n\n\t\t\t\tzoomChanged = prevZoom !== this.object.zoom;\n\n\t\t\t\tconst mouseAfter = new Vector3( this._mouse.x, this._mouse.y, 0 );\n\t\t\t\tmouseAfter.unproject( this.object );\n\n\t\t\t\tthis.object.position.sub( mouseAfter ).add( mouseBefore );\n\t\t\t\tthis.object.updateMatrixWorld();\n\n\t\t\t\tnewRadius = _v.length();\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled.' );\n\t\t\t\tthis.zoomToCursor = false;\n\n\t\t\t}\n\n\t\t\t// handle the placement of the target\n\t\t\tif ( newRadius !== null ) {\n\n\t\t\t\tif ( this.screenSpacePanning ) {\n\n\t\t\t\t\t// position the orbit target in front of the new camera position\n\t\t\t\t\tthis.target.set( 0, 0, - 1 )\n\t\t\t\t\t\t.transformDirection( this.object.matrix )\n\t\t\t\t\t\t.multiplyScalar( newRadius )\n\t\t\t\t\t\t.add( this.object.position );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// get the ray and translation plane to compute target\n\t\t\t\t\t_ray.origin.copy( this.object.position );\n\t\t\t\t\t_ray.direction.set( 0, 0, - 1 ).transformDirection( this.object.matrix );\n\n\t\t\t\t\t// if the camera is 20 degrees above the horizon then don't adjust the focus target to avoid\n\t\t\t\t\t// extremely large values\n\t\t\t\t\tif ( Math.abs( this.object.up.dot( _ray.direction ) ) < _TILT_LIMIT ) {\n\n\t\t\t\t\t\tthis.object.lookAt( this.target );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t_plane.setFromNormalAndCoplanarPoint( this.object.up, this.target );\n\t\t\t\t\t\t_ray.intersectPlane( _plane, this.target );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ( this.object.isOrthographicCamera ) {\n\n\t\t\tconst prevZoom = this.object.zoom;\n\t\t\tthis.object.zoom = Math.max( this.minZoom, Math.min( this.maxZoom, this.object.zoom / this._scale ) );\n\n\t\t\tif ( prevZoom !== this.object.zoom ) {\n\n\t\t\t\tthis.object.updateProjectionMatrix();\n\t\t\t\tzoomChanged = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis._scale = 1;\n\t\tthis._performCursorZoom = false;\n\n\t\t// update condition is:\n\t\t// min(camera displacement, camera rotation in radians)^2 > EPS\n\t\t// using small-angle approximation cos(x/2) = 1 - x^2 / 8\n\n\t\tif ( zoomChanged ||\n\t\t\tthis._lastPosition.distanceToSquared( this.object.position ) > _EPS ||\n\t\t\t8 * ( 1 - this._lastQuaternion.dot( this.object.quaternion ) ) > _EPS ||\n\t\t\tthis._lastTargetPosition.distanceToSquared( this.target ) > _EPS ) {\n\n\t\t\tthis.dispatchEvent( _changeEvent );\n\n\t\t\tthis._lastPosition.copy( this.object.position );\n\t\t\tthis._lastQuaternion.copy( this.object.quaternion );\n\t\t\tthis._lastTargetPosition.copy( this.target );\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\t_getAutoRotationAngle( deltaTime ) {\n\n\t\tif ( deltaTime !== null ) {\n\n\t\t\treturn ( _twoPI / 60 * this.autoRotateSpeed ) * deltaTime;\n\n\t\t} else {\n\n\t\t\treturn _twoPI / 60 / 60 * this.autoRotateSpeed;\n\n\t\t}\n\n\t}\n\n\t_getZoomScale( delta ) {\n\n\t\tconst normalizedDelta = Math.abs( delta * 0.01 );\n\t\treturn Math.pow( 0.95, this.zoomSpeed * normalizedDelta );\n\n\t}\n\n\t_rotateLeft( angle ) {\n\n\t\tthis._sphericalDelta.theta -= angle;\n\n\t}\n\n\t_rotateUp( angle ) {\n\n\t\tthis._sphericalDelta.phi -= angle;\n\n\t}\n\n\t_panLeft( distance, objectMatrix ) {\n\n\t\t_v.setFromMatrixColumn( objectMatrix, 0 ); // get X column of objectMatrix\n\t\t_v.multiplyScalar( - distance );\n\n\t\tthis._panOffset.add( _v );\n\n\t}\n\n\t_panUp( distance, objectMatrix ) {\n\n\t\tif ( this.screenSpacePanning === true ) {\n\n\t\t\t_v.setFromMatrixColumn( objectMatrix, 1 );\n\n\t\t} else {\n\n\t\t\t_v.setFromMatrixColumn( objectMatrix, 0 );\n\t\t\t_v.crossVectors( this.object.up, _v );\n\n\t\t}\n\n\t\t_v.multiplyScalar( distance );\n\n\t\tthis._panOffset.add( _v );\n\n\t}\n\n\t// deltaX and deltaY are in pixels; right and down are positive\n\t_pan( deltaX, deltaY ) {\n\n\t\tconst element = this.domElement;\n\n\t\tif ( this.object.isPerspectiveCamera ) {\n\n\t\t\t// perspective\n\t\t\tconst position = this.object.position;\n\t\t\t_v.copy( position ).sub( this.target );\n\t\t\tlet targetDistance = _v.length();\n\n\t\t\t// half of the fov is center to top of screen\n\t\t\ttargetDistance *= Math.tan( ( this.object.fov / 2 ) * Math.PI / 180.0 );\n\n\t\t\t// we use only clientHeight here so aspect ratio does not distort speed\n\t\t\tthis._panLeft( 2 * deltaX * targetDistance / element.clientHeight, this.object.matrix );\n\t\t\tthis._panUp( 2 * deltaY * targetDistance / element.clientHeight, this.object.matrix );\n\n\t\t} else if ( this.object.isOrthographicCamera ) {\n\n\t\t\t// orthographic\n\t\t\tthis._panLeft( deltaX * ( this.object.right - this.object.left ) / this.object.zoom / element.clientWidth, this.object.matrix );\n\t\t\tthis._panUp( deltaY * ( this.object.top - this.object.bottom ) / this.object.zoom / element.clientHeight, this.object.matrix );\n\n\t\t} else {\n\n\t\t\t// camera neither orthographic nor perspective\n\t\t\tconsole.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.' );\n\t\t\tthis.enablePan = false;\n\n\t\t}\n\n\t}\n\n\t_dollyOut( dollyScale ) {\n\n\t\tif ( this.object.isPerspectiveCamera || this.object.isOrthographicCamera ) {\n\n\t\t\tthis._scale /= dollyScale;\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );\n\t\t\tthis.enableZoom = false;\n\n\t\t}\n\n\t}\n\n\t_dollyIn( dollyScale ) {\n\n\t\tif ( this.object.isPerspectiveCamera || this.object.isOrthographicCamera ) {\n\n\t\t\tthis._scale *= dollyScale;\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );\n\t\t\tthis.enableZoom = false;\n\n\t\t}\n\n\t}\n\n\t_updateZoomParameters( x, y ) {\n\n\t\tif ( ! this.zoomToCursor ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis._performCursorZoom = true;\n\n\t\tconst rect = this.domElement.getBoundingClientRect();\n\t\tconst dx = x - rect.left;\n\t\tconst dy = y - rect.top;\n\t\tconst w = rect.width;\n\t\tconst h = rect.height;\n\n\t\tthis._mouse.x = ( dx / w ) * 2 - 1;\n\t\tthis._mouse.y = - ( dy / h ) * 2 + 1;\n\n\t\tthis._dollyDirection.set( this._mouse.x, this._mouse.y, 1 ).unproject( this.object ).sub( this.object.position ).normalize();\n\n\t}\n\n\t_clampDistance( dist ) {\n\n\t\treturn Math.max( this.minDistance, Math.min( this.maxDistance, dist ) );\n\n\t}\n\n\t//\n\t// event callbacks - update the object state\n\t//\n\n\t_handleMouseDownRotate( event ) {\n\n\t\tthis._rotateStart.set( event.clientX, event.clientY );\n\n\t}\n\n\t_handleMouseDownDolly( event ) {\n\n\t\tthis._updateZoomParameters( event.clientX, event.clientX );\n\t\tthis._dollyStart.set( event.clientX, event.clientY );\n\n\t}\n\n\t_handleMouseDownPan( event ) {\n\n\t\tthis._panStart.set( event.clientX, event.clientY );\n\n\t}\n\n\t_handleMouseMoveRotate( event ) {\n\n\t\tthis._rotateEnd.set( event.clientX, event.clientY );\n\n\t\tthis._rotateDelta.subVectors( this._rotateEnd, this._rotateStart ).multiplyScalar( this.rotateSpeed );\n\n\t\tconst element = this.domElement;\n\n\t\tthis._rotateLeft( _twoPI * this._rotateDelta.x / element.clientHeight ); // yes, height\n\n\t\tthis._rotateUp( _twoPI * this._rotateDelta.y / element.clientHeight );\n\n\t\tthis._rotateStart.copy( this._rotateEnd );\n\n\t\tthis.update();\n\n\t}\n\n\t_handleMouseMoveDolly( event ) {\n\n\t\tthis._dollyEnd.set( event.clientX, event.clientY );\n\n\t\tthis._dollyDelta.subVectors( this._dollyEnd, this._dollyStart );\n\n\t\tif ( this._dollyDelta.y > 0 ) {\n\n\t\t\tthis._dollyOut( this._getZoomScale( this._dollyDelta.y ) );\n\n\t\t} else if ( this._dollyDelta.y < 0 ) {\n\n\t\t\tthis._dollyIn( this._getZoomScale( this._dollyDelta.y ) );\n\n\t\t}\n\n\t\tthis._dollyStart.copy( this._dollyEnd );\n\n\t\tthis.update();\n\n\t}\n\n\t_handleMouseMovePan( event ) {\n\n\t\tthis._panEnd.set( event.clientX, event.clientY );\n\n\t\tthis._panDelta.subVectors( this._panEnd, this._panStart ).multiplyScalar( this.panSpeed );\n\n\t\tthis._pan( this._panDelta.x, this._panDelta.y );\n\n\t\tthis._panStart.copy( this._panEnd );\n\n\t\tthis.update();\n\n\t}\n\n\t_handleMouseWheel( event ) {\n\n\t\tthis._updateZoomParameters( event.clientX, event.clientY );\n\n\t\tif ( event.deltaY < 0 ) {\n\n\t\t\tthis._dollyIn( this._getZoomScale( event.deltaY ) );\n\n\t\t} else if ( event.deltaY > 0 ) {\n\n\t\t\tthis._dollyOut( this._getZoomScale( event.deltaY ) );\n\n\t\t}\n\n\t\tthis.update();\n\n\t}\n\n\t_handleKeyDown( event ) {\n\n\t\tlet needsUpdate = false;\n\n\t\tswitch ( event.code ) {\n\n\t\t\tcase this.keys.UP:\n\n\t\t\t\tif ( event.ctrlKey || event.metaKey || event.shiftKey ) {\n\n\t\t\t\t\tif ( this.enableRotate ) {\n\n\t\t\t\t\t\tthis._rotateUp( _twoPI * this.keyRotateSpeed / this.domElement.clientHeight );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( this.enablePan ) {\n\n\t\t\t\t\t\tthis._pan( 0, this.keyPanSpeed );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tneedsUpdate = true;\n\t\t\t\tbreak;\n\n\t\t\tcase this.keys.BOTTOM:\n\n\t\t\t\tif ( event.ctrlKey || event.metaKey || event.shiftKey ) {\n\n\t\t\t\t\tif ( this.enableRotate ) {\n\n\t\t\t\t\t\tthis._rotateUp( - _twoPI * this.keyRotateSpeed / this.domElement.clientHeight );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( this.enablePan ) {\n\n\t\t\t\t\t\tthis._pan( 0, - this.keyPanSpeed );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tneedsUpdate = true;\n\t\t\t\tbreak;\n\n\t\t\tcase this.keys.LEFT:\n\n\t\t\t\tif ( event.ctrlKey || event.metaKey || event.shiftKey ) {\n\n\t\t\t\t\tif ( this.enableRotate ) {\n\n\t\t\t\t\t\tthis._rotateLeft( _twoPI * this.keyRotateSpeed / this.domElement.clientHeight );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( this.enablePan ) {\n\n\t\t\t\t\t\tthis._pan( this.keyPanSpeed, 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tneedsUpdate = true;\n\t\t\t\tbreak;\n\n\t\t\tcase this.keys.RIGHT:\n\n\t\t\t\tif ( event.ctrlKey || event.metaKey || event.shiftKey ) {\n\n\t\t\t\t\tif ( this.enableRotate ) {\n\n\t\t\t\t\t\tthis._rotateLeft( - _twoPI * this.keyRotateSpeed / this.domElement.clientHeight );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( this.enablePan ) {\n\n\t\t\t\t\t\tthis._pan( - this.keyPanSpeed, 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tneedsUpdate = true;\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\tif ( needsUpdate ) {\n\n\t\t\t// prevent the browser from scrolling on cursor keys\n\t\t\tevent.preventDefault();\n\n\t\t\tthis.update();\n\n\t\t}\n\n\n\t}\n\n\t_handleTouchStartRotate( event ) {\n\n\t\tif ( this._pointers.length === 1 ) {\n\n\t\t\tthis._rotateStart.set( event.pageX, event.pageY );\n\n\t\t} else {\n\n\t\t\tconst position = this._getSecondPointerPosition( event );\n\n\t\t\tconst x = 0.5 * ( event.pageX + position.x );\n\t\t\tconst y = 0.5 * ( event.pageY + position.y );\n\n\t\t\tthis._rotateStart.set( x, y );\n\n\t\t}\n\n\t}\n\n\t_handleTouchStartPan( event ) {\n\n\t\tif ( this._pointers.length === 1 ) {\n\n\t\t\tthis._panStart.set( event.pageX, event.pageY );\n\n\t\t} else {\n\n\t\t\tconst position = this._getSecondPointerPosition( event );\n\n\t\t\tconst x = 0.5 * ( event.pageX + position.x );\n\t\t\tconst y = 0.5 * ( event.pageY + position.y );\n\n\t\t\tthis._panStart.set( x, y );\n\n\t\t}\n\n\t}\n\n\t_handleTouchStartDolly( event ) {\n\n\t\tconst position = this._getSecondPointerPosition( event );\n\n\t\tconst dx = event.pageX - position.x;\n\t\tconst dy = event.pageY - position.y;\n\n\t\tconst distance = Math.sqrt( dx * dx + dy * dy );\n\n\t\tthis._dollyStart.set( 0, distance );\n\n\t}\n\n\t_handleTouchStartDollyPan( event ) {\n\n\t\tif ( this.enableZoom ) this._handleTouchStartDolly( event );\n\n\t\tif ( this.enablePan ) this._handleTouchStartPan( event );\n\n\t}\n\n\t_handleTouchStartDollyRotate( event ) {\n\n\t\tif ( this.enableZoom ) this._handleTouchStartDolly( event );\n\n\t\tif ( this.enableRotate ) this._handleTouchStartRotate( event );\n\n\t}\n\n\t_handleTouchMoveRotate( event ) {\n\n\t\tif ( this._pointers.length == 1 ) {\n\n\t\t\tthis._rotateEnd.set( event.pageX, event.pageY );\n\n\t\t} else {\n\n\t\t\tconst position = this._getSecondPointerPosition( event );\n\n\t\t\tconst x = 0.5 * ( event.pageX + position.x );\n\t\t\tconst y = 0.5 * ( event.pageY + position.y );\n\n\t\t\tthis._rotateEnd.set( x, y );\n\n\t\t}\n\n\t\tthis._rotateDelta.subVectors( this._rotateEnd, this._rotateStart ).multiplyScalar( this.rotateSpeed );\n\n\t\tconst element = this.domElement;\n\n\t\tthis._rotateLeft( _twoPI * this._rotateDelta.x / element.clientHeight ); // yes, height\n\n\t\tthis._rotateUp( _twoPI * this._rotateDelta.y / element.clientHeight );\n\n\t\tthis._rotateStart.copy( this._rotateEnd );\n\n\t}\n\n\t_handleTouchMovePan( event ) {\n\n\t\tif ( this._pointers.length === 1 ) {\n\n\t\t\tthis._panEnd.set( event.pageX, event.pageY );\n\n\t\t} else {\n\n\t\t\tconst position = this._getSecondPointerPosition( event );\n\n\t\t\tconst x = 0.5 * ( event.pageX + position.x );\n\t\t\tconst y = 0.5 * ( event.pageY + position.y );\n\n\t\t\tthis._panEnd.set( x, y );\n\n\t\t}\n\n\t\tthis._panDelta.subVectors( this._panEnd, this._panStart ).multiplyScalar( this.panSpeed );\n\n\t\tthis._pan( this._panDelta.x, this._panDelta.y );\n\n\t\tthis._panStart.copy( this._panEnd );\n\n\t}\n\n\t_handleTouchMoveDolly( event ) {\n\n\t\tconst position = this._getSecondPointerPosition( event );\n\n\t\tconst dx = event.pageX - position.x;\n\t\tconst dy = event.pageY - position.y;\n\n\t\tconst distance = Math.sqrt( dx * dx + dy * dy );\n\n\t\tthis._dollyEnd.set( 0, distance );\n\n\t\tthis._dollyDelta.set( 0, Math.pow( this._dollyEnd.y / this._dollyStart.y, this.zoomSpeed ) );\n\n\t\tthis._dollyOut( this._dollyDelta.y );\n\n\t\tthis._dollyStart.copy( this._dollyEnd );\n\n\t\tconst centerX = ( event.pageX + position.x ) * 0.5;\n\t\tconst centerY = ( event.pageY + position.y ) * 0.5;\n\n\t\tthis._updateZoomParameters( centerX, centerY );\n\n\t}\n\n\t_handleTouchMoveDollyPan( event ) {\n\n\t\tif ( this.enableZoom ) this._handleTouchMoveDolly( event );\n\n\t\tif ( this.enablePan ) this._handleTouchMovePan( event );\n\n\t}\n\n\t_handleTouchMoveDollyRotate( event ) {\n\n\t\tif ( this.enableZoom ) this._handleTouchMoveDolly( event );\n\n\t\tif ( this.enableRotate ) this._handleTouchMoveRotate( event );\n\n\t}\n\n\t// pointers\n\n\t_addPointer( event ) {\n\n\t\tthis._pointers.push( event.pointerId );\n\n\t}\n\n\t_removePointer( event ) {\n\n\t\tdelete this._pointerPositions[ event.pointerId ];\n\n\t\tfor ( let i = 0; i < this._pointers.length; i ++ ) {\n\n\t\t\tif ( this._pointers[ i ] == event.pointerId ) {\n\n\t\t\t\tthis._pointers.splice( i, 1 );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t_isTrackingPointer( event ) {\n\n\t\tfor ( let i = 0; i < this._pointers.length; i ++ ) {\n\n\t\t\tif ( this._pointers[ i ] == event.pointerId ) return true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\t_trackPointer( event ) {\n\n\t\tlet position = this._pointerPositions[ event.pointerId ];\n\n\t\tif ( position === undefined ) {\n\n\t\t\tposition = new Vector2();\n\t\t\tthis._pointerPositions[ event.pointerId ] = position;\n\n\t\t}\n\n\t\tposition.set( event.pageX, event.pageY );\n\n\t}\n\n\t_getSecondPointerPosition( event ) {\n\n\t\tconst pointerId = ( event.pointerId === this._pointers[ 0 ] ) ? this._pointers[ 1 ] : this._pointers[ 0 ];\n\n\t\treturn this._pointerPositions[ pointerId ];\n\n\t}\n\n\t//\n\n\t_customWheelEvent( event ) {\n\n\t\tconst mode = event.deltaMode;\n\n\t\t// minimal wheel event altered to meet delta-zoom demand\n\t\tconst newEvent = {\n\t\t\tclientX: event.clientX,\n\t\t\tclientY: event.clientY,\n\t\t\tdeltaY: event.deltaY,\n\t\t};\n\n\t\tswitch ( mode ) {\n\n\t\t\tcase 1: // LINE_MODE\n\t\t\t\tnewEvent.deltaY *= 16;\n\t\t\t\tbreak;\n\n\t\t\tcase 2: // PAGE_MODE\n\t\t\t\tnewEvent.deltaY *= 100;\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\t// detect if event was triggered by pinching\n\t\tif ( event.ctrlKey && ! this._controlActive ) {\n\n\t\t\tnewEvent.deltaY *= 10;\n\n\t\t}\n\n\t\treturn newEvent;\n\n\t}\n\n}\n\nfunction onPointerDown( event ) {\n\n\tif ( this.enabled === false ) return;\n\n\tif ( this._pointers.length === 0 ) {\n\n\t\tthis.domElement.setPointerCapture( event.pointerId );\n\n\t\tthis.domElement.ownerDocument.addEventListener( 'pointermove', this._onPointerMove );\n\t\tthis.domElement.ownerDocument.addEventListener( 'pointerup', this._onPointerUp );\n\n\t}\n\n\t//\n\n\tif ( this._isTrackingPointer( event ) ) return;\n\n\t//\n\n\tthis._addPointer( event );\n\n\tif ( event.pointerType === 'touch' ) {\n\n\t\tthis._onTouchStart( event );\n\n\t} else {\n\n\t\tthis._onMouseDown( event );\n\n\t}\n\n}\n\nfunction onPointerMove( event ) {\n\n\tif ( this.enabled === false ) return;\n\n\tif ( event.pointerType === 'touch' ) {\n\n\t\tthis._onTouchMove( event );\n\n\t} else {\n\n\t\tthis._onMouseMove( event );\n\n\t}\n\n}\n\nfunction onPointerUp( event ) {\n\n\tthis._removePointer( event );\n\n\tswitch ( this._pointers.length ) {\n\n\t\tcase 0:\n\n\t\t\tthis.domElement.releasePointerCapture( event.pointerId );\n\n\t\t\tthis.domElement.ownerDocument.removeEventListener( 'pointermove', this._onPointerMove );\n\t\t\tthis.domElement.ownerDocument.removeEventListener( 'pointerup', this._onPointerUp );\n\n\t\t\tthis.dispatchEvent( _endEvent );\n\n\t\t\tthis.state = _STATE.NONE;\n\n\t\t\tbreak;\n\n\t\tcase 1:\n\n\t\t\tconst pointerId = this._pointers[ 0 ];\n\t\t\tconst position = this._pointerPositions[ pointerId ];\n\n\t\t\t// minimal placeholder event - allows state correction on pointer-up\n\t\t\tthis._onTouchStart( { pointerId: pointerId, pageX: position.x, pageY: position.y } );\n\n\t\t\tbreak;\n\n\t}\n\n}\n\nfunction onMouseDown( event ) {\n\n\tlet mouseAction;\n\n\tswitch ( event.button ) {\n\n\t\tcase 0:\n\n\t\t\tmouseAction = this.mouseButtons.LEFT;\n\t\t\tbreak;\n\n\t\tcase 1:\n\n\t\t\tmouseAction = this.mouseButtons.MIDDLE;\n\t\t\tbreak;\n\n\t\tcase 2:\n\n\t\t\tmouseAction = this.mouseButtons.RIGHT;\n\t\t\tbreak;\n\n\t\tdefault:\n\n\t\t\tmouseAction = - 1;\n\n\t}\n\n\tswitch ( mouseAction ) {\n\n\t\tcase MOUSE.DOLLY:\n\n\t\t\tif ( this.enableZoom === false ) return;\n\n\t\t\tthis._handleMouseDownDolly( event );\n\n\t\t\tthis.state = _STATE.DOLLY;\n\n\t\t\tbreak;\n\n\t\tcase MOUSE.ROTATE:\n\n\t\t\tif ( event.ctrlKey || event.metaKey || event.shiftKey ) {\n\n\t\t\t\tif ( this.enablePan === false ) return;\n\n\t\t\t\tthis._handleMouseDownPan( event );\n\n\t\t\t\tthis.state = _STATE.PAN;\n\n\t\t\t} else {\n\n\t\t\t\tif ( this.enableRotate === false ) return;\n\n\t\t\t\tthis._handleMouseDownRotate( event );\n\n\t\t\t\tthis.state = _STATE.ROTATE;\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase MOUSE.PAN:\n\n\t\t\tif ( event.ctrlKey || event.metaKey || event.shiftKey ) {\n\n\t\t\t\tif ( this.enableRotate === false ) return;\n\n\t\t\t\tthis._handleMouseDownRotate( event );\n\n\t\t\t\tthis.state = _STATE.ROTATE;\n\n\t\t\t} else {\n\n\t\t\t\tif ( this.enablePan === false ) return;\n\n\t\t\t\tthis._handleMouseDownPan( event );\n\n\t\t\t\tthis.state = _STATE.PAN;\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tdefault:\n\n\t\t\tthis.state = _STATE.NONE;\n\n\t}\n\n\tif ( this.state !== _STATE.NONE ) {\n\n\t\tthis.dispatchEvent( _startEvent );\n\n\t}\n\n}\n\nfunction onMouseMove( event ) {\n\n\tswitch ( this.state ) {\n\n\t\tcase _STATE.ROTATE:\n\n\t\t\tif ( this.enableRotate === false ) return;\n\n\t\t\tthis._handleMouseMoveRotate( event );\n\n\t\t\tbreak;\n\n\t\tcase _STATE.DOLLY:\n\n\t\t\tif ( this.enableZoom === false ) return;\n\n\t\t\tthis._handleMouseMoveDolly( event );\n\n\t\t\tbreak;\n\n\t\tcase _STATE.PAN:\n\n\t\t\tif ( this.enablePan === false ) return;\n\n\t\t\tthis._handleMouseMovePan( event );\n\n\t\t\tbreak;\n\n\t}\n\n}\n\nfunction onMouseWheel( event ) {\n\n\tif ( this.enabled === false || this.enableZoom === false || this.state !== _STATE.NONE ) return;\n\n\tevent.preventDefault();\n\n\tthis.dispatchEvent( _startEvent );\n\n\tthis._handleMouseWheel( this._customWheelEvent( event ) );\n\n\tthis.dispatchEvent( _endEvent );\n\n}\n\nfunction onKeyDown( event ) {\n\n\tif ( this.enabled === false ) return;\n\n\tthis._handleKeyDown( event );\n\n}\n\nfunction onTouchStart( event ) {\n\n\tthis._trackPointer( event );\n\n\tswitch ( this._pointers.length ) {\n\n\t\tcase 1:\n\n\t\t\tswitch ( this.touches.ONE ) {\n\n\t\t\t\tcase TOUCH.ROTATE:\n\n\t\t\t\t\tif ( this.enableRotate === false ) return;\n\n\t\t\t\t\tthis._handleTouchStartRotate( event );\n\n\t\t\t\t\tthis.state = _STATE.TOUCH_ROTATE;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase TOUCH.PAN:\n\n\t\t\t\t\tif ( this.enablePan === false ) return;\n\n\t\t\t\t\tthis._handleTouchStartPan( event );\n\n\t\t\t\t\tthis.state = _STATE.TOUCH_PAN;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tthis.state = _STATE.NONE;\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase 2:\n\n\t\t\tswitch ( this.touches.TWO ) {\n\n\t\t\t\tcase TOUCH.DOLLY_PAN:\n\n\t\t\t\t\tif ( this.enableZoom === false && this.enablePan === false ) return;\n\n\t\t\t\t\tthis._handleTouchStartDollyPan( event );\n\n\t\t\t\t\tthis.state = _STATE.TOUCH_DOLLY_PAN;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase TOUCH.DOLLY_ROTATE:\n\n\t\t\t\t\tif ( this.enableZoom === false && this.enableRotate === false ) return;\n\n\t\t\t\t\tthis._handleTouchStartDollyRotate( event );\n\n\t\t\t\t\tthis.state = _STATE.TOUCH_DOLLY_ROTATE;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tthis.state = _STATE.NONE;\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tdefault:\n\n\t\t\tthis.state = _STATE.NONE;\n\n\t}\n\n\tif ( this.state !== _STATE.NONE ) {\n\n\t\tthis.dispatchEvent( _startEvent );\n\n\t}\n\n}\n\nfunction onTouchMove( event ) {\n\n\tthis._trackPointer( event );\n\n\tswitch ( this.state ) {\n\n\t\tcase _STATE.TOUCH_ROTATE:\n\n\t\t\tif ( this.enableRotate === false ) return;\n\n\t\t\tthis._handleTouchMoveRotate( event );\n\n\t\t\tthis.update();\n\n\t\t\tbreak;\n\n\t\tcase _STATE.TOUCH_PAN:\n\n\t\t\tif ( this.enablePan === false ) return;\n\n\t\t\tthis._handleTouchMovePan( event );\n\n\t\t\tthis.update();\n\n\t\t\tbreak;\n\n\t\tcase _STATE.TOUCH_DOLLY_PAN:\n\n\t\t\tif ( this.enableZoom === false && this.enablePan === false ) return;\n\n\t\t\tthis._handleTouchMoveDollyPan( event );\n\n\t\t\tthis.update();\n\n\t\t\tbreak;\n\n\t\tcase _STATE.TOUCH_DOLLY_ROTATE:\n\n\t\t\tif ( this.enableZoom === false && this.enableRotate === false ) return;\n\n\t\t\tthis._handleTouchMoveDollyRotate( event );\n\n\t\t\tthis.update();\n\n\t\t\tbreak;\n\n\t\tdefault:\n\n\t\t\tthis.state = _STATE.NONE;\n\n\t}\n\n}\n\nfunction onContextMenu( event ) {\n\n\tif ( this.enabled === false ) return;\n\n\tevent.preventDefault();\n\n}\n\nfunction interceptControlDown( event ) {\n\n\tif ( event.key === 'Control' ) {\n\n\t\tthis._controlActive = true;\n\n\t\tconst document = this.domElement.getRootNode(); // offscreen canvas compatibility\n\n\t\tdocument.addEventListener( 'keyup', this._interceptControlUp, { passive: true, capture: true } );\n\n\t}\n\n}\n\nfunction interceptControlUp( event ) {\n\n\tif ( event.key === 'Control' ) {\n\n\t\tthis._controlActive = false;\n\n\t\tconst document = this.domElement.getRootNode(); // offscreen canvas compatibility\n\n\t\tdocument.removeEventListener( 'keyup', this._interceptControlUp, { passive: true, capture: true } );\n\n\t}\n\n}\n\nexport { OrbitControls };\n","import * as THREE from 'three';\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';\n\n/**\n * Camera manager with orbit controls\n * Handles camera setup and user interaction for viewing the scene\n */\nexport class CameraManager {\n  constructor(renderer, options = {}) {\n    const cameraType = options.type || 'perspective'; // 'perspective' or 'orthographic'\n    this.aspect = options.aspect || 1.6; // Default to 1.6:1 for touch screen\n    \n    if (cameraType === 'orthographic') {\n      // Orthographic camera for isometric view (no distortion)\n      const frustumSize = options.frustumSize || 10;\n      this.camera = new THREE.OrthographicCamera(\n        frustumSize * this.aspect / -2,    // Left\n        frustumSize * this.aspect / 2,     // Right\n        frustumSize / 2,              // Top\n        frustumSize / -2,             // Bottom\n        0.1,                          // Near\n        1000                          // Far\n      );\n      this.isOrthographic = true;\n      this.frustumSize = frustumSize;\n    } else {\n      // Perspective camera (default)\n      this.camera = new THREE.PerspectiveCamera(\n        75,                           // Field of view\n        aspect,                       // Aspect ratio (30vh viewport)\n        0.1,                          // Near clipping plane\n        1000                          // Far clipping plane\n      );\n      this.isOrthographic = false;\n    }\n\n    // Position camera for good initial view\n    this.camera.position.set(5, 5, 5);\n    this.camera.lookAt(0, 0.8, 0); // Look at gizmo center (slightly elevated)\n\n    // Setup orbit controls for user interaction\n    this.controls = new OrbitControls(this.camera, renderer.domElement);\n    this.controls.enableDamping = true;     // Smooth camera movements\n    this.controls.dampingFactor = 0.05;\n    this.controls.minDistance = 2;          // Minimum zoom\n    this.controls.maxDistance = 50;         // Maximum zoom\n    \n    // Allow full vertical rotation (0 to 180 degrees)\n    this.controls.minPolarAngle = 0;        // Can look from straight above\n    this.controls.maxPolarAngle = Math.PI;  // Can look from straight below\n    \n    // Allow unlimited horizontal rotation\n    this.controls.minAzimuthAngle = -Infinity;\n    this.controls.maxAzimuthAngle = Infinity;\n    \n    this.controls.enablePan = false;        // Disable right-click pan\n  }\n\n  /**\n   * Update camera controls (call in render loop)\n   */\n  update() {\n    this.controls.update();\n  }\n\n  /**\n   * Handle window resize (for 30vh viewport with 1.6:1 aspect ratio)\n   */\n  handleResize() {\n    if (this.isOrthographic) {\n      // Update orthographic camera frustum\n      this.camera.left = this.frustumSize * this.aspect / -2;\n      this.camera.right = this.frustumSize * this.aspect / 2;\n      this.camera.top = this.frustumSize / 2;\n      this.camera.bottom = this.frustumSize / -2;\n    } else {\n      // Update perspective camera aspect\n      this.camera.aspect = this.aspect;\n    }\n    \n    this.camera.updateProjectionMatrix();\n  }\n\n  /**\n   * Get the Three.js camera instance\n   * @returns {THREE.PerspectiveCamera}\n   */\n  getCamera() {\n    return this.camera;\n  }\n\n  /**\n   * Get the orbit controls instance\n   * @returns {OrbitControls}\n   */\n  getControls() {\n    return this.controls;\n  }\n}\n\n","import * as THREE from 'three';\n\n/**\n * Dual viewport renderer manager\n * Handles rendering for both preview and work viewports\n */\nexport class RendererManager {\n  constructor() {\n    // Create preview renderer (top viewport)\n    this.previewRenderer = new THREE.WebGLRenderer({\n      antialias: true,\n      alpha: true\n    });\n    this.previewRenderer.setPixelRatio(window.devicePixelRatio);\n    this.previewRenderer.shadowMap.enabled = true;\n    this.previewRenderer.shadowMap.type = THREE.PCFSoftShadowMap;\n    \n    // Enable clipping planes for thin slab visualization\n    this.previewRenderer.localClippingEnabled = false; // Use global clipping\n    this.previewRenderer.clippingPlanes = [];\n\n    // Create work renderer (bottom viewport)\n    this.workRenderer = new THREE.WebGLRenderer({\n      antialias: true,\n      alpha: true\n    });\n    this.workRenderer.setPixelRatio(window.devicePixelRatio);\n    this.workRenderer.shadowMap.enabled = true;\n    this.workRenderer.shadowMap.type = THREE.PCFSoftShadowMap;\n\n    // Add canvases to their respective containers\n    const previewContainer = document.getElementById('preview-viewport');\n    const workContainer = document.getElementById('work-viewport');\n\n    if (previewContainer && workContainer) {\n      previewContainer.appendChild(this.previewRenderer.domElement);\n      workContainer.appendChild(this.workRenderer.domElement);\n    }\n\n    // Set initial sizes\n    this.handleResize();\n\n    // Handle window resize\n    window.addEventListener('resize', () => this.handleResize());\n  }\n\n  /**\n   * Handle window resize event\n   */\n  handleResize() {\n    const width = window.innerWidth;\n    const previewHeight = window.innerHeight * 0.7; // 70% for main screen\n    const workHeight = window.innerHeight * 0.3;    // 30% for touch screen\n    const previewWidth = previewHeight * 1.6;       // 1.6:1 aspect ratio for main screen\n    const workWidth = workHeight * 1.6;             // 1.6:1 aspect ratio for touch screen\n\n    this.previewRenderer.setSize(previewWidth, previewHeight);\n    this.workRenderer.setSize(workWidth, workHeight);\n  }\n\n  /**\n   * Render all viewports with thin slab clipping for MPR views\n   * @param {THREE.Scene} previewScene - Scene for preview viewport\n   * @param {THREE.Camera} previewCamera - Camera for 3D perspective view (left)\n   * @param {THREE.Camera} transverseCamera - Camera for transverse plane (top right)\n   * @param {THREE.Camera} coronalCamera - Camera for coronal plane (middle right)\n   * @param {THREE.Camera} sagittalCamera - Camera for sagittal plane (bottom right)\n   * @param {Array} transverseClipPlanes - Dual clipping planes for transverse slab\n   * @param {Array} coronalClipPlanes - Dual clipping planes for coronal slab\n   * @param {Array} sagittalClipPlanes - Dual clipping planes for sagittal slab\n   * @param {THREE.Scene} workScene - Scene for work viewport\n   * @param {THREE.Camera} workCamera - Camera for work viewport\n   * @param {THREE.Scene} summaryScene - Summary gizmo scene for transverse\n   * @param {THREE.Camera} summaryCamera - Summary gizmo camera for transverse\n   * @param {THREE.Scene} coronalSummaryScene - Summary gizmo scene for coronal\n   * @param {THREE.Camera} coronalSummaryCamera - Summary gizmo camera for coronal\n   * @param {THREE.Scene} sagittalSummaryScene - Summary gizmo scene for sagittal\n   * @param {THREE.Camera} sagittalSummaryCamera - Summary gizmo camera for sagittal\n   */\n  render(previewScene, previewCamera, transverseCamera, coronalCamera, sagittalCamera,\n         transverseClipPlanes, coronalClipPlanes, sagittalClipPlanes, workScene, workCamera,\n         summaryScene, summaryCamera, coronalSummaryScene, coronalSummaryCamera,\n         sagittalSummaryScene, sagittalSummaryCamera) {\n    const previewHeight = window.innerHeight * 0.7;\n    const width = previewHeight * 1.6; // 1.6:1 aspect ratio\n    const halfWidth = Math.floor(width / 2);\n    const thirdHeight = Math.floor(previewHeight / 3);\n    \n    // Enable scissor test for split viewports\n    this.previewRenderer.setScissorTest(true);\n    \n    // === LEFT HALF: 3D Perspective View (No clipping) ===\n    this.previewRenderer.clippingPlanes = [];\n    this.previewRenderer.setViewport(0, 0, halfWidth, previewHeight);\n    this.previewRenderer.setScissor(0, 0, halfWidth, previewHeight);\n    this.previewRenderer.render(previewScene, previewCamera);\n    \n    // === RIGHT TOP THIRD: Transverse Slab (Full width) ===\n    this.previewRenderer.clippingPlanes = transverseClipPlanes || [];\n    this.previewRenderer.setViewport(halfWidth, thirdHeight * 2, halfWidth, thirdHeight);\n    this.previewRenderer.setScissor(halfWidth, thirdHeight * 2, halfWidth, thirdHeight);\n    this.previewRenderer.render(previewScene, transverseCamera);\n    \n    // Overlay: Summary Gizmo (top-left corner of transverse, square viewport)\n    if (summaryScene && summaryCamera) {\n      const overlaySize = Math.min(thirdHeight, halfWidth) * 0.55; // 55% of smaller dimension (larger)\n      const overlayX = halfWidth + 15; // 15px from left edge\n      const overlayY = thirdHeight * 2 + thirdHeight - overlaySize - 15; // 15px from top\n      \n      this.previewRenderer.clippingPlanes = [];\n      this.previewRenderer.setViewport(overlayX, overlayY, overlaySize, overlaySize);\n      this.previewRenderer.setScissor(overlayX, overlayY, overlaySize, overlaySize);\n      this.previewRenderer.render(summaryScene, summaryCamera);\n      \n      // Update CSS border position\n      this.updateSummaryBorder(overlayX, overlayY, overlaySize, 'summary-gizmo-border');\n    }\n    \n    // === RIGHT MIDDLE THIRD: Coronal Slab (Thin front-to-back slice) ===\n    this.previewRenderer.clippingPlanes = coronalClipPlanes || [];\n    this.previewRenderer.setViewport(halfWidth, thirdHeight, halfWidth, thirdHeight);\n    this.previewRenderer.setScissor(halfWidth, thirdHeight, halfWidth, thirdHeight);\n    this.previewRenderer.render(previewScene, coronalCamera);\n    \n    // Overlay: Coronal Summary Gizmo (top-left corner of coronal, square viewport)\n    if (coronalSummaryScene && coronalSummaryCamera) {\n      const overlaySize = Math.min(thirdHeight, halfWidth) * 0.55;\n      const overlayX = halfWidth + 15;\n      const overlayY = thirdHeight + thirdHeight - overlaySize - 15;\n      \n      this.previewRenderer.clippingPlanes = [];\n      this.previewRenderer.setViewport(overlayX, overlayY, overlaySize, overlaySize);\n      this.previewRenderer.setScissor(overlayX, overlayY, overlaySize, overlaySize);\n      this.previewRenderer.render(coronalSummaryScene, coronalSummaryCamera);\n      \n      // Update CSS border position\n      this.updateSummaryBorder(overlayX, overlayY, overlaySize, 'coronal-summary-gizmo-border');\n    }\n    \n    // === RIGHT BOTTOM THIRD: Sagittal Slab (Thin left-to-right slice) ===\n    this.previewRenderer.clippingPlanes = sagittalClipPlanes || [];\n    this.previewRenderer.setViewport(halfWidth, 0, halfWidth, thirdHeight);\n    this.previewRenderer.setScissor(halfWidth, 0, halfWidth, thirdHeight);\n    this.previewRenderer.render(previewScene, sagittalCamera);\n    \n    // Overlay: Sagittal Summary Gizmo (top-left corner of sagittal, square viewport)\n    if (sagittalSummaryScene && sagittalSummaryCamera) {\n      const overlaySize = Math.min(thirdHeight, halfWidth) * 0.55;\n      const overlayX = halfWidth + 15;\n      const overlayY = thirdHeight - overlaySize - 15;\n      \n      this.previewRenderer.clippingPlanes = [];\n      this.previewRenderer.setViewport(overlayX, overlayY, overlaySize, overlaySize);\n      this.previewRenderer.setScissor(overlayX, overlayY, overlaySize, overlaySize);\n      this.previewRenderer.render(sagittalSummaryScene, sagittalSummaryCamera);\n      \n      // Update CSS border position\n      this.updateSummaryBorder(overlayX, overlayY, overlaySize, 'sagittal-summary-gizmo-border');\n    }\n    \n    // Clear clipping planes and disable scissor test for work viewport\n    this.previewRenderer.clippingPlanes = [];\n    this.previewRenderer.setScissorTest(false);\n    this.workRenderer.render(workScene, workCamera);\n  }\n\n  /**\n   * Get the work viewport's DOM element (for input handling)\n   * @returns {HTMLCanvasElement}\n   */\n  get domElement() {\n    return this.workRenderer.domElement;\n  }\n\n  /**\n   * Get work renderer instance\n   * @returns {THREE.WebGLRenderer}\n   */\n  getRenderer() {\n    return this.workRenderer;\n  }\n  \n  /**\n   * Update summary gizmo border position\n   * @param {number} x - X position in pixels\n   * @param {number} y - Y position in pixels\n   * @param {number} size - Size in pixels\n   * @param {string} elementId - ID of the border element\n   */\n  updateSummaryBorder(x, y, size, elementId) {\n    const border = document.getElementById(elementId);\n    if (border) {\n      const previewHeight = window.innerHeight * 0.7;\n      const canvasWidth = previewHeight * 1.6; // 1.6:1 aspect ratio\n      const windowWidth = window.innerWidth;\n      const canvasOffsetX = (windowWidth - canvasWidth) / 2; // Canvas is centered\n      \n      // Convert from WebGL coordinates (bottom-left origin) to CSS coordinates (top-left origin)\n      const cssY = previewHeight - y - size;\n      const cssX = canvasOffsetX + x;\n      \n      border.style.left = `${cssX}px`;\n      border.style.top = `${cssY}px`;\n      border.style.width = `${size}px`;\n      border.style.height = `${size}px`;\n    }\n  }\n\n  /**\n   * Get preview renderer instance\n   * @returns {THREE.WebGLRenderer}\n   */\n  getPreviewRenderer() {\n    return this.previewRenderer;\n  }\n\n  /**\n   * Clean up renderer resources\n   */\n  dispose() {\n    this.previewRenderer.dispose();\n    this.workRenderer.dispose();\n  }\n}\n","import * as THREE from 'three';\n\n/**\n * Rotation Gizmo - Axis-based rotation control\n * Provides visual rotation rings for X, Y, and Z axes\n */\nexport class RotationGizmo {\n  constructor(targetObject, options = {}) {\n    this.target = targetObject;\n    this.mesh = new THREE.Group();\n    \n    // Configuration\n    this.config = {\n      radius: options.radius || 2.5,           // Ring radius\n      tubeRadius: options.tubeRadius || 0.04,  // Ring thickness (balanced for visibility and aesthetics)\n      segments: options.segments || 64,        // Smoothness\n      opacity: options.opacity || 0.6,         // Base opacity\n      hoverOpacity: options.hoverOpacity || 1.0 // Hover opacity\n    };\n\n    // Rotation mode: 'world' or 'local'\n    this.rotationMode = options.rotationMode || 'world';\n\n    // Store axis colors for hover highlighting\n    this.axisColors = {\n      x: 0xff3333,  // Red\n      y: 0x44ff44,  // Green\n      z: 0x4444ff   // Blue\n    };\n    \n    this.defaultColor = 0x888888;  // Stronger gray for inactive state\n\n    // Axis ring meshes (default gray, colored on hover)\n    this.axes = {\n      x: this.createAxisRing('x', this.defaultColor),\n      y: this.createAxisRing('y', this.defaultColor),\n      z: this.createAxisRing('z', this.defaultColor)\n    };\n\n    // Add all rings to the gizmo group\n    this.mesh.add(this.axes.x.mesh);\n    this.mesh.add(this.axes.y.mesh);\n    this.mesh.add(this.axes.z.mesh);\n\n    // Create text labels for each axis\n    // Position beyond the sphere/cube so they're clickable\n    const labelDistance = this.config.radius + 0.5; // Beyond sphere radius (2.5 + 0.5 = 3.0)\n    this.labels = {\n      x: this.createAxisLabel('X', 0xff0000, new THREE.Vector3(labelDistance, 0, 0)),\n      y: this.createAxisLabel('Y', 0x00ff00, new THREE.Vector3(0, labelDistance, 0)),\n      z: this.createAxisLabel('Z', 0x0000ff, new THREE.Vector3(0, 0, labelDistance))\n    };\n\n    // Add labels to the gizmo group\n    this.mesh.add(this.labels.x);\n    this.mesh.add(this.labels.y);\n    this.mesh.add(this.labels.z);\n\n    // Create circular highlight planes for each axis\n    this.highlightPlanes = {\n      x: this.createHighlightPlane('x', 0xff0000, 'circle'),\n      y: this.createHighlightPlane('y', 0x00ff00, 'circle'),\n      z: this.createHighlightPlane('z', 0x0000ff, 'circle')\n    };\n\n    // Create square highlight planes for cube style\n    this.squareHighlightPlanes = {\n      x: this.createHighlightPlane('x', 0xff0000, 'square'),\n      y: this.createHighlightPlane('y', 0x00ff00, 'square'),\n      z: this.createHighlightPlane('z', 0x0000ff, 'square')\n    };\n\n    // Add highlight planes (initially hidden)\n    this.mesh.add(this.highlightPlanes.x);\n    this.mesh.add(this.highlightPlanes.y);\n    this.mesh.add(this.highlightPlanes.z);\n    this.mesh.add(this.squareHighlightPlanes.x);\n    this.mesh.add(this.squareHighlightPlanes.y);\n    this.mesh.add(this.squareHighlightPlanes.z);\n    \n    this.highlightPlanes.x.visible = false;\n    this.highlightPlanes.y.visible = false;\n    this.highlightPlanes.z.visible = false;\n    this.squareHighlightPlanes.x.visible = false;\n    this.squareHighlightPlanes.y.visible = false;\n    this.squareHighlightPlanes.z.visible = false;\n\n    // State tracking\n    this.activeAxis = null;\n    this.hoveredAxis = null;\n    this.isRotating = false;\n    this.currentStyle = 'cube';  // Track current style (default is cube)\n\n    console.log(' Rotation Gizmo created with 3 axis rings and labels');\n  }\n\n  /**\n   * Create an axis ring with proper geometry and material\n   * @param {string} axisName - Axis name ('x', 'y', 'z')\n   * @param {number} color - Hex color for the axis\n   * @returns {Object} - Axis data object\n   */\n  createAxisRing(axisName, color) {\n    // Create a circle curve for the ring path\n    const curve = new THREE.EllipseCurve(\n      0, 0,                    // Center\n      this.config.radius,      // X radius\n      this.config.radius,      // Y radius\n      0, 2 * Math.PI,          // Start angle, end angle\n      false,                   // Clockwise\n      0                        // Rotation\n    );\n    \n    // Get points along the curve\n    const points = curve.getPoints(this.config.segments);\n    const geometry = new THREE.BufferGeometry().setFromPoints(points);\n    \n    // Create dashed line material for dotted appearance\n    const material = new THREE.LineDashedMaterial({\n      color: color,\n      transparent: true,\n      opacity: this.config.opacity,\n      dashSize: 0.3,           // Longer dashes for better visibility\n      gapSize: 0.2,            // Shorter gaps\n      linewidth: 3,            // Thicker line\n      depthTest: true,\n      depthWrite: true\n    });\n\n    // Create line and compute line distances for dashing\n    const mesh = new THREE.Line(geometry, material);\n    mesh.computeLineDistances();\n    \n    // Rotate ring to align with the correct axis\n    if (axisName === 'x') {\n      // X-axis: rotate to face along X\n      mesh.rotation.y = Math.PI / 2;\n    } else if (axisName === 'y') {\n      // Y-axis: already upright, rotate to face along Y\n      mesh.rotation.x = Math.PI / 2;\n    } else if (axisName === 'z') {\n      // Z-axis: already faces along Z (no rotation needed)\n    }\n\n    // Store axis direction vector\n    const axisVector = new THREE.Vector3();\n    if (axisName === 'x') axisVector.set(1, 0, 0);\n    if (axisName === 'y') axisVector.set(0, 1, 0);\n    if (axisName === 'z') axisVector.set(0, 0, 1);\n\n    // Store reference for raycasting (Phase 3)\n    mesh.userData = {\n      type: 'gizmo-axis',\n      axis: axisName,\n      axisVector: axisVector\n    };\n\n    return {\n      name: axisName,\n      mesh: mesh,\n      material: material,\n      color: color,\n      axisVector: axisVector\n    };\n  }\n\n  /**\n   * Create a text label sprite for an axis with colored circle background\n   * @param {string} text - Text to display (e.g., 'X', 'Y', 'Z')\n   * @param {number} color - Hex color for the circle background\n   * @param {THREE.Vector3} position - Position relative to gizmo center\n   * @returns {THREE.Sprite} - Text sprite\n   */\n  createAxisLabel(text, color, position) {\n    // Create canvas for text rendering (larger for better touch targets)\n    const canvas = document.createElement('canvas');\n    const size = 320;  // Even larger canvas for bigger buttons\n    canvas.width = size;\n    canvas.height = size;\n    \n    const context = canvas.getContext('2d');\n    \n    // Clear canvas\n    context.clearRect(0, 0, size, size);\n    \n    // Draw colored circle background\n    const centerX = size / 2;\n    const centerY = size / 2;\n    const radius = 130;  // Bigger radius for better touch interaction\n    \n    // Use darker colors for better contrast with white text\n    let darkColor;\n    if (color === 0xff0000) {\n      darkColor = '#CC0000';  // Darker red\n    } else if (color === 0x00ff00) {\n      darkColor = '#009900';  // Darker green (much better contrast)\n    } else if (color === 0x0000ff) {\n      darkColor = '#0000CC';  // Darker blue\n    } else {\n      darkColor = '#' + color.toString(16).padStart(6, '0');\n    }\n    \n    // Create circle with darker color for contrast\n    context.beginPath();\n    context.arc(centerX, centerY, radius, 0, Math.PI * 2);\n    context.fillStyle = darkColor;\n    context.fill();\n    \n    // Add subtle border to circle\n    context.strokeStyle = 'rgba(255, 255, 255, 0.4)';\n    context.lineWidth = 3;\n    context.stroke();\n    \n    // Draw large white text on top of circle\n    context.font = 'Bold 180px Arial';  // Even larger font for bigger buttons\n    context.fillStyle = '#FFFFFF';  // White text\n    context.textAlign = 'center';\n    context.textBaseline = 'middle';\n    \n    // Add shadow for depth\n    context.shadowColor = 'rgba(0, 0, 0, 0.6)';\n    context.shadowBlur = 5;\n    context.shadowOffsetX = 2;\n    context.shadowOffsetY = 2;\n    \n    // Draw text\n    context.fillText(text, centerX, centerY);\n    \n    // Create texture from canvas\n    const texture = new THREE.CanvasTexture(canvas);\n    texture.needsUpdate = true;\n    \n    // Create sprite material\n    const spriteMaterial = new THREE.SpriteMaterial({\n      map: texture,\n      transparent: true,\n      depthTest: false,  // Always visible on top\n      depthWrite: false\n    });\n    \n    // Create sprite\n    const sprite = new THREE.Sprite(spriteMaterial);\n    sprite.position.copy(position);\n    sprite.scale.set(1.4, 1.4, 1.4);  // Much larger scale for better touch interaction\n    \n    // Mark as label (now pickable for interaction!)\n    sprite.userData = {\n      type: 'gizmo-label',\n      axis: text.toLowerCase(),\n      axisVector: this.axes[text.toLowerCase()].axisVector  // Same as ring\n    };\n    \n    return sprite;\n  }\n\n  /**\n   * Create a transparent highlight plane for an axis\n   * @param {string} axisName - Axis name ('x', 'y', 'z')\n   * @param {number} color - Hex color for the plane\n   * @param {string} shape - 'circle' or 'square'\n   * @returns {THREE.Mesh} - Highlight plane\n   */\n  createHighlightPlane(axisName, color, shape = 'circle') {\n    // Create geometry based on shape\n    let geometry;\n    if (shape === 'square') {\n      const size = this.config.radius * 1.2;  // Slightly larger than label\n      geometry = new THREE.PlaneGeometry(size, size);\n    } else {\n      geometry = new THREE.CircleGeometry(this.config.radius, 64);\n    }\n    \n    const material = new THREE.MeshBasicMaterial({\n      color: color,\n      transparent: true,\n      opacity: 0.2,\n      side: THREE.DoubleSide,\n      depthWrite: false\n    });\n\n    const plane = new THREE.Mesh(geometry, material);\n    \n    // Rotate plane to align with axis\n    if (axisName === 'x') {\n      plane.rotation.y = Math.PI / 2;  // YZ plane\n    } else if (axisName === 'y') {\n      plane.rotation.x = Math.PI / 2;  // XZ plane\n    }\n    // Z-axis plane is already XY (no rotation needed)\n\n    return plane;\n  }\n\n  /**\n   * Update gizmo position and orientation\n   */\n  update() {\n    if (this.target) {\n      // Position gizmo at target object's position\n      this.mesh.position.copy(this.target.position);\n      \n      // In local mode, gizmo rotates with the object\n      if (this.rotationMode === 'local') {\n        this.mesh.quaternion.copy(this.target.quaternion);\n      } else {\n        // In world mode, gizmo stays aligned with world axes\n        this.mesh.quaternion.identity();\n      }\n    }\n  }\n\n  /**\n   * Set rotation mode (world or local)\n   * @param {string} mode - 'world' or 'local'\n   */\n  setRotationMode(mode) {\n    if (mode === 'world' || mode === 'local') {\n      this.rotationMode = mode;\n      console.log(` Rotation mode: ${mode.toUpperCase()}`);\n    }\n  }\n\n  /**\n   * Get current axis vector in world space\n   * @param {string} axisName - Axis name ('x', 'y', 'z')\n   * @returns {THREE.Vector3} - Axis vector in world space\n   */\n  getWorldAxisVector(axisName) {\n    const axis = this.axes[axisName];\n    if (!axis) return null;\n\n    if (this.rotationMode === 'local') {\n      // Transform local axis to world space\n      const worldAxis = axis.axisVector.clone();\n      worldAxis.applyQuaternion(this.target.quaternion);\n      return worldAxis.normalize();\n    } else {\n      // Already in world space\n      return axis.axisVector.clone();\n    }\n  }\n\n  /**\n   * Set hover state for an axis\n   * @param {string|null} axisName - Axis name or null\n   */\n  setHoverAxis(axisName) {\n    // Don't change hover state if we're actively rotating\n    if (this.isRotating) return;\n\n    this.hoveredAxis = axisName;\n\n    if (axisName) {\n      // Highlight hovered axis, dim others\n      Object.keys(this.axes).forEach(key => {\n      if (key === axisName) {\n        // Brighten and color hovered axis (rings or square frames)\n        this.axes[key].material.opacity = this.config.hoverOpacity;\n        this.axes[key].material.color.setHex(this.axisColors[key]);\n        if (this.squareFrames && this.squareFrames[key]) {\n          // Square frames are groups with multiple meshes\n          this.squareFrames[key].children.forEach(mesh => {\n            mesh.material.opacity = this.config.hoverOpacity;\n            mesh.material.color.setHex(this.axisColors[key]);\n          });\n        }\n          // Show appropriate highlight plane based on current style\n          if (this.currentStyle === 'cube') {\n            this.squareHighlightPlanes[key].visible = true;\n            this.highlightPlanes[key].visible = false;\n          } else {\n            this.highlightPlanes[key].visible = true;\n            this.squareHighlightPlanes[key].visible = false;\n          }\n          // Keep label normal\n          this.labels[key].material.opacity = 1.0;\n      } else {\n        // Dim other axes and keep them gray\n        this.axes[key].material.opacity = this.config.opacity * 0.3;\n        this.axes[key].material.color.setHex(this.defaultColor);\n        if (this.squareFrames && this.squareFrames[key]) {\n          // Square frames are groups with multiple meshes\n          this.squareFrames[key].children.forEach(mesh => {\n            mesh.material.opacity = this.config.opacity * 0.3;\n            mesh.material.color.setHex(this.defaultColor);\n          });\n        }\n          // Hide other planes\n          this.highlightPlanes[key].visible = false;\n          this.squareHighlightPlanes[key].visible = false;\n          // Dim other labels\n          this.labels[key].material.opacity = 0.3;\n        }\n      });\n      console.log(` Highlighting ${axisName.toUpperCase()}-axis (hover)`);\n    } else {\n      // Reset all to default (gray, normal opacity)\n      Object.keys(this.axes).forEach(key => {\n        this.axes[key].material.opacity = this.config.opacity;\n        this.axes[key].material.color.setHex(this.defaultColor);\n        if (this.squareFrames && this.squareFrames[key]) {\n          // Square frames are groups with multiple meshes\n          this.squareFrames[key].children.forEach(mesh => {\n            mesh.material.opacity = this.config.opacity;\n            mesh.material.color.setHex(this.defaultColor);\n          });\n        }\n        this.highlightPlanes[key].visible = false;\n        this.squareHighlightPlanes[key].visible = false;\n        this.labels[key].material.opacity = 1.0;\n      });\n    }\n  }\n\n  /**\n   * Set active axis for rotation\n   * @param {string|null} axisName - Axis name or null\n   */\n  setActiveAxis(axisName) {\n    this.isRotating = true;\n    this.activeAxis = axisName;\n\n    // Dim all axes and labels\n    Object.keys(this.axes).forEach(key => {\n      if (key === axisName) {\n        // Brighten and color active axis (rings or square frames)\n        this.axes[key].material.opacity = this.config.hoverOpacity;\n        this.axes[key].material.color.setHex(this.axisColors[key]);\n        if (this.squareFrames && this.squareFrames[key]) {\n          // Square frames are groups with multiple meshes\n          this.squareFrames[key].children.forEach(mesh => {\n            mesh.material.opacity = this.config.hoverOpacity;\n            mesh.material.color.setHex(this.axisColors[key]);\n          });\n        }\n        // Show appropriate highlight plane\n        if (this.currentStyle === 'cube') {\n          this.squareHighlightPlanes[key].visible = true;\n          this.highlightPlanes[key].visible = false;\n        } else {\n          this.highlightPlanes[key].visible = true;\n          this.squareHighlightPlanes[key].visible = false;\n        }\n        // Keep label bright\n        this.labels[key].material.opacity = 1.0;\n      } else {\n        // Dim other axes and keep them gray\n        this.axes[key].material.opacity = this.config.opacity * 0.2;\n        this.axes[key].material.color.setHex(this.defaultColor);\n        if (this.squareFrames && this.squareFrames[key]) {\n          // Square frames are groups with multiple meshes\n          this.squareFrames[key].children.forEach(mesh => {\n            mesh.material.opacity = this.config.opacity * 0.2;\n            mesh.material.color.setHex(this.defaultColor);\n          });\n        }\n        // Hide other planes\n        this.highlightPlanes[key].visible = false;\n        this.squareHighlightPlanes[key].visible = false;\n        // Dim other labels\n        this.labels[key].material.opacity = 0.2;\n      }\n    });\n\n    if (axisName) {\n      console.log(` Locked ${axisName.toUpperCase()}-axis (active)`);\n    }\n  }\n\n  /**\n   * Clear active axis (end rotation)\n   */\n  clearActiveAxis() {\n    // Restore all axes, planes, and labels to default (gray)\n    Object.keys(this.axes).forEach(key => {\n      this.axes[key].material.opacity = this.config.opacity;\n      this.axes[key].material.color.setHex(this.defaultColor);\n      if (this.squareFrames && this.squareFrames[key]) {\n        // Square frames are groups with multiple meshes\n        this.squareFrames[key].children.forEach(mesh => {\n          mesh.material.opacity = this.config.opacity;\n          mesh.material.color.setHex(this.defaultColor);\n        });\n      }\n      this.highlightPlanes[key].visible = false;\n      this.squareHighlightPlanes[key].visible = false;\n      this.labels[key].material.opacity = 1.0;\n    });\n    \n    this.activeAxis = null;\n    this.isRotating = false;\n  }\n\n  /**\n   * Get all gizmo meshes for raycasting (including labels)\n   * @returns {Array<THREE.Object3D>}\n   */\n  getPickingMeshes() {\n    const meshes = [\n      this.labels.x,  // Labels are always interactive\n      this.labels.y,\n      this.labels.z\n    ];\n    \n    // Add appropriate axis meshes based on current style\n    if (this.currentStyle === 'cube') {\n      // In cube mode, use square frames and cube planes for picking\n      if (this.squareFrames) {\n        meshes.push(this.squareFrames.x, this.squareFrames.y, this.squareFrames.z);\n      }\n      if (this.cubePlanes) {\n        meshes.push(this.cubePlanes.x, this.cubePlanes.y, this.cubePlanes.z);\n      }\n    } else if (this.currentStyle === 'linear') {\n      // In linear mode, use linear lines\n      if (this.linearLines) {\n        meshes.push(this.linearLines.x, this.linearLines.y, this.linearLines.z);\n      }\n    } else {\n      // In circular mode, use circular rings\n      meshes.push(this.axes.x.mesh, this.axes.y.mesh, this.axes.z.mesh);\n    }\n    \n    return meshes;\n  }\n\n  /**\n   * Get the gizmo's Three.js group\n   * @returns {THREE.Group}\n   */\n  getMesh() {\n    return this.mesh;\n  }\n\n  /**\n   * Apply a visual style to the gizmo\n   * @param {string} styleName - 'circular', 'linear', or 'cube'\n   */\n  applyStyle(styleName) {\n    console.log(` Applying style: ${styleName}`);\n    \n    this.currentStyle = styleName;  // Track current style\n    \n    if (styleName === 'circular') {\n      this.applyCircularStyle();\n    } else if (styleName === 'linear') {\n      this.applyLinearStyle();\n    } else if (styleName === 'cube') {\n      this.applyCubeStyle();\n    } else {\n      console.warn(`Unknown style: ${styleName}, defaulting to circular`);\n      this.applyCircularStyle();\n    }\n  }\n\n  /**\n   * Circular style - shows ring gizmos\n   */\n  applyCircularStyle() {\n    // Show circular rings for all axes (Y ring will be movable for XZ plane)\n    this.axes.x.mesh.visible = true;\n    this.axes.y.mesh.visible = true; // Show Y circular ring (movable XZ plane)\n    this.axes.z.mesh.visible = true;\n    \n    // Hide linear lines if they exist\n    if (this.linearLines) {\n      this.linearLines.x.visible = false;\n      this.linearLines.y.visible = false;\n      this.linearLines.z.visible = false;\n    }\n    \n    // Hide cube planes if they exist\n    if (this.cubePlanes) {\n      this.cubePlanes.x.visible = false;\n      this.cubePlanes.y.visible = false;\n      this.cubePlanes.z.visible = false;\n    }\n    \n    // Keep square frames for interaction but hide them visually\n    // (Y frame still provides interaction for dragging)\n    if (this.squareFrames) {\n      this.squareFrames.x.visible = false;\n      this.squareFrames.y.visible = false; // Hidden but still used for interaction\n      this.squareFrames.z.visible = false;\n    }\n    \n    // Hide cube axis lines if they exist\n    if (this.cubeAxisLines) {\n      this.cubeAxisLines.x.visible = false;\n      this.cubeAxisLines.y.visible = false;\n      this.cubeAxisLines.z.visible = false;\n    }\n    \n    // Labels stay visible (they're common to both styles)\n    this.labels.x.visible = true;\n    this.labels.y.visible = true;\n    this.labels.z.visible = true;\n    \n    console.log(' Circular style applied');\n  }\n\n  /**\n   * Linear style - shows straight axis lines instead of rings\n   */\n  applyLinearStyle() {\n    // Hide circular rings\n    this.axes.x.mesh.visible = false;\n    this.axes.y.mesh.visible = false;\n    this.axes.z.mesh.visible = false;\n    \n    // Hide cube planes if they exist\n    if (this.cubePlanes) {\n      this.cubePlanes.x.visible = false;\n      this.cubePlanes.y.visible = false;\n      this.cubePlanes.z.visible = false;\n    }\n    \n    // Create linear lines if they don't exist yet\n    if (!this.linearLines) {\n      this.createLinearLines();\n    }\n    \n    // Show linear lines\n    this.linearLines.x.visible = true;\n    this.linearLines.y.visible = true;\n    this.linearLines.z.visible = true;\n    \n    // Labels stay visible\n    this.labels.x.visible = true;\n    this.labels.y.visible = true;\n    this.labels.z.visible = true;\n    \n    console.log(' Linear style applied');\n  }\n\n  /**\n   * Create straight axis lines for linear style\n   */\n  createLinearLines() {\n    this.linearLines = {};\n    \n    // Extend lines to reach the buttons (radius + 0.5 = 3.0)\n    const lineLength = this.config.radius + 0.5;\n    const lineWidth = 0.04;\n    \n    // X-axis line (red)\n    const xGeometry = new THREE.CylinderGeometry(lineWidth, lineWidth, lineLength, 16);\n    const xMaterial = new THREE.MeshBasicMaterial({ \n      color: 0xff0000,\n      transparent: true,\n      opacity: 0.8\n    });\n    const xLine = new THREE.Mesh(xGeometry, xMaterial);\n    xLine.rotation.z = -Math.PI / 2;\n    xLine.position.x = lineLength / 2;\n    this.linearLines.x = xLine;\n    this.mesh.add(xLine);\n    \n    // Y-axis line (green)\n    const yGeometry = new THREE.CylinderGeometry(lineWidth, lineWidth, lineLength, 16);\n    const yMaterial = new THREE.MeshBasicMaterial({ \n      color: 0x00ff00,\n      transparent: true,\n      opacity: 0.8\n    });\n    const yLine = new THREE.Mesh(yGeometry, yMaterial);\n    yLine.position.y = lineLength / 2;\n    this.linearLines.y = yLine;\n    this.mesh.add(yLine);\n    \n    // Z-axis line (blue)\n    const zGeometry = new THREE.CylinderGeometry(lineWidth, lineWidth, lineLength, 16);\n    const zMaterial = new THREE.MeshBasicMaterial({ \n      color: 0x0000ff,\n      transparent: true,\n      opacity: 0.8\n    });\n    const zLine = new THREE.Mesh(zGeometry, zMaterial);\n    zLine.rotation.x = Math.PI / 2;\n    zLine.position.z = lineLength / 2;\n    this.linearLines.z = zLine;\n    this.mesh.add(zLine);\n    \n    // Initially hide them (circular is default)\n    this.linearLines.x.visible = false;\n    this.linearLines.y.visible = false;\n    this.linearLines.z.visible = false;\n    \n    console.log(' Linear axis lines created');\n  }\n\n  /**\n   * Cube style - shows square frames and long axis lines\n   */\n  applyCubeStyle() {\n    // Hide circular rings\n    this.axes.x.mesh.visible = false;\n    this.axes.y.mesh.visible = false;\n    this.axes.z.mesh.visible = false;\n    \n    // Create and show long linear lines (extending to labels)\n    if (!this.linearLines) {\n      this.createLinearLines();\n    }\n    this.linearLines.x.visible = true;\n    this.linearLines.y.visible = true;\n    this.linearLines.z.visible = true;\n    \n    // Hide short cube axis lines (we're using long lines now)\n    if (this.cubeAxisLines) {\n      this.cubeAxisLines.x.visible = false;\n      this.cubeAxisLines.y.visible = false;\n      this.cubeAxisLines.z.visible = false;\n    }\n    \n    // Create and show square frames for cube style (now smaller)\n    if (!this.squareFrames) {\n      this.createSquareAxisFrames();\n    }\n    this.squareFrames.x.visible = true;\n    this.squareFrames.y.visible = true;\n    this.squareFrames.z.visible = true;\n    \n    // Create cube planes if they don't exist yet\n    if (!this.cubePlanes) {\n      this.createCubePlanes();\n    }\n    \n    // Keep cube planes for raycasting but make them invisible\n    this.cubePlanes.x.visible = true;\n    this.cubePlanes.y.visible = true;\n    this.cubePlanes.z.visible = true;\n    this.cubePlanes.x.material.opacity = 0;  // Invisible\n    this.cubePlanes.y.material.opacity = 0;  // Invisible\n    this.cubePlanes.z.material.opacity = 0;  // Invisible\n    \n    // Labels stay visible\n    this.labels.x.visible = true;\n    this.labels.y.visible = true;\n    this.labels.z.visible = true;\n    \n    console.log(' Cube style applied');\n  }\n\n  /**\n   * Create short axis lines for cube style (only to edge of cube)\n   */\n  createCubeAxisLines() {\n    this.cubeAxisLines = {};\n    \n    const lineLength = 1.95;  // Half the cube size (3.9 / 2)\n    const lineWidth = 0.03;\n    \n    // X-axis line (red)\n    const xGeometry = new THREE.CylinderGeometry(lineWidth, lineWidth, lineLength, 16);\n    const xMaterial = new THREE.MeshBasicMaterial({ \n      color: 0xff0000,\n      transparent: true,\n      opacity: 0.8\n    });\n    const xLine = new THREE.Mesh(xGeometry, xMaterial);\n    xLine.rotation.z = -Math.PI / 2;\n    xLine.position.x = lineLength / 2;\n    this.cubeAxisLines.x = xLine;\n    this.mesh.add(xLine);\n    \n    // Y-axis line (green)\n    const yGeometry = new THREE.CylinderGeometry(lineWidth, lineWidth, lineLength, 16);\n    const yMaterial = new THREE.MeshBasicMaterial({ \n      color: 0x00ff00,\n      transparent: true,\n      opacity: 0.8\n    });\n    const yLine = new THREE.Mesh(yGeometry, yMaterial);\n    yLine.position.y = lineLength / 2;\n    this.cubeAxisLines.y = yLine;\n    this.mesh.add(yLine);\n    \n    // Z-axis line (blue)\n    const zGeometry = new THREE.CylinderGeometry(lineWidth, lineWidth, lineLength, 16);\n    const zMaterial = new THREE.MeshBasicMaterial({ \n      color: 0x0000ff,\n      transparent: true,\n      opacity: 0.8\n    });\n    const zLine = new THREE.Mesh(zGeometry, zMaterial);\n    zLine.rotation.x = Math.PI / 2;\n    zLine.position.z = lineLength / 2;\n    this.cubeAxisLines.z = zLine;\n    this.mesh.add(zLine);\n    \n    // Initially hide them\n    this.cubeAxisLines.x.visible = false;\n    this.cubeAxisLines.y.visible = false;\n    this.cubeAxisLines.z.visible = false;\n    \n    console.log(' Cube axis lines created');\n  }\n\n  /**\n   * Create square axis frames (like square rings) for cube style\n   */\n  createSquareAxisFrames() {\n    this.squareFrames = {};\n    \n    const size = 3.6; // Smaller than labels (at ~2.05), larger than axis lines (at 1.75)\n    const halfSize = size / 2;\n    const tubeRadius = 0.035; // Thickness of the square frame lines (proportionally thicker)\n    \n    // Helper function to create a thick square wireframe using tubes\n    const createSquareFrame = (color, axisName) => {\n      const group = new THREE.Group();\n      \n      // Create 4 edges of the square using cylinders (tubes)\n      const edges = [\n        // Bottom edge\n        { start: new THREE.Vector3(-halfSize, -halfSize, 0), end: new THREE.Vector3(halfSize, -halfSize, 0) },\n        // Right edge\n        { start: new THREE.Vector3(halfSize, -halfSize, 0), end: new THREE.Vector3(halfSize, halfSize, 0) },\n        // Top edge\n        { start: new THREE.Vector3(halfSize, halfSize, 0), end: new THREE.Vector3(-halfSize, halfSize, 0) },\n        // Left edge\n        { start: new THREE.Vector3(-halfSize, halfSize, 0), end: new THREE.Vector3(-halfSize, -halfSize, 0) }\n      ];\n      \n      const material = new THREE.LineDashedMaterial({\n        color: color,\n        transparent: true,\n        opacity: this.config.opacity,\n        dashSize: 0.3,           // Longer dashes for better visibility\n        gapSize: 0.2,            // Shorter gaps\n        linewidth: 3,\n        depthTest: true,\n        depthWrite: true\n      });\n      \n      edges.forEach(edge => {\n        const points = [edge.start, edge.end];\n        const geometry = new THREE.BufferGeometry().setFromPoints(points);\n        const line = new THREE.Line(geometry, material.clone());\n        line.computeLineDistances();\n        \n        group.add(line);\n      });\n      \n      // Store reference for raycasting\n      group.userData = {\n        type: 'gizmo-axis',\n        axis: axisName,\n        axisVector: axisName === 'x' ? new THREE.Vector3(1, 0, 0) :\n                    axisName === 'y' ? new THREE.Vector3(0, 1, 0) :\n                    new THREE.Vector3(0, 0, 1)\n      };\n      \n      return group;\n    };\n    \n    // X-axis square frame (YZ plane) - Default gray (colored on hover)\n    this.squareFrames.x = createSquareFrame(this.defaultColor, 'x');\n    this.squareFrames.x.rotation.y = Math.PI / 2;\n    this.mesh.add(this.squareFrames.x);\n    \n    // Y-axis square frame (XZ plane) - Default gray (colored on hover)\n    this.squareFrames.y = createSquareFrame(this.defaultColor, 'y');\n    this.squareFrames.y.rotation.x = Math.PI / 2;\n    this.mesh.add(this.squareFrames.y);\n    \n    // Z-axis square frame (XY plane) - Default gray (colored on hover)\n    this.squareFrames.z = createSquareFrame(this.defaultColor, 'z');\n    this.mesh.add(this.squareFrames.z);\n    \n    // Initially hide them\n    this.squareFrames.x.visible = false;\n    this.squareFrames.y.visible = false;\n    this.squareFrames.z.visible = false;\n    \n    console.log(' Square axis frames created');\n  }\n\n  /**\n   * Create square planes for cube style\n   */\n  createCubePlanes() {\n    this.cubePlanes = {};\n    \n    const planeSize = this.config.radius * 0.7; // Size of the square planes\n    const distance = this.config.radius; // Distance from center\n    \n    // === X-AXIS PLANE (YZ plane) ===\n    const xGeometry = new THREE.PlaneGeometry(planeSize, planeSize);\n    const xMaterial = new THREE.MeshBasicMaterial({\n      color: 0xff0000,\n      transparent: true,\n      opacity: 0.3,\n      side: THREE.DoubleSide,\n      depthTest: true,\n      depthWrite: false\n    });\n    const xPlane = new THREE.Mesh(xGeometry, xMaterial);\n    xPlane.rotation.y = Math.PI / 2; // Face along X-axis\n    xPlane.position.x = distance;\n    xPlane.userData = {\n      type: 'gizmo-axis',\n      axis: 'x',\n      axisVector: new THREE.Vector3(1, 0, 0)\n    };\n    this.cubePlanes.x = xPlane;\n    this.mesh.add(xPlane);\n    \n    // === Y-AXIS PLANE (XZ plane) ===\n    const yGeometry = new THREE.PlaneGeometry(planeSize, planeSize);\n    const yMaterial = new THREE.MeshBasicMaterial({\n      color: 0x00ff00,\n      transparent: true,\n      opacity: 0.3,\n      side: THREE.DoubleSide,\n      depthTest: true,\n      depthWrite: false\n    });\n    const yPlane = new THREE.Mesh(yGeometry, yMaterial);\n    yPlane.rotation.x = Math.PI / 2; // Face along Y-axis\n    yPlane.position.y = distance;\n    yPlane.userData = {\n      type: 'gizmo-axis',\n      axis: 'y',\n      axisVector: new THREE.Vector3(0, 1, 0)\n    };\n    this.cubePlanes.y = yPlane;\n    this.mesh.add(yPlane);\n    \n    // === Z-AXIS PLANE (XY plane) ===\n    const zGeometry = new THREE.PlaneGeometry(planeSize, planeSize);\n    const zMaterial = new THREE.MeshBasicMaterial({\n      color: 0x0000ff,\n      transparent: true,\n      opacity: 0.3,\n      side: THREE.DoubleSide,\n      depthTest: true,\n      depthWrite: false\n    });\n    const zPlane = new THREE.Mesh(zGeometry, zMaterial);\n    zPlane.position.z = distance;\n    zPlane.userData = {\n      type: 'gizmo-axis',\n      axis: 'z',\n      axisVector: new THREE.Vector3(0, 0, 1)\n    };\n    this.cubePlanes.z = zPlane;\n    this.mesh.add(zPlane);\n    \n    // Initially hide them (circular is default)\n    this.cubePlanes.x.visible = false;\n    this.cubePlanes.y.visible = false;\n    this.cubePlanes.z.visible = false;\n    \n    console.log(' Cube style planes created');\n  }\n\n  /**\n   * Clean up resources\n   */\n  dispose() {\n    // Dispose axis rings\n    Object.keys(this.axes).forEach(key => {\n      const axis = this.axes[key];\n      axis.mesh.geometry.dispose();\n      axis.material.dispose();\n    });\n    \n    // Dispose labels\n    if (this.labels) {\n      Object.keys(this.labels).forEach(key => {\n        const label = this.labels[key];\n        if (label.material.map) {\n          label.material.map.dispose();\n        }\n        label.material.dispose();\n      });\n    }\n  }\n}\n\n","import * as THREE from 'three';\n\n/**\n * Math utilities for rotation calculations\n */\n\n/**\n * Calculate ray-plane intersection point\n * @param {THREE.Ray} ray - Ray to intersect\n * @param {THREE.Plane} plane - Plane to intersect with\n * @returns {THREE.Vector3|null} - Intersection point or null if no intersection\n */\nexport function rayPlaneIntersection(ray, plane) {\n  const target = new THREE.Vector3();\n  const intersection = ray.intersectPlane(plane, target);\n  \n  if (intersection) {\n    return intersection;\n  }\n  \n  return null;\n}\n\n/**\n * Calculate signed angle between two vectors around an axis\n * @param {THREE.Vector3} v1 - First vector (should be normalized)\n * @param {THREE.Vector3} v2 - Second vector (should be normalized)\n * @param {THREE.Vector3} axis - Axis to measure rotation around (should be normalized)\n * @returns {number} - Signed angle in radians\n */\nexport function signedAngle(v1, v2, axis) {\n  // Calculate the angle between vectors\n  const angle = v1.angleTo(v2);\n  \n  // Determine the sign using the cross product\n  const cross = new THREE.Vector3().crossVectors(v1, v2);\n  const sign = Math.sign(cross.dot(axis));\n  \n  // Return signed angle\n  return angle * sign;\n}\n\n/**\n * Create a quaternion from axis and angle\n * @param {THREE.Vector3} axis - Rotation axis (should be normalized)\n * @param {number} angle - Rotation angle in radians\n * @returns {THREE.Quaternion} - Resulting quaternion\n */\nexport function quaternionFromAxisAngle(axis, angle) {\n  const quaternion = new THREE.Quaternion();\n  quaternion.setFromAxisAngle(axis, angle);\n  return quaternion;\n}\n\n/**\n * Clamp angle to snap increments (for snapping feature - Phase 6)\n * @param {number} angle - Angle in radians\n * @param {number} snapAngle - Snap increment in degrees\n * @returns {number} - Snapped angle in radians\n */\nexport function snapAngle(angle, snapAngle = 15) {\n  const snapRadians = (snapAngle * Math.PI) / 180;\n  return Math.round(angle / snapRadians) * snapRadians;\n}\n\n/**\n * Create a rotation plane perpendicular to the given axis\n * @param {THREE.Vector3} axis - Axis vector (X, Y, or Z)\n * @param {THREE.Vector3} point - Point on the plane (usually object position)\n * @returns {THREE.Plane} - Plane perpendicular to the axis\n */\nexport function createRotationPlane(axis, point) {\n  // Plane normal is the axis itself\n  const plane = new THREE.Plane();\n  plane.setFromNormalAndCoplanarPoint(axis, point);\n  return plane;\n}\n\n","import * as THREE from 'three';\nimport { rayPlaneIntersection, signedAngle, quaternionFromAxisAngle, createRotationPlane } from '../utils/MathUtils.js';\n\n/**\n * Input Handler - Manages mouse interactions with the 3D scene\n * Handles raycasting, axis picking, and user input events\n */\nexport class InputHandler {\n  constructor(camera, domElement, gizmo, app = null) {\n    this.camera = camera;\n    this.domElement = domElement;\n    this.gizmo = gizmo;\n    this.app = app; // Reference to main app for slice control\n\n    // Raycasting setup\n    this.raycaster = new THREE.Raycaster();\n    // Increase threshold for easier picking of thin geometries\n    this.raycaster.params.Points.threshold = 0.5;\n    this.raycaster.params.Line.threshold = 0.5;\n    this.mouse = new THREE.Vector2();\n    \n    // Debug mode\n    this.debugMode = true;\n\n    // Stability settings (Phase 5)\n    this.config = {\n      minAngleThreshold: 0.001,  // Dead zone: ignore tiny rotations (radians)\n      maxCameraAlignmentDot: 0.99  // Threshold for camera-axis alignment detection\n    };\n\n    // State tracking\n    this.isDragging = false;\n    this.hoveredAxis = null;\n    this.selectedAxis = null;\n    this.isCameraRotating = false;  // Track camera rotation to prevent hover flicker\n    \n    // For detecting click vs drag\n    this.mouseDownPosition = new THREE.Vector2();\n    this.mouseDownTime = 0;\n    \n    // Track if we hit a label vs a ring\n    this.hitType = null; // 'label' or 'ring'\n\n    // Rotation state (Phase 4)\n    this.rotationPlane = null;\n    this.initialHitPoint = null;\n    this.initialRotation = null;\n    this.currentAxisVector = null;\n\n    // Callbacks for orbit controls integration\n    this.onGizmoInteractionStart = null;\n    this.onGizmoInteractionEnd = null;\n\n    // Bind event handlers\n    this.onMouseMove = this.onMouseMove.bind(this);\n    this.onMouseDown = this.onMouseDown.bind(this);\n    this.onMouseUp = this.onMouseUp.bind(this);\n\n    // Attach event listeners with capture phase to intercept before OrbitControls\n    this.attachEventListeners();\n\n    console.log(' Input Handler initialized');\n  }\n\n  /**\n   * Attach mouse event listeners to the DOM element\n   * Using capture phase (true) to intercept events before OrbitControls\n   */\n  attachEventListeners() {\n    // Use capture phase to get events before OrbitControls\n    this.domElement.addEventListener('mousemove', this.onMouseMove, true);\n    this.domElement.addEventListener('mousedown', this.onMouseDown, true);\n    this.domElement.addEventListener('mouseup', this.onMouseUp, true);\n  }\n\n  /**\n   * Remove event listeners (cleanup)\n   */\n  detachEventListeners() {\n    this.domElement.removeEventListener('mousemove', this.onMouseMove, true);\n    this.domElement.removeEventListener('mousedown', this.onMouseDown, true);\n    this.domElement.removeEventListener('mouseup', this.onMouseUp, true);\n  }\n\n  /**\n   * Convert mouse coordinates to Normalized Device Coordinates (NDC)\n   * @param {MouseEvent} event - Mouse event\n   */\n  updateMousePosition(event) {\n    const rect = this.domElement.getBoundingClientRect();\n    \n    // Convert to NDC (-1 to +1)\n    this.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;\n    this.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;\n  }\n\n  /**\n   * Perform raycasting to detect gizmo axis intersection\n   * @returns {Object|null} - Intersected axis data or null\n   */\n  raycastGizmo() {\n    // Update raycaster with current mouse position\n    this.raycaster.setFromCamera(this.mouse, this.camera);\n\n    // Get all gizmo meshes for picking\n    const pickingMeshes = this.gizmo.getPickingMeshes();\n\n    // Perform raycast (recursive=true to check children of Groups like square frames)\n    const intersects = this.raycaster.intersectObjects(pickingMeshes, true);\n\n    // Debug: Log raycast attempts\n    if (this.debugMode && intersects.length > 0) {\n      console.log(` Raycast hit ${intersects.length} object(s)`);\n    }\n\n    if (intersects.length > 0) {\n      const intersection = intersects[0];\n      let userData = intersection.object.userData;\n      \n      // If the hit object doesn't have userData, check parent (for groups/children)\n      let checkObject = intersection.object;\n      while ((!userData.type || !userData.axis) && checkObject.parent) {\n        checkObject = checkObject.parent;\n        userData = checkObject.userData;\n        if (userData.axis) break;\n      }\n\n      // Handle both axis rings and labels\n      if (userData.type === 'gizmo-axis' || userData.type === 'gizmo-label') {\n        const isLabel = userData.type === 'gizmo-label';\n        if (this.debugMode) {\n          const type = isLabel ? 'label' : 'axis';\n          console.log(` Hit ${userData.axis.toUpperCase()}-axis ${type} at distance ${intersection.distance.toFixed(2)}`);\n        }\n        return {\n          axis: userData.axis,\n          axisVector: userData.axisVector,\n          point: intersection.point,\n          object: intersection.object,\n          isLabel: isLabel  // Track if this is a label or ring\n        };\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Handle mouse move event\n   * @param {MouseEvent} event - Mouse event\n   */\n  onMouseMove(event) {\n    // Update mouse position\n    this.updateMousePosition(event);\n\n    // Handle Y-axis dual interaction (detect drag direction on first move)\n    if (this.yAxisDragMode !== undefined) {\n      if (this.yAxisDragMode === null) {\n        // Determine drag direction based on initial movement\n        const deltaX = Math.abs(event.clientX - this.sliceDragStartX);\n        const deltaY = Math.abs(event.clientY - this.sliceDragStartY);\n        \n        if (deltaX > 5 || deltaY > 5) {  // Threshold to detect direction\n          if (deltaY > deltaX) {\n            // More vertical movement - slice control\n            this.yAxisDragMode = 'slice';\n            this.isControllingSlice = true;\n            this.isDragging = false;\n            this.domElement.style.cursor = \"url('/pointer.png') 3 3, ns-resize\";\n            console.log(` Y-axis: Vertical drag detected - slice control`);\n          } else {\n            // More horizontal movement - rotation\n            this.yAxisDragMode = 'rotate';\n            this.isDragging = true;\n            this.isControllingSlice = false;\n            this.gizmo.isRotating = true;\n            this.domElement.style.cursor = \"url('/pointer.png') 3 3, ew-resize\";\n            this.setupRotation({ axis: 'y', axisVector: new THREE.Vector3(0, 1, 0) });\n            console.log(` Y-axis: Horizontal drag detected - rotation`);\n          }\n        }\n      }\n      \n      // Execute the determined action\n      if (this.yAxisDragMode === 'slice') {\n        this.updateSlicePosition(event);\n      } else if (this.yAxisDragMode === 'rotate') {\n        this.updateRotation(event);\n      }\n    } else if (this.isControllingSlice) {\n      // Legacy slice control (for Y-axis label)\n      this.updateSlicePosition(event);\n    } else if (this.isDragging) {\n      // Perform rotation during drag\n      this.updateRotation();\n    } else if (!this.isCameraRotating) {\n      // Only check for hover if not dragging and not rotating camera\n      this.updateHover();\n    }\n  }\n\n  /**\n   * Update hover state based on raycasting\n   */\n  updateHover() {\n    const hit = this.raycastGizmo();\n\n    if (hit) {\n      // Mouse is over a gizmo axis\n      if (this.hoveredAxis !== hit.axis) {\n        this.hoveredAxis = hit.axis;\n        this.gizmo.setHoverAxis(hit.axis);\n        this.domElement.style.cursor = \"url('/pointer.png') 3 3, auto\";\n        \n        console.log(` Hovering over ${hit.axis.toUpperCase()}-axis`);\n      }\n    } else {\n      // Mouse is not over any axis\n      if (this.hoveredAxis !== null) {\n        console.log(' Hover ended');\n        this.gizmo.setHoverAxis(null);\n        this.hoveredAxis = null;\n        this.domElement.style.cursor = \"url('/pointer.png') 3 3, auto\";\n      }\n    }\n  }\n\n  /**\n   * Handle mouse down event\n   * @param {MouseEvent} event - Mouse event\n   */\n  onMouseDown(event) {\n    // Only handle left mouse button\n    if (event.button !== 0) return;\n\n    // Update mouse position\n    this.updateMousePosition(event);\n\n    // Check if clicking on gizmo\n    const hit = this.raycastGizmo();\n\n    if (hit) {\n      // Store mouse down info for click detection\n      this.mouseDownPosition.copy(this.mouse);\n      this.mouseDownTime = Date.now();\n      this.hitType = hit.isLabel ? 'label' : 'ring';\n      this.selectedAxis = hit.axis;\n      \n      if (hit.isLabel) {\n        // LABEL CLICKED: Check if it's Y-axis for slice control\n        if (hit.axis === 'y' && this.app) {\n          // Y-AXIS LABEL: Start slice control mode\n          event.stopPropagation();\n          event.preventDefault();\n          \n          this.isControllingSlice = true;\n          this.isDragging = false;\n          this.isCameraRotating = false;\n          this.sliceDragStartY = event.clientY;\n          this.sliceStartPosition = this.app.transverseYPosition || 0;\n          \n          this.domElement.style.cursor = \"url('/pointer.png') 3 3, ns-resize\";\n          \n          console.log(` Y-axis label clicked - transverse slice control enabled`);\n          \n        } else {\n          // OTHER LABELS: Allow camera rotation (don't block OrbitControls)\n          this.isCameraRotating = true;\n          this.isDragging = false;\n          \n          console.log(` Label ${hit.axis.toUpperCase()} clicked - camera rotation enabled`);\n        }\n        \n      } else {\n        // RING/AXIS CLICKED: Check if it's Y-axis for dual interaction\n        if (hit.axis === 'y' && this.app) {\n          // Y-AXIS: Support both slice control (vertical) and rotation (horizontal)\n          event.stopPropagation();\n          event.preventDefault();\n          \n          // Store initial mouse position to detect drag direction\n          this.yAxisDragMode = null; // Will be set to 'slice' or 'rotate' on first move\n          this.sliceDragStartY = event.clientY;\n          this.sliceDragStartX = event.clientX;\n          this.sliceStartPosition = this.app.transverseYPosition || 0;\n          \n          // Update gizmo visual state for Y-axis\n          this.gizmo.setActiveAxis(hit.axis);\n          \n          this.domElement.style.cursor = \"url('/pointer.png') 3 3, move\";\n          \n          // Disable orbit controls\n          if (this.onGizmoInteractionStart) {\n            this.onGizmoInteractionStart();\n          }\n          \n          console.log(` Y-axis grabbed - waiting for drag direction`);\n          \n        } else {\n          // OTHER AXES (X, Z): Setup axis rotation (block OrbitControls)\n          event.stopPropagation();\n          event.preventDefault();\n          \n          this.isDragging = true;\n          this.isCameraRotating = false;\n          \n          // Update gizmo visual state\n          this.gizmo.setActiveAxis(hit.axis);\n          this.gizmo.isRotating = true;\n          \n          // Change cursor\n          this.domElement.style.cursor = \"url('/pointer.png') 3 3, auto\";\n          \n          // Disable orbit controls\n          if (this.onGizmoInteractionStart) {\n            this.onGizmoInteractionStart();\n          }\n          \n          console.log(` Ring ${hit.axis.toUpperCase()} grabbed - axis rotation enabled`);\n          \n          // Phase 4: Store initial rotation state\n          this.setupRotation(hit);\n        }\n      }\n    } else {\n      // Clicking on empty space - camera rotation will start\n      this.isCameraRotating = true;\n      this.hitType = null;\n      // Clear any hover state\n      this.gizmo.setHoverAxis(null);\n      this.hoveredAxis = null;\n    }\n  }\n\n  /**\n   * Handle mouse up event\n   * @param {MouseEvent} event - Mouse event\n   */\n  onMouseUp(event) {\n    // Check if this was a quick click on a label\n    const mouseUpTime = Date.now();\n    const timeDiff = mouseUpTime - this.mouseDownTime;\n    const mouseDist = this.mouse.distanceTo(this.mouseDownPosition);\n    \n    // Handle Y-axis dual interaction end\n    if (this.yAxisDragMode !== undefined) {\n      this.yAxisDragMode = undefined;\n      this.isControllingSlice = false;\n      this.isDragging = false;\n      this.domElement.style.cursor = \"url('/pointer.png') 3 3, auto\";\n      \n      // Clear active axis visual state\n      this.gizmo.clearActiveAxis();\n      this.gizmo.isRotating = false;\n      \n      // Re-enable orbit controls\n      if (this.onGizmoInteractionEnd) {\n        this.onGizmoInteractionEnd();\n      }\n      \n      console.log(` Y-axis interaction ended`);\n    }\n    \n    // Handle slice control end (legacy for Y-axis label)\n    if (this.isControllingSlice) {\n      this.isControllingSlice = false;\n      this.domElement.style.cursor = \"url('/pointer.png') 3 3, auto\";\n      \n      // Clear active axis visual state\n      this.gizmo.clearActiveAxis();\n      \n      // Re-enable orbit controls\n      if (this.onGizmoInteractionEnd) {\n        this.onGizmoInteractionEnd();\n      }\n      \n      console.log(` Transverse slice control ended at Y = ${this.app.transverseYPosition.toFixed(2)}`);\n    }\n    \n    // If quick click with minimal movement on a LABEL (not Y-axis), snap to axis view\n    if (timeDiff < 250 && mouseDist < 0.05 && this.selectedAxis && this.hitType === 'label' && this.selectedAxis !== 'y') {\n      console.log(` Quick label click - snapping to ${this.selectedAxis.toUpperCase()}-axis view`);\n      this.snapToAxisView(this.selectedAxis);\n    }\n    \n    if (this.isDragging) {\n      // Stop propagation if we were dragging a RING\n      event.stopPropagation();\n      event.preventDefault();\n      \n      this.isDragging = false;\n      \n      // Clear active axis\n      this.gizmo.clearActiveAxis();\n      \n      // Restore cursor\n      this.domElement.style.cursor = \"url('/pointer.png') 8 8, auto\";\n      \n      // Re-enable orbit controls\n      if (this.onGizmoInteractionEnd) {\n        this.onGizmoInteractionEnd();\n      }\n      \n      console.log(' Ring rotation ended');\n      \n      // Phase 4: Clear rotation state\n      this.clearRotationState();\n    }\n    \n    // Clear selection state\n    this.selectedAxis = null;\n    this.hitType = null;\n    \n    // End camera rotation mode\n    this.isCameraRotating = false;\n  }\n\n  /**\n   * Setup rotation state when axis is selected (Phase 4/5)\n   * @param {Object} hit - Raycast hit data\n   */\n  setupRotation(hit) {\n    // Get axis vector (in world space for local mode support)\n    this.currentAxisVector = this.gizmo.getWorldAxisVector(hit.axis);\n    \n    if (!this.currentAxisVector) {\n      console.error(' Failed to get axis vector');\n      return;\n    }\n\n    // Phase 5: Check if camera is aligned with rotation axis\n    const cameraDirection = new THREE.Vector3();\n    this.camera.getWorldDirection(cameraDirection);\n    const alignment = Math.abs(cameraDirection.dot(this.currentAxisVector));\n\n    if (alignment > this.config.maxCameraAlignmentDot) {\n      // Camera is too aligned with axis, use fallback plane\n      console.log(' Camera aligned with axis - using fallback plane');\n      this.currentAxisVector = this.getFallbackAxis(this.currentAxisVector, cameraDirection);\n    }\n    \n    // Create a plane perpendicular to the rotation axis\n    const targetPosition = this.gizmo.target.position;\n    this.rotationPlane = createRotationPlane(this.currentAxisVector, targetPosition);\n    \n    // Get initial hit point on the plane\n    this.raycaster.setFromCamera(this.mouse, this.camera);\n    const ray = this.raycaster.ray;\n    this.initialHitPoint = rayPlaneIntersection(ray, this.rotationPlane);\n    \n    // Store initial rotation\n    this.initialRotation = this.gizmo.target.quaternion.clone();\n    \n    if (this.initialHitPoint) {\n      console.log(` Rotation setup complete for ${hit.axis.toUpperCase()}-axis`);\n    } else {\n      console.warn(' Could not establish initial hit point');\n    }\n  }\n\n  /**\n   * Get fallback axis when camera is aligned with rotation axis (Phase 5)\n   * @param {THREE.Vector3} originalAxis - Original rotation axis\n   * @param {THREE.Vector3} cameraDirection - Camera direction\n   * @returns {THREE.Vector3} - Fallback axis perpendicular to camera\n   */\n  getFallbackAxis(originalAxis, cameraDirection) {\n    // Use camera's up vector as fallback\n    const cameraUp = this.camera.up.clone();\n    const fallbackAxis = new THREE.Vector3().crossVectors(cameraDirection, cameraUp);\n    fallbackAxis.normalize();\n    \n    console.log(' Using fallback rotation plane');\n    return fallbackAxis;\n  }\n\n  /**\n   * Update transverse slice position during Y-axis drag\n   */\n  updateSlicePosition(event) {\n    if (!this.app) return;\n    \n    const deltaY = event.clientY - this.sliceDragStartY;\n    const sensitivity = 0.02; // Adjust sensitivity\n    const newY = this.sliceStartPosition - deltaY * sensitivity; // Invert for intuitive control\n    \n    // Clamp to gizmo bounds (don't go beyond Y-axis label button)\n    // Gizmo is at Y=1.0, radius is 3.5, so label is at ~Y=4.0 in world space\n    // Model space: clamp to 3.0 (safe range within gizmo)\n    const clampedY = Math.max(-3.0, Math.min(3.0, newY));\n    \n    this.app.updateTransverseClipping(clampedY);\n  }\n\n  /**\n   * Update rotation during mouse drag (Phase 4/5)\n   */\n  updateRotation() {\n    if (!this.initialHitPoint || !this.rotationPlane || !this.currentAxisVector) {\n      return;\n    }\n\n    // Cast ray to rotation plane\n    this.raycaster.setFromCamera(this.mouse, this.camera);\n    const ray = this.raycaster.ray;\n    const currentHitPoint = rayPlaneIntersection(ray, this.rotationPlane);\n\n    // Phase 5: Handle ray parallel to plane (no intersection)\n    if (!currentHitPoint) {\n      // Ray is parallel to plane or no intersection - skip this frame\n      return;\n    }\n\n    // Get target position (pivot point)\n    const pivot = this.gizmo.target.position;\n\n    // Calculate vectors from pivot to hit points\n    const startVector = new THREE.Vector3().subVectors(this.initialHitPoint, pivot);\n    const currentVector = new THREE.Vector3().subVectors(currentHitPoint, pivot);\n\n    // Phase 5: Check if vectors are valid (not zero-length)\n    const startLength = startVector.length();\n    const currentLength = currentVector.length();\n    \n    if (startLength < 0.001 || currentLength < 0.001) {\n      // Too close to pivot point - skip\n      return;\n    }\n\n    // Normalize vectors\n    startVector.normalize();\n    currentVector.normalize();\n\n    // Calculate signed angle between vectors\n    const angle = signedAngle(startVector, currentVector, this.currentAxisVector);\n\n    // Phase 5: Dead zone - ignore very small angle changes to prevent jitter\n    if (Math.abs(angle) < this.config.minAngleThreshold) {\n      return;\n    }\n\n    // Create rotation quaternion\n    const deltaRotation = quaternionFromAxisAngle(this.currentAxisVector, angle);\n\n    // Apply rotation relative to initial rotation (prevents drift)\n    this.gizmo.target.quaternion.copy(this.initialRotation);\n    this.gizmo.target.quaternion.premultiply(deltaRotation);\n\n    // Optional: Log rotation for debugging (only significant angles)\n    if (this.debugMode && Math.abs(angle) > 0.01) {\n      const degrees = (angle * 180 / Math.PI).toFixed(1);\n      console.log(` Rotating ${degrees} around ${this.selectedAxis.toUpperCase()}-axis`);\n    }\n  }\n\n  /**\n   * Clear rotation state (Phase 4)\n   */\n  clearRotationState() {\n    this.rotationPlane = null;\n    this.initialHitPoint = null;\n    this.initialRotation = null;\n    this.currentAxisVector = null;\n  }\n\n  /**\n   * Snap camera to look down the clicked axis (orthographic-like view)\n   * @param {string} axisName - Axis to look down ('x', 'y', 'z')\n   */\n  snapToAxisView(axisName) {\n    // Calculate target camera position to look down the clicked axis\n    const distance = this.camera.position.length(); // Maintain current distance\n    const targetPosition = new THREE.Vector3();\n    \n    if (axisName === 'x') {\n      // Look down X-axis: camera on +X, looking toward origin\n      // This puts X label at center, Y and Z perpendicular\n      targetPosition.set(distance, 0, 0);\n    } else if (axisName === 'y') {\n      // Look down Y-axis: camera on +Y, looking toward origin\n      // This puts Y label at center, X and Z perpendicular\n      targetPosition.set(0, distance, 0);\n    } else if (axisName === 'z') {\n      // Look down Z-axis: camera on +Z, looking toward origin\n      // This puts Z label at center, X and Y perpendicular\n      targetPosition.set(0, 0, distance);\n    }\n\n    // Animate camera to target position\n    const duration = 600;\n    const startTime = Date.now();\n    const startPosition = this.camera.position.clone();\n\n    // Temporarily disable orbit controls during animation\n    if (this.onGizmoInteractionStart) {\n      this.onGizmoInteractionStart();\n    }\n\n    const animate = () => {\n      const elapsed = Date.now() - startTime;\n      const progress = Math.min(elapsed / duration, 1);\n      \n      // Smooth ease-in-out\n      const eased = 0.5 - Math.cos(progress * Math.PI) / 2;\n      \n      // Interpolate camera position\n      this.camera.position.lerpVectors(startPosition, targetPosition, eased);\n      \n      // Keep camera looking at origin (where gizmo is)\n      this.camera.lookAt(0, 0, 0);\n      \n      if (progress < 1) {\n        requestAnimationFrame(animate);\n      } else {\n        // Re-enable orbit controls after animation\n        if (this.onGizmoInteractionEnd) {\n          this.onGizmoInteractionEnd();\n        }\n        console.log(` Camera aligned to ${axisName.toUpperCase()}-axis view`);\n      }\n    };\n\n    animate();\n  }\n\n  /**\n   * Get current interaction state\n   * @returns {Object} - Current state\n   */\n  getState() {\n    return {\n      isDragging: this.isDragging,\n      hoveredAxis: this.hoveredAxis,\n      selectedAxis: this.selectedAxis\n    };\n  }\n\n  /**\n   * Clean up resources\n   */\n  dispose() {\n    this.detachEventListeners();\n  }\n}\n\n","import {\n\tBufferAttribute,\n\tBufferGeometry,\n\tFloat32BufferAttribute,\n\tInstancedBufferAttribute,\n\tInterleavedBuffer,\n\tInterleavedBufferAttribute,\n\tTriangleFanDrawMode,\n\tTriangleStripDrawMode,\n\tTrianglesDrawMode,\n\tVector3,\n} from 'three';\n\n/**\n * @module BufferGeometryUtils\n * @three_import import * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';\n */\n\n/**\n * Computes vertex tangents using the MikkTSpace algorithm. MikkTSpace generates the same tangents consistently,\n * and is used in most modelling tools and normal map bakers. Use MikkTSpace for materials with normal maps,\n * because inconsistent tangents may lead to subtle visual issues in the normal map, particularly around mirrored\n * UV seams.\n *\n * In comparison to this method, {@link BufferGeometry#computeTangents} (a custom algorithm) generates tangents that\n * probably will not match the tangents in other software. The custom algorithm is sufficient for general use with a\n * custom material, and may be faster than MikkTSpace.\n *\n * Returns the original BufferGeometry. Indexed geometries will be de-indexed. Requires position, normal, and uv attributes.\n *\n * @param {BufferGeometry} geometry - The geometry to compute tangents for.\n * @param {Object} MikkTSpace - Instance of `examples/jsm/libs/mikktspace.module.js`, or `mikktspace` npm package.\n * Await `MikkTSpace.ready` before use.\n * @param {boolean} [negateSign=true] - Whether to negate the sign component (.w) of each tangent.\n * Required for normal map conventions in some formats, including glTF.\n * @return {BufferGeometry} The updated geometry.\n */\nfunction computeMikkTSpaceTangents( geometry, MikkTSpace, negateSign = true ) {\n\n\tif ( ! MikkTSpace || ! MikkTSpace.isReady ) {\n\n\t\tthrow new Error( 'BufferGeometryUtils: Initialized MikkTSpace library required.' );\n\n\t}\n\n\tif ( ! geometry.hasAttribute( 'position' ) || ! geometry.hasAttribute( 'normal' ) || ! geometry.hasAttribute( 'uv' ) ) {\n\n\t\tthrow new Error( 'BufferGeometryUtils: Tangents require \"position\", \"normal\", and \"uv\" attributes.' );\n\n\t}\n\n\tfunction getAttributeArray( attribute ) {\n\n\t\tif ( attribute.normalized || attribute.isInterleavedBufferAttribute ) {\n\n\t\t\tconst dstArray = new Float32Array( attribute.count * attribute.itemSize );\n\n\t\t\tfor ( let i = 0, j = 0; i < attribute.count; i ++ ) {\n\n\t\t\t\tdstArray[ j ++ ] = attribute.getX( i );\n\t\t\t\tdstArray[ j ++ ] = attribute.getY( i );\n\n\t\t\t\tif ( attribute.itemSize > 2 ) {\n\n\t\t\t\t\tdstArray[ j ++ ] = attribute.getZ( i );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn dstArray;\n\n\t\t}\n\n\t\tif ( attribute.array instanceof Float32Array ) {\n\n\t\t\treturn attribute.array;\n\n\t\t}\n\n\t\treturn new Float32Array( attribute.array );\n\n\t}\n\n\t// MikkTSpace algorithm requires non-indexed input.\n\n\tconst _geometry = geometry.index ? geometry.toNonIndexed() : geometry;\n\n\t// Compute vertex tangents.\n\n\tconst tangents = MikkTSpace.generateTangents(\n\n\t\tgetAttributeArray( _geometry.attributes.position ),\n\t\tgetAttributeArray( _geometry.attributes.normal ),\n\t\tgetAttributeArray( _geometry.attributes.uv )\n\n\t);\n\n\t// Texture coordinate convention of glTF differs from the apparent\n\t// default of the MikkTSpace library; .w component must be flipped.\n\n\tif ( negateSign ) {\n\n\t\tfor ( let i = 3; i < tangents.length; i += 4 ) {\n\n\t\t\ttangents[ i ] *= - 1;\n\n\t\t}\n\n\t}\n\n\t//\n\n\t_geometry.setAttribute( 'tangent', new BufferAttribute( tangents, 4 ) );\n\n\tif ( geometry !== _geometry ) {\n\n\t\tgeometry.copy( _geometry );\n\n\t}\n\n\treturn geometry;\n\n}\n\n/**\n * Merges a set of geometries into a single instance. All geometries must have compatible attributes.\n *\n * @param {Array<BufferGeometry>} geometries - The geometries to merge.\n * @param {boolean} [useGroups=false] - Whether to use groups or not.\n * @return {?BufferGeometry} The merged geometry. Returns `null` if the merge does not succeed.\n */\nfunction mergeGeometries( geometries, useGroups = false ) {\n\n\tconst isIndexed = geometries[ 0 ].index !== null;\n\n\tconst attributesUsed = new Set( Object.keys( geometries[ 0 ].attributes ) );\n\tconst morphAttributesUsed = new Set( Object.keys( geometries[ 0 ].morphAttributes ) );\n\n\tconst attributes = {};\n\tconst morphAttributes = {};\n\n\tconst morphTargetsRelative = geometries[ 0 ].morphTargetsRelative;\n\n\tconst mergedGeometry = new BufferGeometry();\n\n\tlet offset = 0;\n\n\tfor ( let i = 0; i < geometries.length; ++ i ) {\n\n\t\tconst geometry = geometries[ i ];\n\t\tlet attributesCount = 0;\n\n\t\t// ensure that all geometries are indexed, or none\n\n\t\tif ( isIndexed !== ( geometry.index !== null ) ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// gather attributes, exit early if they're different\n\n\t\tfor ( const name in geometry.attributes ) {\n\n\t\t\tif ( ! attributesUsed.has( name ) ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tif ( attributes[ name ] === undefined ) attributes[ name ] = [];\n\n\t\t\tattributes[ name ].push( geometry.attributes[ name ] );\n\n\t\t\tattributesCount ++;\n\n\t\t}\n\n\t\t// ensure geometries have the same number of attributes\n\n\t\tif ( attributesCount !== attributesUsed.size ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. Make sure all geometries have the same number of attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// gather morph attributes, exit early if they're different\n\n\t\tif ( morphTargetsRelative !== geometry.morphTargetsRelative ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. .morphTargetsRelative must be consistent throughout all geometries.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tfor ( const name in geometry.morphAttributes ) {\n\n\t\t\tif ( ! morphAttributesUsed.has( name ) ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '.  .morphAttributes must be consistent throughout all geometries.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tif ( morphAttributes[ name ] === undefined ) morphAttributes[ name ] = [];\n\n\t\t\tmorphAttributes[ name ].push( geometry.morphAttributes[ name ] );\n\n\t\t}\n\n\t\tif ( useGroups ) {\n\n\t\t\tlet count;\n\n\t\t\tif ( isIndexed ) {\n\n\t\t\t\tcount = geometry.index.count;\n\n\t\t\t} else if ( geometry.attributes.position !== undefined ) {\n\n\t\t\t\tcount = geometry.attributes.position.count;\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. The geometry must have either an index or a position attribute' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tmergedGeometry.addGroup( offset, count, i );\n\n\t\t\toffset += count;\n\n\t\t}\n\n\t}\n\n\t// merge indices\n\n\tif ( isIndexed ) {\n\n\t\tlet indexOffset = 0;\n\t\tconst mergedIndex = [];\n\n\t\tfor ( let i = 0; i < geometries.length; ++ i ) {\n\n\t\t\tconst index = geometries[ i ].index;\n\n\t\t\tfor ( let j = 0; j < index.count; ++ j ) {\n\n\t\t\t\tmergedIndex.push( index.getX( j ) + indexOffset );\n\n\t\t\t}\n\n\t\t\tindexOffset += geometries[ i ].attributes.position.count;\n\n\t\t}\n\n\t\tmergedGeometry.setIndex( mergedIndex );\n\n\t}\n\n\t// merge attributes\n\n\tfor ( const name in attributes ) {\n\n\t\tconst mergedAttribute = mergeAttributes( attributes[ name ] );\n\n\t\tif ( ! mergedAttribute ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the ' + name + ' attribute.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tmergedGeometry.setAttribute( name, mergedAttribute );\n\n\t}\n\n\t// merge morph attributes\n\n\tfor ( const name in morphAttributes ) {\n\n\t\tconst numMorphTargets = morphAttributes[ name ][ 0 ].length;\n\n\t\tif ( numMorphTargets === 0 ) break;\n\n\t\tmergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};\n\t\tmergedGeometry.morphAttributes[ name ] = [];\n\n\t\tfor ( let i = 0; i < numMorphTargets; ++ i ) {\n\n\t\t\tconst morphAttributesToMerge = [];\n\n\t\t\tfor ( let j = 0; j < morphAttributes[ name ].length; ++ j ) {\n\n\t\t\t\tmorphAttributesToMerge.push( morphAttributes[ name ][ j ][ i ] );\n\n\t\t\t}\n\n\t\t\tconst mergedMorphAttribute = mergeAttributes( morphAttributesToMerge );\n\n\t\t\tif ( ! mergedMorphAttribute ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the ' + name + ' morphAttribute.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tmergedGeometry.morphAttributes[ name ].push( mergedMorphAttribute );\n\n\t\t}\n\n\t}\n\n\treturn mergedGeometry;\n\n}\n\n/**\n * Merges a set of attributes into a single instance. All attributes must have compatible properties and types.\n * Instances of {@link InterleavedBufferAttribute} are not supported.\n *\n * @param {Array<BufferAttribute>} attributes - The attributes to merge.\n * @return {?BufferAttribute} The merged attribute. Returns `null` if the merge does not succeed.\n */\nfunction mergeAttributes( attributes ) {\n\n\tlet TypedArray;\n\tlet itemSize;\n\tlet normalized;\n\tlet gpuType = - 1;\n\tlet arrayLength = 0;\n\n\tfor ( let i = 0; i < attributes.length; ++ i ) {\n\n\t\tconst attribute = attributes[ i ];\n\n\t\tif ( TypedArray === undefined ) TypedArray = attribute.array.constructor;\n\t\tif ( TypedArray !== attribute.array.constructor ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( itemSize === undefined ) itemSize = attribute.itemSize;\n\t\tif ( itemSize !== attribute.itemSize ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( normalized === undefined ) normalized = attribute.normalized;\n\t\tif ( normalized !== attribute.normalized ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( gpuType === - 1 ) gpuType = attribute.gpuType;\n\t\tif ( gpuType !== attribute.gpuType ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tarrayLength += attribute.count * itemSize;\n\n\t}\n\n\tconst array = new TypedArray( arrayLength );\n\tconst result = new BufferAttribute( array, itemSize, normalized );\n\tlet offset = 0;\n\n\tfor ( let i = 0; i < attributes.length; ++ i ) {\n\n\t\tconst attribute = attributes[ i ];\n\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\n\t\t\tconst tupleOffset = offset / itemSize;\n\t\t\tfor ( let j = 0, l = attribute.count; j < l; j ++ ) {\n\n\t\t\t\tfor ( let c = 0; c < itemSize; c ++ ) {\n\n\t\t\t\t\tconst value = attribute.getComponent( j, c );\n\t\t\t\t\tresult.setComponent( j + tupleOffset, c, value );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tarray.set( attribute.array, offset );\n\n\t\t}\n\n\t\toffset += attribute.count * itemSize;\n\n\t}\n\n\tif ( gpuType !== undefined ) {\n\n\t\tresult.gpuType = gpuType;\n\n\t}\n\n\treturn result;\n\n}\n\n/**\n * Performs a deep clone of the given buffer attribute.\n *\n * @param {BufferAttribute} attribute - The attribute to clone.\n * @return {BufferAttribute} The cloned attribute.\n */\nfunction deepCloneAttribute( attribute ) {\n\n\tif ( attribute.isInstancedInterleavedBufferAttribute || attribute.isInterleavedBufferAttribute ) {\n\n\t\treturn deinterleaveAttribute( attribute );\n\n\t}\n\n\tif ( attribute.isInstancedBufferAttribute ) {\n\n\t\treturn new InstancedBufferAttribute().copy( attribute );\n\n\t}\n\n\treturn new BufferAttribute().copy( attribute );\n\n}\n\n/**\n * Interleaves a set of attributes and returns a new array of corresponding attributes that share a\n * single {@link InterleavedBuffer} instance. All attributes must have compatible types.\n *\n * @param {Array<BufferAttribute>} attributes - The attributes to interleave.\n * @return {?Array<InterleavedBufferAttribute>} An array of interleaved attributes. If interleave does not succeed, the method returns `null`.\n */\nfunction interleaveAttributes( attributes ) {\n\n\t// Interleaves the provided attributes into an InterleavedBuffer and returns\n\t// a set of InterleavedBufferAttributes for each attribute\n\tlet TypedArray;\n\tlet arrayLength = 0;\n\tlet stride = 0;\n\n\t// calculate the length and type of the interleavedBuffer\n\tfor ( let i = 0, l = attributes.length; i < l; ++ i ) {\n\n\t\tconst attribute = attributes[ i ];\n\n\t\tif ( TypedArray === undefined ) TypedArray = attribute.array.constructor;\n\t\tif ( TypedArray !== attribute.array.constructor ) {\n\n\t\t\tconsole.error( 'AttributeBuffers of different types cannot be interleaved' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tarrayLength += attribute.array.length;\n\t\tstride += attribute.itemSize;\n\n\t}\n\n\t// Create the set of buffer attributes\n\tconst interleavedBuffer = new InterleavedBuffer( new TypedArray( arrayLength ), stride );\n\tlet offset = 0;\n\tconst res = [];\n\tconst getters = [ 'getX', 'getY', 'getZ', 'getW' ];\n\tconst setters = [ 'setX', 'setY', 'setZ', 'setW' ];\n\n\tfor ( let j = 0, l = attributes.length; j < l; j ++ ) {\n\n\t\tconst attribute = attributes[ j ];\n\t\tconst itemSize = attribute.itemSize;\n\t\tconst count = attribute.count;\n\t\tconst iba = new InterleavedBufferAttribute( interleavedBuffer, itemSize, offset, attribute.normalized );\n\t\tres.push( iba );\n\n\t\toffset += itemSize;\n\n\t\t// Move the data for each attribute into the new interleavedBuffer\n\t\t// at the appropriate offset\n\t\tfor ( let c = 0; c < count; c ++ ) {\n\n\t\t\tfor ( let k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\tiba[ setters[ k ] ]( c, attribute[ getters[ k ] ]( c ) );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn res;\n\n}\n\n/**\n * Returns a new, non-interleaved version of the given attribute.\n *\n * @param {InterleavedBufferAttribute} attribute - The interleaved attribute.\n * @return {BufferAttribute} The non-interleaved attribute.\n */\nfunction deinterleaveAttribute( attribute ) {\n\n\tconst cons = attribute.data.array.constructor;\n\tconst count = attribute.count;\n\tconst itemSize = attribute.itemSize;\n\tconst normalized = attribute.normalized;\n\n\tconst array = new cons( count * itemSize );\n\tlet newAttribute;\n\tif ( attribute.isInstancedInterleavedBufferAttribute ) {\n\n\t\tnewAttribute = new InstancedBufferAttribute( array, itemSize, normalized, attribute.meshPerAttribute );\n\n\t} else {\n\n\t\tnewAttribute = new BufferAttribute( array, itemSize, normalized );\n\n\t}\n\n\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\tnewAttribute.setX( i, attribute.getX( i ) );\n\n\t\tif ( itemSize >= 2 ) {\n\n\t\t\tnewAttribute.setY( i, attribute.getY( i ) );\n\n\t\t}\n\n\t\tif ( itemSize >= 3 ) {\n\n\t\t\tnewAttribute.setZ( i, attribute.getZ( i ) );\n\n\t\t}\n\n\t\tif ( itemSize >= 4 ) {\n\n\t\t\tnewAttribute.setW( i, attribute.getW( i ) );\n\n\t\t}\n\n\t}\n\n\treturn newAttribute;\n\n}\n\n/**\n * Deinterleaves all attributes on the given geometry.\n *\n * @param {BufferGeometry} geometry - The geometry to deinterleave.\n */\nfunction deinterleaveGeometry( geometry ) {\n\n\tconst attributes = geometry.attributes;\n\tconst morphTargets = geometry.morphTargets;\n\tconst attrMap = new Map();\n\n\tfor ( const key in attributes ) {\n\n\t\tconst attr = attributes[ key ];\n\t\tif ( attr.isInterleavedBufferAttribute ) {\n\n\t\t\tif ( ! attrMap.has( attr ) ) {\n\n\t\t\t\tattrMap.set( attr, deinterleaveAttribute( attr ) );\n\n\t\t\t}\n\n\t\t\tattributes[ key ] = attrMap.get( attr );\n\n\t\t}\n\n\t}\n\n\tfor ( const key in morphTargets ) {\n\n\t\tconst attr = morphTargets[ key ];\n\t\tif ( attr.isInterleavedBufferAttribute ) {\n\n\t\t\tif ( ! attrMap.has( attr ) ) {\n\n\t\t\t\tattrMap.set( attr, deinterleaveAttribute( attr ) );\n\n\t\t\t}\n\n\t\t\tmorphTargets[ key ] = attrMap.get( attr );\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * Returns the amount of bytes used by all attributes to represent the geometry.\n *\n * @param {BufferGeometry} geometry - The geometry.\n * @return {number} The estimate bytes used.\n */\nfunction estimateBytesUsed( geometry ) {\n\n\t// Return the estimated memory used by this geometry in bytes\n\t// Calculate using itemSize, count, and BYTES_PER_ELEMENT to account\n\t// for InterleavedBufferAttributes.\n\tlet mem = 0;\n\tfor ( const name in geometry.attributes ) {\n\n\t\tconst attr = geometry.getAttribute( name );\n\t\tmem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;\n\n\t}\n\n\tconst indices = geometry.getIndex();\n\tmem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;\n\treturn mem;\n\n}\n\n/**\n * Returns a new geometry with vertices for which all similar vertex attributes (within tolerance) are merged.\n *\n * @param {BufferGeometry} geometry - The geometry to merge vertices for.\n * @param {number} [tolerance=1e-4] - The tolerance value.\n * @return {BufferGeometry} - The new geometry with merged vertices.\n */\nfunction mergeVertices( geometry, tolerance = 1e-4 ) {\n\n\ttolerance = Math.max( tolerance, Number.EPSILON );\n\n\t// Generate an index buffer if the geometry doesn't have one, or optimize it\n\t// if it's already available.\n\tconst hashToIndex = {};\n\tconst indices = geometry.getIndex();\n\tconst positions = geometry.getAttribute( 'position' );\n\tconst vertexCount = indices ? indices.count : positions.count;\n\n\t// next value for triangle indices\n\tlet nextIndex = 0;\n\n\t// attributes and new attribute arrays\n\tconst attributeNames = Object.keys( geometry.attributes );\n\tconst tmpAttributes = {};\n\tconst tmpMorphAttributes = {};\n\tconst newIndices = [];\n\tconst getters = [ 'getX', 'getY', 'getZ', 'getW' ];\n\tconst setters = [ 'setX', 'setY', 'setZ', 'setW' ];\n\n\t// Initialize the arrays, allocating space conservatively. Extra\n\t// space will be trimmed in the last step.\n\tfor ( let i = 0, l = attributeNames.length; i < l; i ++ ) {\n\n\t\tconst name = attributeNames[ i ];\n\t\tconst attr = geometry.attributes[ name ];\n\n\t\ttmpAttributes[ name ] = new attr.constructor(\n\t\t\tnew attr.array.constructor( attr.count * attr.itemSize ),\n\t\t\tattr.itemSize,\n\t\t\tattr.normalized\n\t\t);\n\n\t\tconst morphAttributes = geometry.morphAttributes[ name ];\n\t\tif ( morphAttributes ) {\n\n\t\t\tif ( ! tmpMorphAttributes[ name ] ) tmpMorphAttributes[ name ] = [];\n\t\t\tmorphAttributes.forEach( ( morphAttr, i ) => {\n\n\t\t\t\tconst array = new morphAttr.array.constructor( morphAttr.count * morphAttr.itemSize );\n\t\t\t\ttmpMorphAttributes[ name ][ i ] = new morphAttr.constructor( array, morphAttr.itemSize, morphAttr.normalized );\n\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n\t// convert the error tolerance to an amount of decimal places to truncate to\n\tconst halfTolerance = tolerance * 0.5;\n\tconst exponent = Math.log10( 1 / tolerance );\n\tconst hashMultiplier = Math.pow( 10, exponent );\n\tconst hashAdditive = halfTolerance * hashMultiplier;\n\tfor ( let i = 0; i < vertexCount; i ++ ) {\n\n\t\tconst index = indices ? indices.getX( i ) : i;\n\n\t\t// Generate a hash for the vertex attributes at the current index 'i'\n\t\tlet hash = '';\n\t\tfor ( let j = 0, l = attributeNames.length; j < l; j ++ ) {\n\n\t\t\tconst name = attributeNames[ j ];\n\t\t\tconst attribute = geometry.getAttribute( name );\n\t\t\tconst itemSize = attribute.itemSize;\n\n\t\t\tfor ( let k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\t// double tilde truncates the decimal value\n\t\t\t\thash += `${ ~ ~ ( attribute[ getters[ k ] ]( index ) * hashMultiplier + hashAdditive ) },`;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Add another reference to the vertex if it's already\n\t\t// used by another index\n\t\tif ( hash in hashToIndex ) {\n\n\t\t\tnewIndices.push( hashToIndex[ hash ] );\n\n\t\t} else {\n\n\t\t\t// copy data to the new index in the temporary attributes\n\t\t\tfor ( let j = 0, l = attributeNames.length; j < l; j ++ ) {\n\n\t\t\t\tconst name = attributeNames[ j ];\n\t\t\t\tconst attribute = geometry.getAttribute( name );\n\t\t\t\tconst morphAttributes = geometry.morphAttributes[ name ];\n\t\t\t\tconst itemSize = attribute.itemSize;\n\t\t\t\tconst newArray = tmpAttributes[ name ];\n\t\t\t\tconst newMorphArrays = tmpMorphAttributes[ name ];\n\n\t\t\t\tfor ( let k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\t\tconst getterFunc = getters[ k ];\n\t\t\t\t\tconst setterFunc = setters[ k ];\n\t\t\t\t\tnewArray[ setterFunc ]( nextIndex, attribute[ getterFunc ]( index ) );\n\n\t\t\t\t\tif ( morphAttributes ) {\n\n\t\t\t\t\t\tfor ( let m = 0, ml = morphAttributes.length; m < ml; m ++ ) {\n\n\t\t\t\t\t\t\tnewMorphArrays[ m ][ setterFunc ]( nextIndex, morphAttributes[ m ][ getterFunc ]( index ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\thashToIndex[ hash ] = nextIndex;\n\t\t\tnewIndices.push( nextIndex );\n\t\t\tnextIndex ++;\n\n\t\t}\n\n\t}\n\n\t// generate result BufferGeometry\n\tconst result = geometry.clone();\n\tfor ( const name in geometry.attributes ) {\n\n\t\tconst tmpAttribute = tmpAttributes[ name ];\n\n\t\tresult.setAttribute( name, new tmpAttribute.constructor(\n\t\t\ttmpAttribute.array.slice( 0, nextIndex * tmpAttribute.itemSize ),\n\t\t\ttmpAttribute.itemSize,\n\t\t\ttmpAttribute.normalized,\n\t\t) );\n\n\t\tif ( ! ( name in tmpMorphAttributes ) ) continue;\n\n\t\tfor ( let j = 0; j < tmpMorphAttributes[ name ].length; j ++ ) {\n\n\t\t\tconst tmpMorphAttribute = tmpMorphAttributes[ name ][ j ];\n\n\t\t\tresult.morphAttributes[ name ][ j ] = new tmpMorphAttribute.constructor(\n\t\t\t\ttmpMorphAttribute.array.slice( 0, nextIndex * tmpMorphAttribute.itemSize ),\n\t\t\t\ttmpMorphAttribute.itemSize,\n\t\t\t\ttmpMorphAttribute.normalized,\n\t\t\t);\n\n\t\t}\n\n\t}\n\n\t// indices\n\n\tresult.setIndex( newIndices );\n\n\treturn result;\n\n}\n\n/**\n * Returns a new indexed geometry based on `TrianglesDrawMode` draw mode.\n * This mode corresponds to the `gl.TRIANGLES` primitive in WebGL.\n *\n * @param {BufferGeometry} geometry - The geometry to convert.\n * @param {number} drawMode - The current draw mode.\n * @return {BufferGeometry} The new geometry using `TrianglesDrawMode`.\n */\nfunction toTrianglesDrawMode( geometry, drawMode ) {\n\n\tif ( drawMode === TrianglesDrawMode ) {\n\n\t\tconsole.warn( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.' );\n\t\treturn geometry;\n\n\t}\n\n\tif ( drawMode === TriangleFanDrawMode || drawMode === TriangleStripDrawMode ) {\n\n\t\tlet index = geometry.getIndex();\n\n\t\t// generate index if not present\n\n\t\tif ( index === null ) {\n\n\t\t\tconst indices = [];\n\n\t\t\tconst position = geometry.getAttribute( 'position' );\n\n\t\t\tif ( position !== undefined ) {\n\n\t\t\t\tfor ( let i = 0; i < position.count; i ++ ) {\n\n\t\t\t\t\tindices.push( i );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.setIndex( indices );\n\t\t\t\tindex = geometry.getIndex();\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.' );\n\t\t\t\treturn geometry;\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tconst numberOfTriangles = index.count - 2;\n\t\tconst newIndices = [];\n\n\t\tif ( drawMode === TriangleFanDrawMode ) {\n\n\t\t\t// gl.TRIANGLE_FAN\n\n\t\t\tfor ( let i = 1; i <= numberOfTriangles; i ++ ) {\n\n\t\t\t\tnewIndices.push( index.getX( 0 ) );\n\t\t\t\tnewIndices.push( index.getX( i ) );\n\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// gl.TRIANGLE_STRIP\n\n\t\t\tfor ( let i = 0; i < numberOfTriangles; i ++ ) {\n\n\t\t\t\tif ( i % 2 === 0 ) {\n\n\t\t\t\t\tnewIndices.push( index.getX( i ) );\n\t\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\t\t\t\t\tnewIndices.push( index.getX( i + 2 ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tnewIndices.push( index.getX( i + 2 ) );\n\t\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\t\t\t\t\tnewIndices.push( index.getX( i ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( ( newIndices.length / 3 ) !== numberOfTriangles ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.' );\n\n\t\t}\n\n\t\t// build final geometry\n\n\t\tconst newGeometry = geometry.clone();\n\t\tnewGeometry.setIndex( newIndices );\n\t\tnewGeometry.clearGroups();\n\n\t\treturn newGeometry;\n\n\t} else {\n\n\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:', drawMode );\n\t\treturn geometry;\n\n\t}\n\n}\n\n/**\n * Calculates the morphed attributes of a morphed/skinned BufferGeometry.\n *\n * Helpful for Raytracing or Decals (i.e. a `DecalGeometry` applied to a morphed Object with a `BufferGeometry`\n * will use the original `BufferGeometry`, not the morphed/skinned one, generating an incorrect result.\n * Using this function to create a shadow `Object3`D the `DecalGeometry` can be correctly generated).\n *\n * @param {Mesh|Line|Points} object - The 3D object to compute morph attributes for.\n * @return {Object} An object with original position/normal attributes and morphed ones.\n */\nfunction computeMorphedAttributes( object ) {\n\n\tconst _vA = new Vector3();\n\tconst _vB = new Vector3();\n\tconst _vC = new Vector3();\n\n\tconst _tempA = new Vector3();\n\tconst _tempB = new Vector3();\n\tconst _tempC = new Vector3();\n\n\tconst _morphA = new Vector3();\n\tconst _morphB = new Vector3();\n\tconst _morphC = new Vector3();\n\n\tfunction _calculateMorphedAttributeData(\n\t\tobject,\n\t\tattribute,\n\t\tmorphAttribute,\n\t\tmorphTargetsRelative,\n\t\ta,\n\t\tb,\n\t\tc,\n\t\tmodifiedAttributeArray\n\t) {\n\n\t\t_vA.fromBufferAttribute( attribute, a );\n\t\t_vB.fromBufferAttribute( attribute, b );\n\t\t_vC.fromBufferAttribute( attribute, c );\n\n\t\tconst morphInfluences = object.morphTargetInfluences;\n\n\t\tif ( morphAttribute && morphInfluences ) {\n\n\t\t\t_morphA.set( 0, 0, 0 );\n\t\t\t_morphB.set( 0, 0, 0 );\n\t\t\t_morphC.set( 0, 0, 0 );\n\n\t\t\tfor ( let i = 0, il = morphAttribute.length; i < il; i ++ ) {\n\n\t\t\t\tconst influence = morphInfluences[ i ];\n\t\t\t\tconst morph = morphAttribute[ i ];\n\n\t\t\t\tif ( influence === 0 ) continue;\n\n\t\t\t\t_tempA.fromBufferAttribute( morph, a );\n\t\t\t\t_tempB.fromBufferAttribute( morph, b );\n\t\t\t\t_tempC.fromBufferAttribute( morph, c );\n\n\t\t\t\tif ( morphTargetsRelative ) {\n\n\t\t\t\t\t_morphA.addScaledVector( _tempA, influence );\n\t\t\t\t\t_morphB.addScaledVector( _tempB, influence );\n\t\t\t\t\t_morphC.addScaledVector( _tempC, influence );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_morphA.addScaledVector( _tempA.sub( _vA ), influence );\n\t\t\t\t\t_morphB.addScaledVector( _tempB.sub( _vB ), influence );\n\t\t\t\t\t_morphC.addScaledVector( _tempC.sub( _vC ), influence );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t_vA.add( _morphA );\n\t\t\t_vB.add( _morphB );\n\t\t\t_vC.add( _morphC );\n\n\t\t}\n\n\t\tif ( object.isSkinnedMesh ) {\n\n\t\t\tobject.applyBoneTransform( a, _vA );\n\t\t\tobject.applyBoneTransform( b, _vB );\n\t\t\tobject.applyBoneTransform( c, _vC );\n\n\t\t}\n\n\t\tmodifiedAttributeArray[ a * 3 + 0 ] = _vA.x;\n\t\tmodifiedAttributeArray[ a * 3 + 1 ] = _vA.y;\n\t\tmodifiedAttributeArray[ a * 3 + 2 ] = _vA.z;\n\t\tmodifiedAttributeArray[ b * 3 + 0 ] = _vB.x;\n\t\tmodifiedAttributeArray[ b * 3 + 1 ] = _vB.y;\n\t\tmodifiedAttributeArray[ b * 3 + 2 ] = _vB.z;\n\t\tmodifiedAttributeArray[ c * 3 + 0 ] = _vC.x;\n\t\tmodifiedAttributeArray[ c * 3 + 1 ] = _vC.y;\n\t\tmodifiedAttributeArray[ c * 3 + 2 ] = _vC.z;\n\n\t}\n\n\tconst geometry = object.geometry;\n\tconst material = object.material;\n\n\tlet a, b, c;\n\tconst index = geometry.index;\n\tconst positionAttribute = geometry.attributes.position;\n\tconst morphPosition = geometry.morphAttributes.position;\n\tconst morphTargetsRelative = geometry.morphTargetsRelative;\n\tconst normalAttribute = geometry.attributes.normal;\n\tconst morphNormal = geometry.morphAttributes.position;\n\n\tconst groups = geometry.groups;\n\tconst drawRange = geometry.drawRange;\n\tlet i, j, il, jl;\n\tlet group;\n\tlet start, end;\n\n\tconst modifiedPosition = new Float32Array( positionAttribute.count * positionAttribute.itemSize );\n\tconst modifiedNormal = new Float32Array( normalAttribute.count * normalAttribute.itemSize );\n\n\tif ( index !== null ) {\n\n\t\t// indexed buffer geometry\n\n\t\tif ( Array.isArray( material ) ) {\n\n\t\t\tfor ( i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\t\tgroup = groups[ i ];\n\n\t\t\t\tstart = Math.max( group.start, drawRange.start );\n\t\t\t\tend = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );\n\n\t\t\t\tfor ( j = start, jl = end; j < jl; j += 3 ) {\n\n\t\t\t\t\ta = index.getX( j );\n\t\t\t\t\tb = index.getX( j + 1 );\n\t\t\t\t\tc = index.getX( j + 2 );\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tpositionAttribute,\n\t\t\t\t\t\tmorphPosition,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedPosition\n\t\t\t\t\t);\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tnormalAttribute,\n\t\t\t\t\t\tmorphNormal,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedNormal\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tstart = Math.max( 0, drawRange.start );\n\t\t\tend = Math.min( index.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\tfor ( i = start, il = end; i < il; i += 3 ) {\n\n\t\t\t\ta = index.getX( i );\n\t\t\t\tb = index.getX( i + 1 );\n\t\t\t\tc = index.getX( i + 2 );\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tpositionAttribute,\n\t\t\t\t\tmorphPosition,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedPosition\n\t\t\t\t);\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tnormalAttribute,\n\t\t\t\t\tmorphNormal,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedNormal\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t} else {\n\n\t\t// non-indexed buffer geometry\n\n\t\tif ( Array.isArray( material ) ) {\n\n\t\t\tfor ( i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\t\tgroup = groups[ i ];\n\n\t\t\t\tstart = Math.max( group.start, drawRange.start );\n\t\t\t\tend = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );\n\n\t\t\t\tfor ( j = start, jl = end; j < jl; j += 3 ) {\n\n\t\t\t\t\ta = j;\n\t\t\t\t\tb = j + 1;\n\t\t\t\t\tc = j + 2;\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tpositionAttribute,\n\t\t\t\t\t\tmorphPosition,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedPosition\n\t\t\t\t\t);\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tnormalAttribute,\n\t\t\t\t\t\tmorphNormal,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedNormal\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tstart = Math.max( 0, drawRange.start );\n\t\t\tend = Math.min( positionAttribute.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\tfor ( i = start, il = end; i < il; i += 3 ) {\n\n\t\t\t\ta = i;\n\t\t\t\tb = i + 1;\n\t\t\t\tc = i + 2;\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tpositionAttribute,\n\t\t\t\t\tmorphPosition,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedPosition\n\t\t\t\t);\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tnormalAttribute,\n\t\t\t\t\tmorphNormal,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedNormal\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tconst morphedPositionAttribute = new Float32BufferAttribute( modifiedPosition, 3 );\n\tconst morphedNormalAttribute = new Float32BufferAttribute( modifiedNormal, 3 );\n\n\treturn {\n\n\t\tpositionAttribute: positionAttribute,\n\t\tnormalAttribute: normalAttribute,\n\t\tmorphedPositionAttribute: morphedPositionAttribute,\n\t\tmorphedNormalAttribute: morphedNormalAttribute\n\n\t};\n\n}\n\n/**\n * Merges the {@link BufferGeometry#groups} for the given geometry.\n *\n * @param {BufferGeometry} geometry - The geometry to modify.\n * @return {BufferGeometry} - The updated geometry\n */\nfunction mergeGroups( geometry ) {\n\n\tif ( geometry.groups.length === 0 ) {\n\n\t\tconsole.warn( 'THREE.BufferGeometryUtils.mergeGroups(): No groups are defined. Nothing to merge.' );\n\t\treturn geometry;\n\n\t}\n\n\tlet groups = geometry.groups;\n\n\t// sort groups by material index\n\n\tgroups = groups.sort( ( a, b ) => {\n\n\t\tif ( a.materialIndex !== b.materialIndex ) return a.materialIndex - b.materialIndex;\n\n\t\treturn a.start - b.start;\n\n\t} );\n\n\t// create index for non-indexed geometries\n\n\tif ( geometry.getIndex() === null ) {\n\n\t\tconst positionAttribute = geometry.getAttribute( 'position' );\n\t\tconst indices = [];\n\n\t\tfor ( let i = 0; i < positionAttribute.count; i += 3 ) {\n\n\t\t\tindices.push( i, i + 1, i + 2 );\n\n\t\t}\n\n\t\tgeometry.setIndex( indices );\n\n\t}\n\n\t// sort index\n\n\tconst index = geometry.getIndex();\n\n\tconst newIndices = [];\n\n\tfor ( let i = 0; i < groups.length; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\n\t\tconst groupStart = group.start;\n\t\tconst groupLength = groupStart + group.count;\n\n\t\tfor ( let j = groupStart; j < groupLength; j ++ ) {\n\n\t\t\tnewIndices.push( index.getX( j ) );\n\n\t\t}\n\n\t}\n\n\tgeometry.dispose(); // Required to force buffer recreation\n\tgeometry.setIndex( newIndices );\n\n\t// update groups indices\n\n\tlet start = 0;\n\n\tfor ( let i = 0; i < groups.length; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\n\t\tgroup.start = start;\n\t\tstart += group.count;\n\n\t}\n\n\t// merge groups\n\n\tlet currentGroup = groups[ 0 ];\n\n\tgeometry.groups = [ currentGroup ];\n\n\tfor ( let i = 1; i < groups.length; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\n\t\tif ( currentGroup.materialIndex === group.materialIndex ) {\n\n\t\t\tcurrentGroup.count += group.count;\n\n\t\t} else {\n\n\t\t\tcurrentGroup = group;\n\t\t\tgeometry.groups.push( currentGroup );\n\n\t\t}\n\n\t}\n\n\treturn geometry;\n\n}\n\n/**\n * Modifies the supplied geometry if it is non-indexed, otherwise creates a new,\n * non-indexed geometry. Returns the geometry with smooth normals everywhere except\n * faces that meet at an angle greater than the crease angle.\n *\n * @param {BufferGeometry} geometry - The geometry to modify.\n * @param {number} [creaseAngle=Math.PI/3] - The crease angle in radians.\n * @return {BufferGeometry} - The updated geometry\n */\nfunction toCreasedNormals( geometry, creaseAngle = Math.PI / 3 /* 60 degrees */ ) {\n\n\tconst creaseDot = Math.cos( creaseAngle );\n\tconst hashMultiplier = ( 1 + 1e-10 ) * 1e2;\n\n\t// reusable vectors\n\tconst verts = [ new Vector3(), new Vector3(), new Vector3() ];\n\tconst tempVec1 = new Vector3();\n\tconst tempVec2 = new Vector3();\n\tconst tempNorm = new Vector3();\n\tconst tempNorm2 = new Vector3();\n\n\t// hashes a vector\n\tfunction hashVertex( v ) {\n\n\t\tconst x = ~ ~ ( v.x * hashMultiplier );\n\t\tconst y = ~ ~ ( v.y * hashMultiplier );\n\t\tconst z = ~ ~ ( v.z * hashMultiplier );\n\t\treturn `${x},${y},${z}`;\n\n\t}\n\n\t// BufferGeometry.toNonIndexed() warns if the geometry is non-indexed\n\t// and returns the original geometry\n\tconst resultGeometry = geometry.index ? geometry.toNonIndexed() : geometry;\n\tconst posAttr = resultGeometry.attributes.position;\n\tconst vertexMap = {};\n\n\t// find all the normals shared by commonly located vertices\n\tfor ( let i = 0, l = posAttr.count / 3; i < l; i ++ ) {\n\n\t\tconst i3 = 3 * i;\n\t\tconst a = verts[ 0 ].fromBufferAttribute( posAttr, i3 + 0 );\n\t\tconst b = verts[ 1 ].fromBufferAttribute( posAttr, i3 + 1 );\n\t\tconst c = verts[ 2 ].fromBufferAttribute( posAttr, i3 + 2 );\n\n\t\ttempVec1.subVectors( c, b );\n\t\ttempVec2.subVectors( a, b );\n\n\t\t// add the normal to the map for all vertices\n\t\tconst normal = new Vector3().crossVectors( tempVec1, tempVec2 ).normalize();\n\t\tfor ( let n = 0; n < 3; n ++ ) {\n\n\t\t\tconst vert = verts[ n ];\n\t\t\tconst hash = hashVertex( vert );\n\t\t\tif ( ! ( hash in vertexMap ) ) {\n\n\t\t\t\tvertexMap[ hash ] = [];\n\n\t\t\t}\n\n\t\t\tvertexMap[ hash ].push( normal );\n\n\t\t}\n\n\t}\n\n\t// average normals from all vertices that share a common location if they are within the\n\t// provided crease threshold\n\tconst normalArray = new Float32Array( posAttr.count * 3 );\n\tconst normAttr = new BufferAttribute( normalArray, 3, false );\n\tfor ( let i = 0, l = posAttr.count / 3; i < l; i ++ ) {\n\n\t\t// get the face normal for this vertex\n\t\tconst i3 = 3 * i;\n\t\tconst a = verts[ 0 ].fromBufferAttribute( posAttr, i3 + 0 );\n\t\tconst b = verts[ 1 ].fromBufferAttribute( posAttr, i3 + 1 );\n\t\tconst c = verts[ 2 ].fromBufferAttribute( posAttr, i3 + 2 );\n\n\t\ttempVec1.subVectors( c, b );\n\t\ttempVec2.subVectors( a, b );\n\n\t\ttempNorm.crossVectors( tempVec1, tempVec2 ).normalize();\n\n\t\t// average all normals that meet the threshold and set the normal value\n\t\tfor ( let n = 0; n < 3; n ++ ) {\n\n\t\t\tconst vert = verts[ n ];\n\t\t\tconst hash = hashVertex( vert );\n\t\t\tconst otherNormals = vertexMap[ hash ];\n\t\t\ttempNorm2.set( 0, 0, 0 );\n\n\t\t\tfor ( let k = 0, lk = otherNormals.length; k < lk; k ++ ) {\n\n\t\t\t\tconst otherNorm = otherNormals[ k ];\n\t\t\t\tif ( tempNorm.dot( otherNorm ) > creaseDot ) {\n\n\t\t\t\t\ttempNorm2.add( otherNorm );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\ttempNorm2.normalize();\n\t\t\tnormAttr.setXYZ( i3 + n, tempNorm2.x, tempNorm2.y, tempNorm2.z );\n\n\t\t}\n\n\t}\n\n\tresultGeometry.setAttribute( 'normal', normAttr );\n\treturn resultGeometry;\n\n}\n\nexport {\n\tcomputeMikkTSpaceTangents,\n\tmergeGeometries,\n\tmergeAttributes,\n\tdeepCloneAttribute,\n\tdeinterleaveAttribute,\n\tdeinterleaveGeometry,\n\tinterleaveAttributes,\n\testimateBytesUsed,\n\tmergeVertices,\n\ttoTrianglesDrawMode,\n\tcomputeMorphedAttributes,\n\tmergeGroups,\n\ttoCreasedNormals\n};\n","import {\n\tAnimationClip,\n\tBone,\n\tBox3,\n\tBufferAttribute,\n\tBufferGeometry,\n\tClampToEdgeWrapping,\n\tColor,\n\tColorManagement,\n\tDirectionalLight,\n\tDoubleSide,\n\tFileLoader,\n\tFrontSide,\n\tGroup,\n\tImageBitmapLoader,\n\tInstancedMesh,\n\tInterleavedBuffer,\n\tInterleavedBufferAttribute,\n\tInterpolant,\n\tInterpolateDiscrete,\n\tInterpolateLinear,\n\tLine,\n\tLineBasicMaterial,\n\tLineLoop,\n\tLineSegments,\n\tLinearFilter,\n\tLinearMipmapLinearFilter,\n\tLinearMipmapNearestFilter,\n\tLinearSRGBColorSpace,\n\tLoader,\n\tLoaderUtils,\n\tMaterial,\n\tMathUtils,\n\tMatrix4,\n\tMesh,\n\tMeshBasicMaterial,\n\tMeshPhysicalMaterial,\n\tMeshStandardMaterial,\n\tMirroredRepeatWrapping,\n\tNearestFilter,\n\tNearestMipmapLinearFilter,\n\tNearestMipmapNearestFilter,\n\tNumberKeyframeTrack,\n\tObject3D,\n\tOrthographicCamera,\n\tPerspectiveCamera,\n\tPointLight,\n\tPoints,\n\tPointsMaterial,\n\tPropertyBinding,\n\tQuaternion,\n\tQuaternionKeyframeTrack,\n\tRepeatWrapping,\n\tSkeleton,\n\tSkinnedMesh,\n\tSphere,\n\tSpotLight,\n\tTexture,\n\tTextureLoader,\n\tTriangleFanDrawMode,\n\tTriangleStripDrawMode,\n\tVector2,\n\tVector3,\n\tVectorKeyframeTrack,\n\tSRGBColorSpace,\n\tInstancedBufferAttribute\n} from 'three';\nimport { toTrianglesDrawMode } from '../utils/BufferGeometryUtils.js';\n\n/**\n * A loader for the glTF 2.0 format.\n *\n * [glTF](https://www.khronos.org/gltf/} (GL Transmission Format) is an [open format specification]{@link https://github.com/KhronosGroup/glTF/tree/main/specification/2.0)\n * for efficient delivery and loading of 3D content. Assets may be provided either in JSON (.gltf) or binary (.glb)\n * format. External files store textures (.jpg, .png) and additional binary data (.bin). A glTF asset may deliver\n * one or more scenes, including meshes, materials, textures, skins, skeletons, morph targets, animations, lights,\n * and/or cameras.\n *\n * `GLTFLoader` uses {@link ImageBitmapLoader} whenever possible. Be advised that image bitmaps are not\n * automatically GC-collected when they are no longer referenced, and they require special handling during\n * the disposal process.\n *\n * `GLTFLoader` supports the following glTF 2.0 extensions:\n * - KHR_draco_mesh_compression\n * - KHR_materials_clearcoat\n * - KHR_materials_dispersion\n * - KHR_materials_ior\n * - KHR_materials_specular\n * - KHR_materials_transmission\n * - KHR_materials_iridescence\n * - KHR_materials_unlit\n * - KHR_materials_volume\n * - KHR_mesh_quantization\n * - KHR_lights_punctual\n * - KHR_texture_basisu\n * - KHR_texture_transform\n * - EXT_texture_webp\n * - EXT_meshopt_compression\n * - EXT_mesh_gpu_instancing\n *\n * The following glTF 2.0 extension is supported by an external user plugin:\n * - [KHR_materials_variants](https://github.com/takahirox/three-gltf-extensions)\n * - [MSFT_texture_dds](https://github.com/takahirox/three-gltf-extensions)\n * - [KHR_animation_pointer](https://github.com/needle-tools/three-animation-pointer)\n * - [NEEDLE_progressive](https://github.com/needle-tools/gltf-progressive)\n *\n * ```js\n * const loader = new GLTFLoader();\n *\n * // Optional: Provide a DRACOLoader instance to decode compressed mesh data\n * const dracoLoader = new DRACOLoader();\n * dracoLoader.setDecoderPath( '/examples/jsm/libs/draco/' );\n * loader.setDRACOLoader( dracoLoader );\n *\n * const gltf = await loader.loadAsync( 'models/gltf/duck/duck.gltf' );\n * scene.add( gltf.scene );\n * ```\n *\n * @augments Loader\n * @three_import import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n */\nclass GLTFLoader extends Loader {\n\n\t/**\n\t * Constructs a new glTF loader.\n\t *\n\t * @param {LoadingManager} [manager] - The loading manager.\n\t */\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t\tthis.dracoLoader = null;\n\t\tthis.ktx2Loader = null;\n\t\tthis.meshoptDecoder = null;\n\n\t\tthis.pluginCallbacks = [];\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMaterialsClearcoatExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMaterialsDispersionExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFTextureBasisUExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFTextureWebPExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFTextureAVIFExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMaterialsSheenExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMaterialsTransmissionExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMaterialsVolumeExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMaterialsIorExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMaterialsEmissiveStrengthExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMaterialsSpecularExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMaterialsIridescenceExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMaterialsAnisotropyExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMaterialsBumpExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFLightsExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMeshoptCompression( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMeshGpuInstancing( parser );\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Starts loading from the given URL and passes the loaded glTF asset\n\t * to the `onLoad()` callback.\n\t *\n\t * @param {string} url - The path/URL of the file to be loaded. This can also be a data URI.\n\t * @param {function(GLTFLoader~LoadObject)} onLoad - Executed when the loading process has been finished.\n\t * @param {onProgressCallback} onProgress - Executed while the loading is in progress.\n\t * @param {onErrorCallback} onError - Executed when errors occur.\n\t */\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tlet resourcePath;\n\n\t\tif ( this.resourcePath !== '' ) {\n\n\t\t\tresourcePath = this.resourcePath;\n\n\t\t} else if ( this.path !== '' ) {\n\n\t\t\t// If a base path is set, resources will be relative paths from that plus the relative path of the gltf file\n\t\t\t// Example  path = 'https://my-cnd-server.com/', url = 'assets/models/model.gltf'\n\t\t\t// resourcePath = 'https://my-cnd-server.com/assets/models/'\n\t\t\t// referenced resource 'model.bin' will be loaded from 'https://my-cnd-server.com/assets/models/model.bin'\n\t\t\t// referenced resource '../textures/texture.png' will be loaded from 'https://my-cnd-server.com/assets/textures/texture.png'\n\t\t\tconst relativeUrl = LoaderUtils.extractUrlBase( url );\n\t\t\tresourcePath = LoaderUtils.resolveURL( relativeUrl, this.path );\n\n\t\t} else {\n\n\t\t\tresourcePath = LoaderUtils.extractUrlBase( url );\n\n\t\t}\n\n\t\t// Tells the LoadingManager to track an extra item, which resolves after\n\t\t// the model is fully loaded. This means the count of items loaded will\n\t\t// be incorrect, but ensures manager.onLoad() does not fire early.\n\t\tthis.manager.itemStart( url );\n\n\t\tconst _onError = function ( e ) {\n\n\t\t\tif ( onError ) {\n\n\t\t\t\tonError( e );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( e );\n\n\t\t\t}\n\n\t\t\tscope.manager.itemError( url );\n\t\t\tscope.manager.itemEnd( url );\n\n\t\t};\n\n\t\tconst loader = new FileLoader( this.manager );\n\n\t\tloader.setPath( this.path );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setWithCredentials( this.withCredentials );\n\n\t\tloader.load( url, function ( data ) {\n\n\t\t\ttry {\n\n\t\t\t\tscope.parse( data, resourcePath, function ( gltf ) {\n\n\t\t\t\t\tonLoad( gltf );\n\n\t\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t\t}, _onError );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\t_onError( e );\n\n\t\t\t}\n\n\t\t}, onProgress, _onError );\n\n\t}\n\n\t/**\n\t * Sets the given Draco loader to this loader. Required for decoding assets\n\t * compressed with the `KHR_draco_mesh_compression` extension.\n\t *\n\t * @param {DRACOLoader} dracoLoader - The Draco loader to set.\n\t * @return {GLTFLoader} A reference to this loader.\n\t */\n\tsetDRACOLoader( dracoLoader ) {\n\n\t\tthis.dracoLoader = dracoLoader;\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets the given KTX2 loader to this loader. Required for loading KTX2\n\t * compressed textures.\n\t *\n\t * @param {KTX2Loader} ktx2Loader - The KTX2 loader to set.\n\t * @return {GLTFLoader} A reference to this loader.\n\t */\n\tsetKTX2Loader( ktx2Loader ) {\n\n\t\tthis.ktx2Loader = ktx2Loader;\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets the given meshopt decoder. Required for decoding assets\n\t * compressed with the `EXT_meshopt_compression` extension.\n\t *\n\t * @param {Object} meshoptDecoder - The meshopt decoder to set.\n\t * @return {GLTFLoader} A reference to this loader.\n\t */\n\tsetMeshoptDecoder( meshoptDecoder ) {\n\n\t\tthis.meshoptDecoder = meshoptDecoder;\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Registers a plugin callback. This API is internally used to implement the various\n\t * glTF extensions but can also used by third-party code to add additional logic\n\t * to the loader.\n\t *\n\t * @param {function(parser:GLTFParser)} callback - The callback function to register.\n\t * @return {GLTFLoader} A reference to this loader.\n\t */\n\tregister( callback ) {\n\n\t\tif ( this.pluginCallbacks.indexOf( callback ) === - 1 ) {\n\n\t\t\tthis.pluginCallbacks.push( callback );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Unregisters a plugin callback.\n\t *\n\t * @param {Function} callback - The callback function to unregister.\n\t * @return {GLTFLoader} A reference to this loader.\n\t */\n\tunregister( callback ) {\n\n\t\tif ( this.pluginCallbacks.indexOf( callback ) !== - 1 ) {\n\n\t\t\tthis.pluginCallbacks.splice( this.pluginCallbacks.indexOf( callback ), 1 );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Parses the given FBX data and returns the resulting group.\n\t *\n\t * @param {string|ArrayBuffer} data - The raw glTF data.\n\t * @param {string} path - The URL base path.\n\t * @param {function(GLTFLoader~LoadObject)} onLoad - Executed when the loading process has been finished.\n\t * @param {onErrorCallback} onError - Executed when errors occur.\n\t */\n\tparse( data, path, onLoad, onError ) {\n\n\t\tlet json;\n\t\tconst extensions = {};\n\t\tconst plugins = {};\n\t\tconst textDecoder = new TextDecoder();\n\n\t\tif ( typeof data === 'string' ) {\n\n\t\t\tjson = JSON.parse( data );\n\n\t\t} else if ( data instanceof ArrayBuffer ) {\n\n\t\t\tconst magic = textDecoder.decode( new Uint8Array( data, 0, 4 ) );\n\n\t\t\tif ( magic === BINARY_EXTENSION_HEADER_MAGIC ) {\n\n\t\t\t\ttry {\n\n\t\t\t\t\textensions[ EXTENSIONS.KHR_BINARY_GLTF ] = new GLTFBinaryExtension( data );\n\n\t\t\t\t} catch ( error ) {\n\n\t\t\t\t\tif ( onError ) onError( error );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tjson = JSON.parse( extensions[ EXTENSIONS.KHR_BINARY_GLTF ].content );\n\n\t\t\t} else {\n\n\t\t\t\tjson = JSON.parse( textDecoder.decode( data ) );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tjson = data;\n\n\t\t}\n\n\t\tif ( json.asset === undefined || json.asset.version[ 0 ] < 2 ) {\n\n\t\t\tif ( onError ) onError( new Error( 'THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.' ) );\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst parser = new GLTFParser( json, {\n\n\t\t\tpath: path || this.resourcePath || '',\n\t\t\tcrossOrigin: this.crossOrigin,\n\t\t\trequestHeader: this.requestHeader,\n\t\t\tmanager: this.manager,\n\t\t\tktx2Loader: this.ktx2Loader,\n\t\t\tmeshoptDecoder: this.meshoptDecoder\n\n\t\t} );\n\n\t\tparser.fileLoader.setRequestHeader( this.requestHeader );\n\n\t\tfor ( let i = 0; i < this.pluginCallbacks.length; i ++ ) {\n\n\t\t\tconst plugin = this.pluginCallbacks[ i ]( parser );\n\n\t\t\tif ( ! plugin.name ) console.error( 'THREE.GLTFLoader: Invalid plugin found: missing name' );\n\n\t\t\tplugins[ plugin.name ] = plugin;\n\n\t\t\t// Workaround to avoid determining as unknown extension\n\t\t\t// in addUnknownExtensionsToUserData().\n\t\t\t// Remove this workaround if we move all the existing\n\t\t\t// extension handlers to plugin system\n\t\t\textensions[ plugin.name ] = true;\n\n\t\t}\n\n\t\tif ( json.extensionsUsed ) {\n\n\t\t\tfor ( let i = 0; i < json.extensionsUsed.length; ++ i ) {\n\n\t\t\t\tconst extensionName = json.extensionsUsed[ i ];\n\t\t\t\tconst extensionsRequired = json.extensionsRequired || [];\n\n\t\t\t\tswitch ( extensionName ) {\n\n\t\t\t\t\tcase EXTENSIONS.KHR_MATERIALS_UNLIT:\n\t\t\t\t\t\textensions[ extensionName ] = new GLTFMaterialsUnlitExtension();\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:\n\t\t\t\t\t\textensions[ extensionName ] = new GLTFDracoMeshCompressionExtension( json, this.dracoLoader );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase EXTENSIONS.KHR_TEXTURE_TRANSFORM:\n\t\t\t\t\t\textensions[ extensionName ] = new GLTFTextureTransformExtension();\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase EXTENSIONS.KHR_MESH_QUANTIZATION:\n\t\t\t\t\t\textensions[ extensionName ] = new GLTFMeshQuantizationExtension();\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\n\t\t\t\t\t\tif ( extensionsRequired.indexOf( extensionName ) >= 0 && plugins[ extensionName ] === undefined ) {\n\n\t\t\t\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Unknown extension \"' + extensionName + '\".' );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tparser.setExtensions( extensions );\n\t\tparser.setPlugins( plugins );\n\t\tparser.parse( onLoad, onError );\n\n\t}\n\n\t/**\n\t * Async version of {@link GLTFLoader#parse}.\n\t *\n\t * @async\n\t * @param {string|ArrayBuffer} data - The raw glTF data.\n\t * @param {string} path - The URL base path.\n\t * @return {Promise<GLTFLoader~LoadObject>} A Promise that resolves with the loaded glTF when the parsing has been finished.\n\t */\n\tparseAsync( data, path ) {\n\n\t\tconst scope = this;\n\n\t\treturn new Promise( function ( resolve, reject ) {\n\n\t\t\tscope.parse( data, path, resolve, reject );\n\n\t\t} );\n\n\t}\n\n}\n\n/* GLTFREGISTRY */\n\nfunction GLTFRegistry() {\n\n\tlet objects = {};\n\n\treturn\t{\n\n\t\tget: function ( key ) {\n\n\t\t\treturn objects[ key ];\n\n\t\t},\n\n\t\tadd: function ( key, object ) {\n\n\t\t\tobjects[ key ] = object;\n\n\t\t},\n\n\t\tremove: function ( key ) {\n\n\t\t\tdelete objects[ key ];\n\n\t\t},\n\n\t\tremoveAll: function () {\n\n\t\t\tobjects = {};\n\n\t\t}\n\n\t};\n\n}\n\n/*********************************/\n/********** EXTENSIONS ***********/\n/*********************************/\n\nconst EXTENSIONS = {\n\tKHR_BINARY_GLTF: 'KHR_binary_glTF',\n\tKHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',\n\tKHR_LIGHTS_PUNCTUAL: 'KHR_lights_punctual',\n\tKHR_MATERIALS_CLEARCOAT: 'KHR_materials_clearcoat',\n\tKHR_MATERIALS_DISPERSION: 'KHR_materials_dispersion',\n\tKHR_MATERIALS_IOR: 'KHR_materials_ior',\n\tKHR_MATERIALS_SHEEN: 'KHR_materials_sheen',\n\tKHR_MATERIALS_SPECULAR: 'KHR_materials_specular',\n\tKHR_MATERIALS_TRANSMISSION: 'KHR_materials_transmission',\n\tKHR_MATERIALS_IRIDESCENCE: 'KHR_materials_iridescence',\n\tKHR_MATERIALS_ANISOTROPY: 'KHR_materials_anisotropy',\n\tKHR_MATERIALS_UNLIT: 'KHR_materials_unlit',\n\tKHR_MATERIALS_VOLUME: 'KHR_materials_volume',\n\tKHR_TEXTURE_BASISU: 'KHR_texture_basisu',\n\tKHR_TEXTURE_TRANSFORM: 'KHR_texture_transform',\n\tKHR_MESH_QUANTIZATION: 'KHR_mesh_quantization',\n\tKHR_MATERIALS_EMISSIVE_STRENGTH: 'KHR_materials_emissive_strength',\n\tEXT_MATERIALS_BUMP: 'EXT_materials_bump',\n\tEXT_TEXTURE_WEBP: 'EXT_texture_webp',\n\tEXT_TEXTURE_AVIF: 'EXT_texture_avif',\n\tEXT_MESHOPT_COMPRESSION: 'EXT_meshopt_compression',\n\tEXT_MESH_GPU_INSTANCING: 'EXT_mesh_gpu_instancing'\n};\n\n/**\n * Punctual Lights Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual\n *\n * @private\n */\nclass GLTFLightsExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;\n\n\t\t// Object3D instance caches\n\t\tthis.cache = { refs: {}, uses: {} };\n\n\t}\n\n\t_markDefs() {\n\n\t\tconst parser = this.parser;\n\t\tconst nodeDefs = this.parser.json.nodes || [];\n\n\t\tfor ( let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex ++ ) {\n\n\t\t\tconst nodeDef = nodeDefs[ nodeIndex ];\n\n\t\t\tif ( nodeDef.extensions\n\t\t\t\t\t&& nodeDef.extensions[ this.name ]\n\t\t\t\t\t&& nodeDef.extensions[ this.name ].light !== undefined ) {\n\n\t\t\t\tparser._addNodeRef( this.cache, nodeDef.extensions[ this.name ].light );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t_loadLight( lightIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst cacheKey = 'light:' + lightIndex;\n\t\tlet dependency = parser.cache.get( cacheKey );\n\n\t\tif ( dependency ) return dependency;\n\n\t\tconst json = parser.json;\n\t\tconst extensions = ( json.extensions && json.extensions[ this.name ] ) || {};\n\t\tconst lightDefs = extensions.lights || [];\n\t\tconst lightDef = lightDefs[ lightIndex ];\n\t\tlet lightNode;\n\n\t\tconst color = new Color( 0xffffff );\n\n\t\tif ( lightDef.color !== undefined ) color.setRGB( lightDef.color[ 0 ], lightDef.color[ 1 ], lightDef.color[ 2 ], LinearSRGBColorSpace );\n\n\t\tconst range = lightDef.range !== undefined ? lightDef.range : 0;\n\n\t\tswitch ( lightDef.type ) {\n\n\t\t\tcase 'directional':\n\t\t\t\tlightNode = new DirectionalLight( color );\n\t\t\t\tlightNode.target.position.set( 0, 0, - 1 );\n\t\t\t\tlightNode.add( lightNode.target );\n\t\t\t\tbreak;\n\n\t\t\tcase 'point':\n\t\t\t\tlightNode = new PointLight( color );\n\t\t\t\tlightNode.distance = range;\n\t\t\t\tbreak;\n\n\t\t\tcase 'spot':\n\t\t\t\tlightNode = new SpotLight( color );\n\t\t\t\tlightNode.distance = range;\n\t\t\t\t// Handle spotlight properties.\n\t\t\t\tlightDef.spot = lightDef.spot || {};\n\t\t\t\tlightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== undefined ? lightDef.spot.innerConeAngle : 0;\n\t\t\t\tlightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== undefined ? lightDef.spot.outerConeAngle : Math.PI / 4.0;\n\t\t\t\tlightNode.angle = lightDef.spot.outerConeAngle;\n\t\t\t\tlightNode.penumbra = 1.0 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;\n\t\t\t\tlightNode.target.position.set( 0, 0, - 1 );\n\t\t\t\tlightNode.add( lightNode.target );\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tthrow new Error( 'THREE.GLTFLoader: Unexpected light type: ' + lightDef.type );\n\n\t\t}\n\n\t\t// Some lights (e.g. spot) default to a position other than the origin. Reset the position\n\t\t// here, because node-level parsing will only override position if explicitly specified.\n\t\tlightNode.position.set( 0, 0, 0 );\n\n\t\tassignExtrasToUserData( lightNode, lightDef );\n\n\t\tif ( lightDef.intensity !== undefined ) lightNode.intensity = lightDef.intensity;\n\n\t\tlightNode.name = parser.createUniqueName( lightDef.name || ( 'light_' + lightIndex ) );\n\n\t\tdependency = Promise.resolve( lightNode );\n\n\t\tparser.cache.add( cacheKey, dependency );\n\n\t\treturn dependency;\n\n\t}\n\n\tgetDependency( type, index ) {\n\n\t\tif ( type !== 'light' ) return;\n\n\t\treturn this._loadLight( index );\n\n\t}\n\n\tcreateNodeAttachment( nodeIndex ) {\n\n\t\tconst self = this;\n\t\tconst parser = this.parser;\n\t\tconst json = parser.json;\n\t\tconst nodeDef = json.nodes[ nodeIndex ];\n\t\tconst lightDef = ( nodeDef.extensions && nodeDef.extensions[ this.name ] ) || {};\n\t\tconst lightIndex = lightDef.light;\n\n\t\tif ( lightIndex === undefined ) return null;\n\n\t\treturn this._loadLight( lightIndex ).then( function ( light ) {\n\n\t\t\treturn parser._getNodeRef( self.cache, lightIndex, light );\n\n\t\t} );\n\n\t}\n\n}\n\n/**\n * Unlit Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit\n *\n * @private\n */\nclass GLTFMaterialsUnlitExtension {\n\n\tconstructor() {\n\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_UNLIT;\n\n\t}\n\n\tgetMaterialType() {\n\n\t\treturn MeshBasicMaterial;\n\n\t}\n\n\textendParams( materialParams, materialDef, parser ) {\n\n\t\tconst pending = [];\n\n\t\tmaterialParams.color = new Color( 1.0, 1.0, 1.0 );\n\t\tmaterialParams.opacity = 1.0;\n\n\t\tconst metallicRoughness = materialDef.pbrMetallicRoughness;\n\n\t\tif ( metallicRoughness ) {\n\n\t\t\tif ( Array.isArray( metallicRoughness.baseColorFactor ) ) {\n\n\t\t\t\tconst array = metallicRoughness.baseColorFactor;\n\n\t\t\t\tmaterialParams.color.setRGB( array[ 0 ], array[ 1 ], array[ 2 ], LinearSRGBColorSpace );\n\t\t\t\tmaterialParams.opacity = array[ 3 ];\n\n\t\t\t}\n\n\t\t\tif ( metallicRoughness.baseColorTexture !== undefined ) {\n\n\t\t\t\tpending.push( parser.assignTexture( materialParams, 'map', metallicRoughness.baseColorTexture, SRGBColorSpace ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t}\n\n}\n\n/**\n * Materials Emissive Strength Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/blob/5768b3ce0ef32bc39cdf1bef10b948586635ead3/extensions/2.0/Khronos/KHR_materials_emissive_strength/README.md\n *\n * @private\n */\nclass GLTFMaterialsEmissiveStrengthExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_EMISSIVE_STRENGTH;\n\n\t}\n\n\textendMaterialParams( materialIndex, materialParams ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\n\n\t\t\treturn Promise.resolve();\n\n\t\t}\n\n\t\tconst emissiveStrength = materialDef.extensions[ this.name ].emissiveStrength;\n\n\t\tif ( emissiveStrength !== undefined ) {\n\n\t\t\tmaterialParams.emissiveIntensity = emissiveStrength;\n\n\t\t}\n\n\t\treturn Promise.resolve();\n\n\t}\n\n}\n\n/**\n * Clearcoat Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat\n *\n * @private\n */\nclass GLTFMaterialsClearcoatExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;\n\n\t}\n\n\tgetMaterialType( materialIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\n\n\t\treturn MeshPhysicalMaterial;\n\n\t}\n\n\textendMaterialParams( materialIndex, materialParams ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\n\n\t\t\treturn Promise.resolve();\n\n\t\t}\n\n\t\tconst pending = [];\n\n\t\tconst extension = materialDef.extensions[ this.name ];\n\n\t\tif ( extension.clearcoatFactor !== undefined ) {\n\n\t\t\tmaterialParams.clearcoat = extension.clearcoatFactor;\n\n\t\t}\n\n\t\tif ( extension.clearcoatTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'clearcoatMap', extension.clearcoatTexture ) );\n\n\t\t}\n\n\t\tif ( extension.clearcoatRoughnessFactor !== undefined ) {\n\n\t\t\tmaterialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;\n\n\t\t}\n\n\t\tif ( extension.clearcoatRoughnessTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'clearcoatRoughnessMap', extension.clearcoatRoughnessTexture ) );\n\n\t\t}\n\n\t\tif ( extension.clearcoatNormalTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'clearcoatNormalMap', extension.clearcoatNormalTexture ) );\n\n\t\t\tif ( extension.clearcoatNormalTexture.scale !== undefined ) {\n\n\t\t\t\tconst scale = extension.clearcoatNormalTexture.scale;\n\n\t\t\t\tmaterialParams.clearcoatNormalScale = new Vector2( scale, scale );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t}\n\n}\n\n/**\n * Materials dispersion Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_dispersion\n *\n * @private\n */\nclass GLTFMaterialsDispersionExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_DISPERSION;\n\n\t}\n\n\tgetMaterialType( materialIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\n\n\t\treturn MeshPhysicalMaterial;\n\n\t}\n\n\textendMaterialParams( materialIndex, materialParams ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\n\n\t\t\treturn Promise.resolve();\n\n\t\t}\n\n\t\tconst extension = materialDef.extensions[ this.name ];\n\n\t\tmaterialParams.dispersion = extension.dispersion !== undefined ? extension.dispersion : 0;\n\n\t\treturn Promise.resolve();\n\n\t}\n\n}\n\n/**\n * Iridescence Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_iridescence\n *\n * @private\n */\nclass GLTFMaterialsIridescenceExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_IRIDESCENCE;\n\n\t}\n\n\tgetMaterialType( materialIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\n\n\t\treturn MeshPhysicalMaterial;\n\n\t}\n\n\textendMaterialParams( materialIndex, materialParams ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\n\n\t\t\treturn Promise.resolve();\n\n\t\t}\n\n\t\tconst pending = [];\n\n\t\tconst extension = materialDef.extensions[ this.name ];\n\n\t\tif ( extension.iridescenceFactor !== undefined ) {\n\n\t\t\tmaterialParams.iridescence = extension.iridescenceFactor;\n\n\t\t}\n\n\t\tif ( extension.iridescenceTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'iridescenceMap', extension.iridescenceTexture ) );\n\n\t\t}\n\n\t\tif ( extension.iridescenceIor !== undefined ) {\n\n\t\t\tmaterialParams.iridescenceIOR = extension.iridescenceIor;\n\n\t\t}\n\n\t\tif ( materialParams.iridescenceThicknessRange === undefined ) {\n\n\t\t\tmaterialParams.iridescenceThicknessRange = [ 100, 400 ];\n\n\t\t}\n\n\t\tif ( extension.iridescenceThicknessMinimum !== undefined ) {\n\n\t\t\tmaterialParams.iridescenceThicknessRange[ 0 ] = extension.iridescenceThicknessMinimum;\n\n\t\t}\n\n\t\tif ( extension.iridescenceThicknessMaximum !== undefined ) {\n\n\t\t\tmaterialParams.iridescenceThicknessRange[ 1 ] = extension.iridescenceThicknessMaximum;\n\n\t\t}\n\n\t\tif ( extension.iridescenceThicknessTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'iridescenceThicknessMap', extension.iridescenceThicknessTexture ) );\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t}\n\n}\n\n/**\n * Sheen Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_sheen\n *\n * @private\n */\nclass GLTFMaterialsSheenExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_SHEEN;\n\n\t}\n\n\tgetMaterialType( materialIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\n\n\t\treturn MeshPhysicalMaterial;\n\n\t}\n\n\textendMaterialParams( materialIndex, materialParams ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\n\n\t\t\treturn Promise.resolve();\n\n\t\t}\n\n\t\tconst pending = [];\n\n\t\tmaterialParams.sheenColor = new Color( 0, 0, 0 );\n\t\tmaterialParams.sheenRoughness = 0;\n\t\tmaterialParams.sheen = 1;\n\n\t\tconst extension = materialDef.extensions[ this.name ];\n\n\t\tif ( extension.sheenColorFactor !== undefined ) {\n\n\t\t\tconst colorFactor = extension.sheenColorFactor;\n\t\t\tmaterialParams.sheenColor.setRGB( colorFactor[ 0 ], colorFactor[ 1 ], colorFactor[ 2 ], LinearSRGBColorSpace );\n\n\t\t}\n\n\t\tif ( extension.sheenRoughnessFactor !== undefined ) {\n\n\t\t\tmaterialParams.sheenRoughness = extension.sheenRoughnessFactor;\n\n\t\t}\n\n\t\tif ( extension.sheenColorTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'sheenColorMap', extension.sheenColorTexture, SRGBColorSpace ) );\n\n\t\t}\n\n\t\tif ( extension.sheenRoughnessTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'sheenRoughnessMap', extension.sheenRoughnessTexture ) );\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t}\n\n}\n\n/**\n * Transmission Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission\n * Draft: https://github.com/KhronosGroup/glTF/pull/1698\n *\n * @private\n */\nclass GLTFMaterialsTransmissionExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION;\n\n\t}\n\n\tgetMaterialType( materialIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\n\n\t\treturn MeshPhysicalMaterial;\n\n\t}\n\n\textendMaterialParams( materialIndex, materialParams ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\n\n\t\t\treturn Promise.resolve();\n\n\t\t}\n\n\t\tconst pending = [];\n\n\t\tconst extension = materialDef.extensions[ this.name ];\n\n\t\tif ( extension.transmissionFactor !== undefined ) {\n\n\t\t\tmaterialParams.transmission = extension.transmissionFactor;\n\n\t\t}\n\n\t\tif ( extension.transmissionTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'transmissionMap', extension.transmissionTexture ) );\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t}\n\n}\n\n/**\n * Materials Volume Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_volume\n *\n * @private\n */\nclass GLTFMaterialsVolumeExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_VOLUME;\n\n\t}\n\n\tgetMaterialType( materialIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\n\n\t\treturn MeshPhysicalMaterial;\n\n\t}\n\n\textendMaterialParams( materialIndex, materialParams ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\n\n\t\t\treturn Promise.resolve();\n\n\t\t}\n\n\t\tconst pending = [];\n\n\t\tconst extension = materialDef.extensions[ this.name ];\n\n\t\tmaterialParams.thickness = extension.thicknessFactor !== undefined ? extension.thicknessFactor : 0;\n\n\t\tif ( extension.thicknessTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'thicknessMap', extension.thicknessTexture ) );\n\n\t\t}\n\n\t\tmaterialParams.attenuationDistance = extension.attenuationDistance || Infinity;\n\n\t\tconst colorArray = extension.attenuationColor || [ 1, 1, 1 ];\n\t\tmaterialParams.attenuationColor = new Color().setRGB( colorArray[ 0 ], colorArray[ 1 ], colorArray[ 2 ], LinearSRGBColorSpace );\n\n\t\treturn Promise.all( pending );\n\n\t}\n\n}\n\n/**\n * Materials ior Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_ior\n *\n * @private\n */\nclass GLTFMaterialsIorExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_IOR;\n\n\t}\n\n\tgetMaterialType( materialIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\n\n\t\treturn MeshPhysicalMaterial;\n\n\t}\n\n\textendMaterialParams( materialIndex, materialParams ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\n\n\t\t\treturn Promise.resolve();\n\n\t\t}\n\n\t\tconst extension = materialDef.extensions[ this.name ];\n\n\t\tmaterialParams.ior = extension.ior !== undefined ? extension.ior : 1.5;\n\n\t\treturn Promise.resolve();\n\n\t}\n\n}\n\n/**\n * Materials specular Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_specular\n *\n * @private\n */\nclass GLTFMaterialsSpecularExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_SPECULAR;\n\n\t}\n\n\tgetMaterialType( materialIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\n\n\t\treturn MeshPhysicalMaterial;\n\n\t}\n\n\textendMaterialParams( materialIndex, materialParams ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\n\n\t\t\treturn Promise.resolve();\n\n\t\t}\n\n\t\tconst pending = [];\n\n\t\tconst extension = materialDef.extensions[ this.name ];\n\n\t\tmaterialParams.specularIntensity = extension.specularFactor !== undefined ? extension.specularFactor : 1.0;\n\n\t\tif ( extension.specularTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'specularIntensityMap', extension.specularTexture ) );\n\n\t\t}\n\n\t\tconst colorArray = extension.specularColorFactor || [ 1, 1, 1 ];\n\t\tmaterialParams.specularColor = new Color().setRGB( colorArray[ 0 ], colorArray[ 1 ], colorArray[ 2 ], LinearSRGBColorSpace );\n\n\t\tif ( extension.specularColorTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'specularColorMap', extension.specularColorTexture, SRGBColorSpace ) );\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t}\n\n}\n\n\n/**\n * Materials bump Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/EXT_materials_bump\n *\n * @private\n */\nclass GLTFMaterialsBumpExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.EXT_MATERIALS_BUMP;\n\n\t}\n\n\tgetMaterialType( materialIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\n\n\t\treturn MeshPhysicalMaterial;\n\n\t}\n\n\textendMaterialParams( materialIndex, materialParams ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\n\n\t\t\treturn Promise.resolve();\n\n\t\t}\n\n\t\tconst pending = [];\n\n\t\tconst extension = materialDef.extensions[ this.name ];\n\n\t\tmaterialParams.bumpScale = extension.bumpFactor !== undefined ? extension.bumpFactor : 1.0;\n\n\t\tif ( extension.bumpTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'bumpMap', extension.bumpTexture ) );\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t}\n\n}\n\n/**\n * Materials anisotropy Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_anisotropy\n *\n * @private\n */\nclass GLTFMaterialsAnisotropyExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_ANISOTROPY;\n\n\t}\n\n\tgetMaterialType( materialIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\n\n\t\treturn MeshPhysicalMaterial;\n\n\t}\n\n\textendMaterialParams( materialIndex, materialParams ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\n\n\t\t\treturn Promise.resolve();\n\n\t\t}\n\n\t\tconst pending = [];\n\n\t\tconst extension = materialDef.extensions[ this.name ];\n\n\t\tif ( extension.anisotropyStrength !== undefined ) {\n\n\t\t\tmaterialParams.anisotropy = extension.anisotropyStrength;\n\n\t\t}\n\n\t\tif ( extension.anisotropyRotation !== undefined ) {\n\n\t\t\tmaterialParams.anisotropyRotation = extension.anisotropyRotation;\n\n\t\t}\n\n\t\tif ( extension.anisotropyTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'anisotropyMap', extension.anisotropyTexture ) );\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t}\n\n}\n\n/**\n * BasisU Texture Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_basisu\n *\n * @private\n */\nclass GLTFTextureBasisUExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_TEXTURE_BASISU;\n\n\t}\n\n\tloadTexture( textureIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst json = parser.json;\n\n\t\tconst textureDef = json.textures[ textureIndex ];\n\n\t\tif ( ! textureDef.extensions || ! textureDef.extensions[ this.name ] ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst extension = textureDef.extensions[ this.name ];\n\t\tconst loader = parser.options.ktx2Loader;\n\n\t\tif ( ! loader ) {\n\n\t\t\tif ( json.extensionsRequired && json.extensionsRequired.indexOf( this.name ) >= 0 ) {\n\n\t\t\t\tthrow new Error( 'THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures' );\n\n\t\t\t} else {\n\n\t\t\t\t// Assumes that the extension is optional and that a fallback texture is present\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn parser.loadTextureImage( textureIndex, extension.source, loader );\n\n\t}\n\n}\n\n/**\n * WebP Texture Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_webp\n *\n * @private\n */\nclass GLTFTextureWebPExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.EXT_TEXTURE_WEBP;\n\n\t}\n\n\tloadTexture( textureIndex ) {\n\n\t\tconst name = this.name;\n\t\tconst parser = this.parser;\n\t\tconst json = parser.json;\n\n\t\tconst textureDef = json.textures[ textureIndex ];\n\n\t\tif ( ! textureDef.extensions || ! textureDef.extensions[ name ] ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst extension = textureDef.extensions[ name ];\n\t\tconst source = json.images[ extension.source ];\n\n\t\tlet loader = parser.textureLoader;\n\t\tif ( source.uri ) {\n\n\t\t\tconst handler = parser.options.manager.getHandler( source.uri );\n\t\t\tif ( handler !== null ) loader = handler;\n\n\t\t}\n\n\t\treturn parser.loadTextureImage( textureIndex, extension.source, loader );\n\n\t}\n\n}\n\n/**\n * AVIF Texture Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_avif\n *\n * @private\n */\nclass GLTFTextureAVIFExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.EXT_TEXTURE_AVIF;\n\n\t}\n\n\tloadTexture( textureIndex ) {\n\n\t\tconst name = this.name;\n\t\tconst parser = this.parser;\n\t\tconst json = parser.json;\n\n\t\tconst textureDef = json.textures[ textureIndex ];\n\n\t\tif ( ! textureDef.extensions || ! textureDef.extensions[ name ] ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst extension = textureDef.extensions[ name ];\n\t\tconst source = json.images[ extension.source ];\n\n\t\tlet loader = parser.textureLoader;\n\t\tif ( source.uri ) {\n\n\t\t\tconst handler = parser.options.manager.getHandler( source.uri );\n\t\t\tif ( handler !== null ) loader = handler;\n\n\t\t}\n\n\t\treturn parser.loadTextureImage( textureIndex, extension.source, loader );\n\n\t}\n\n}\n\n/**\n * meshopt BufferView Compression Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_meshopt_compression\n *\n * @private\n */\nclass GLTFMeshoptCompression {\n\n\tconstructor( parser ) {\n\n\t\tthis.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION;\n\t\tthis.parser = parser;\n\n\t}\n\n\tloadBufferView( index ) {\n\n\t\tconst json = this.parser.json;\n\t\tconst bufferView = json.bufferViews[ index ];\n\n\t\tif ( bufferView.extensions && bufferView.extensions[ this.name ] ) {\n\n\t\t\tconst extensionDef = bufferView.extensions[ this.name ];\n\n\t\t\tconst buffer = this.parser.getDependency( 'buffer', extensionDef.buffer );\n\t\t\tconst decoder = this.parser.options.meshoptDecoder;\n\n\t\t\tif ( ! decoder || ! decoder.supported ) {\n\n\t\t\t\tif ( json.extensionsRequired && json.extensionsRequired.indexOf( this.name ) >= 0 ) {\n\n\t\t\t\t\tthrow new Error( 'THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files' );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// Assumes that the extension is optional and that fallback buffer data is present\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn buffer.then( function ( res ) {\n\n\t\t\t\tconst byteOffset = extensionDef.byteOffset || 0;\n\t\t\t\tconst byteLength = extensionDef.byteLength || 0;\n\n\t\t\t\tconst count = extensionDef.count;\n\t\t\t\tconst stride = extensionDef.byteStride;\n\n\t\t\t\tconst source = new Uint8Array( res, byteOffset, byteLength );\n\n\t\t\t\tif ( decoder.decodeGltfBufferAsync ) {\n\n\t\t\t\t\treturn decoder.decodeGltfBufferAsync( count, stride, source, extensionDef.mode, extensionDef.filter ).then( function ( res ) {\n\n\t\t\t\t\t\treturn res.buffer;\n\n\t\t\t\t\t} );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// Support for MeshoptDecoder 0.18 or earlier, without decodeGltfBufferAsync\n\t\t\t\t\treturn decoder.ready.then( function () {\n\n\t\t\t\t\t\tconst result = new ArrayBuffer( count * stride );\n\t\t\t\t\t\tdecoder.decodeGltfBuffer( new Uint8Array( result ), count, stride, source, extensionDef.mode, extensionDef.filter );\n\t\t\t\t\t\treturn result;\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t} else {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * GPU Instancing Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_mesh_gpu_instancing\n *\n * @private\n */\nclass GLTFMeshGpuInstancing {\n\n\tconstructor( parser ) {\n\n\t\tthis.name = EXTENSIONS.EXT_MESH_GPU_INSTANCING;\n\t\tthis.parser = parser;\n\n\t}\n\n\tcreateNodeMesh( nodeIndex ) {\n\n\t\tconst json = this.parser.json;\n\t\tconst nodeDef = json.nodes[ nodeIndex ];\n\n\t\tif ( ! nodeDef.extensions || ! nodeDef.extensions[ this.name ] ||\n\t\t\tnodeDef.mesh === undefined ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst meshDef = json.meshes[ nodeDef.mesh ];\n\n\t\t// No Points or Lines + Instancing support yet\n\n\t\tfor ( const primitive of meshDef.primitives ) {\n\n\t\t\tif ( primitive.mode !== WEBGL_CONSTANTS.TRIANGLES &&\n\t\t\t\t primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_STRIP &&\n\t\t\t\t primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_FAN &&\n\t\t\t\t primitive.mode !== undefined ) {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst extensionDef = nodeDef.extensions[ this.name ];\n\t\tconst attributesDef = extensionDef.attributes;\n\n\t\t// @TODO: Can we support InstancedMesh + SkinnedMesh?\n\n\t\tconst pending = [];\n\t\tconst attributes = {};\n\n\t\tfor ( const key in attributesDef ) {\n\n\t\t\tpending.push( this.parser.getDependency( 'accessor', attributesDef[ key ] ).then( accessor => {\n\n\t\t\t\tattributes[ key ] = accessor;\n\t\t\t\treturn attributes[ key ];\n\n\t\t\t} ) );\n\n\t\t}\n\n\t\tif ( pending.length < 1 ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tpending.push( this.parser.createNodeMesh( nodeIndex ) );\n\n\t\treturn Promise.all( pending ).then( results => {\n\n\t\t\tconst nodeObject = results.pop();\n\t\t\tconst meshes = nodeObject.isGroup ? nodeObject.children : [ nodeObject ];\n\t\t\tconst count = results[ 0 ].count; // All attribute counts should be same\n\t\t\tconst instancedMeshes = [];\n\n\t\t\tfor ( const mesh of meshes ) {\n\n\t\t\t\t// Temporal variables\n\t\t\t\tconst m = new Matrix4();\n\t\t\t\tconst p = new Vector3();\n\t\t\t\tconst q = new Quaternion();\n\t\t\t\tconst s = new Vector3( 1, 1, 1 );\n\n\t\t\t\tconst instancedMesh = new InstancedMesh( mesh.geometry, mesh.material, count );\n\n\t\t\t\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\t\t\t\tif ( attributes.TRANSLATION ) {\n\n\t\t\t\t\t\tp.fromBufferAttribute( attributes.TRANSLATION, i );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( attributes.ROTATION ) {\n\n\t\t\t\t\t\tq.fromBufferAttribute( attributes.ROTATION, i );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( attributes.SCALE ) {\n\n\t\t\t\t\t\ts.fromBufferAttribute( attributes.SCALE, i );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tinstancedMesh.setMatrixAt( i, m.compose( p, q, s ) );\n\n\t\t\t\t}\n\n\t\t\t\t// Add instance attributes to the geometry, excluding TRS.\n\t\t\t\tfor ( const attributeName in attributes ) {\n\n\t\t\t\t\tif ( attributeName === '_COLOR_0' ) {\n\n\t\t\t\t\t\tconst attr = attributes[ attributeName ];\n\t\t\t\t\t\tinstancedMesh.instanceColor = new InstancedBufferAttribute( attr.array, attr.itemSize, attr.normalized );\n\n\t\t\t\t\t} else if ( attributeName !== 'TRANSLATION' &&\n\t\t\t\t\t\t attributeName !== 'ROTATION' &&\n\t\t\t\t\t\t attributeName !== 'SCALE' ) {\n\n\t\t\t\t\t\tmesh.geometry.setAttribute( attributeName, attributes[ attributeName ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// Just in case\n\t\t\t\tObject3D.prototype.copy.call( instancedMesh, mesh );\n\n\t\t\t\tthis.parser.assignFinalMaterial( instancedMesh );\n\n\t\t\t\tinstancedMeshes.push( instancedMesh );\n\n\t\t\t}\n\n\t\t\tif ( nodeObject.isGroup ) {\n\n\t\t\t\tnodeObject.clear();\n\n\t\t\t\tnodeObject.add( ... instancedMeshes );\n\n\t\t\t\treturn nodeObject;\n\n\t\t\t}\n\n\t\t\treturn instancedMeshes[ 0 ];\n\n\t\t} );\n\n\t}\n\n}\n\n/* BINARY EXTENSION */\nconst BINARY_EXTENSION_HEADER_MAGIC = 'glTF';\nconst BINARY_EXTENSION_HEADER_LENGTH = 12;\nconst BINARY_EXTENSION_CHUNK_TYPES = { JSON: 0x4E4F534A, BIN: 0x004E4942 };\n\nclass GLTFBinaryExtension {\n\n\tconstructor( data ) {\n\n\t\tthis.name = EXTENSIONS.KHR_BINARY_GLTF;\n\t\tthis.content = null;\n\t\tthis.body = null;\n\n\t\tconst headerView = new DataView( data, 0, BINARY_EXTENSION_HEADER_LENGTH );\n\t\tconst textDecoder = new TextDecoder();\n\n\t\tthis.header = {\n\t\t\tmagic: textDecoder.decode( new Uint8Array( data.slice( 0, 4 ) ) ),\n\t\t\tversion: headerView.getUint32( 4, true ),\n\t\t\tlength: headerView.getUint32( 8, true )\n\t\t};\n\n\t\tif ( this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFLoader: Unsupported glTF-Binary header.' );\n\n\t\t} else if ( this.header.version < 2.0 ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFLoader: Legacy binary file detected.' );\n\n\t\t}\n\n\t\tconst chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH;\n\t\tconst chunkView = new DataView( data, BINARY_EXTENSION_HEADER_LENGTH );\n\t\tlet chunkIndex = 0;\n\n\t\twhile ( chunkIndex < chunkContentsLength ) {\n\n\t\t\tconst chunkLength = chunkView.getUint32( chunkIndex, true );\n\t\t\tchunkIndex += 4;\n\n\t\t\tconst chunkType = chunkView.getUint32( chunkIndex, true );\n\t\t\tchunkIndex += 4;\n\n\t\t\tif ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON ) {\n\n\t\t\t\tconst contentArray = new Uint8Array( data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength );\n\t\t\t\tthis.content = textDecoder.decode( contentArray );\n\n\t\t\t} else if ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN ) {\n\n\t\t\t\tconst byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;\n\t\t\t\tthis.body = data.slice( byteOffset, byteOffset + chunkLength );\n\n\t\t\t}\n\n\t\t\t// Clients must ignore chunks with unknown types.\n\n\t\t\tchunkIndex += chunkLength;\n\n\t\t}\n\n\t\tif ( this.content === null ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFLoader: JSON content not found.' );\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * DRACO Mesh Compression Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression\n *\n * @private\n */\nclass GLTFDracoMeshCompressionExtension {\n\n\tconstructor( json, dracoLoader ) {\n\n\t\tif ( ! dracoLoader ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFLoader: No DRACOLoader instance provided.' );\n\n\t\t}\n\n\t\tthis.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;\n\t\tthis.json = json;\n\t\tthis.dracoLoader = dracoLoader;\n\t\tthis.dracoLoader.preload();\n\n\t}\n\n\tdecodePrimitive( primitive, parser ) {\n\n\t\tconst json = this.json;\n\t\tconst dracoLoader = this.dracoLoader;\n\t\tconst bufferViewIndex = primitive.extensions[ this.name ].bufferView;\n\t\tconst gltfAttributeMap = primitive.extensions[ this.name ].attributes;\n\t\tconst threeAttributeMap = {};\n\t\tconst attributeNormalizedMap = {};\n\t\tconst attributeTypeMap = {};\n\n\t\tfor ( const attributeName in gltfAttributeMap ) {\n\n\t\t\tconst threeAttributeName = ATTRIBUTES[ attributeName ] || attributeName.toLowerCase();\n\n\t\t\tthreeAttributeMap[ threeAttributeName ] = gltfAttributeMap[ attributeName ];\n\n\t\t}\n\n\t\tfor ( const attributeName in primitive.attributes ) {\n\n\t\t\tconst threeAttributeName = ATTRIBUTES[ attributeName ] || attributeName.toLowerCase();\n\n\t\t\tif ( gltfAttributeMap[ attributeName ] !== undefined ) {\n\n\t\t\t\tconst accessorDef = json.accessors[ primitive.attributes[ attributeName ] ];\n\t\t\t\tconst componentType = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];\n\n\t\t\t\tattributeTypeMap[ threeAttributeName ] = componentType.name;\n\t\t\t\tattributeNormalizedMap[ threeAttributeName ] = accessorDef.normalized === true;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn parser.getDependency( 'bufferView', bufferViewIndex ).then( function ( bufferView ) {\n\n\t\t\treturn new Promise( function ( resolve, reject ) {\n\n\t\t\t\tdracoLoader.decodeDracoFile( bufferView, function ( geometry ) {\n\n\t\t\t\t\tfor ( const attributeName in geometry.attributes ) {\n\n\t\t\t\t\t\tconst attribute = geometry.attributes[ attributeName ];\n\t\t\t\t\t\tconst normalized = attributeNormalizedMap[ attributeName ];\n\n\t\t\t\t\t\tif ( normalized !== undefined ) attribute.normalized = normalized;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tresolve( geometry );\n\n\t\t\t\t}, threeAttributeMap, attributeTypeMap, LinearSRGBColorSpace, reject );\n\n\t\t\t} );\n\n\t\t} );\n\n\t}\n\n}\n\n/**\n * Texture Transform Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_transform\n *\n * @private\n */\nclass GLTFTextureTransformExtension {\n\n\tconstructor() {\n\n\t\tthis.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;\n\n\t}\n\n\textendTexture( texture, transform ) {\n\n\t\tif ( ( transform.texCoord === undefined || transform.texCoord === texture.channel )\n\t\t\t&& transform.offset === undefined\n\t\t\t&& transform.rotation === undefined\n\t\t\t&& transform.scale === undefined ) {\n\n\t\t\t// See https://github.com/mrdoob/three.js/issues/21819.\n\t\t\treturn texture;\n\n\t\t}\n\n\t\ttexture = texture.clone();\n\n\t\tif ( transform.texCoord !== undefined ) {\n\n\t\t\ttexture.channel = transform.texCoord;\n\n\t\t}\n\n\t\tif ( transform.offset !== undefined ) {\n\n\t\t\ttexture.offset.fromArray( transform.offset );\n\n\t\t}\n\n\t\tif ( transform.rotation !== undefined ) {\n\n\t\t\ttexture.rotation = transform.rotation;\n\n\t\t}\n\n\t\tif ( transform.scale !== undefined ) {\n\n\t\t\ttexture.repeat.fromArray( transform.scale );\n\n\t\t}\n\n\t\ttexture.needsUpdate = true;\n\n\t\treturn texture;\n\n\t}\n\n}\n\n/**\n * Mesh Quantization Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization\n *\n * @private\n */\nclass GLTFMeshQuantizationExtension {\n\n\tconstructor() {\n\n\t\tthis.name = EXTENSIONS.KHR_MESH_QUANTIZATION;\n\n\t}\n\n}\n\n/*********************************/\n/********** INTERPOLATION ********/\n/*********************************/\n\n// Spline Interpolation\n// Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#appendix-c-spline-interpolation\nclass GLTFCubicSplineInterpolant extends Interpolant {\n\n\tconstructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\t\tsuper( parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n\t}\n\n\tcopySampleValue_( index ) {\n\n\t\t// Copies a sample value to the result buffer. See description of glTF\n\t\t// CUBICSPLINE values layout in interpolate_() function below.\n\n\t\tconst result = this.resultBuffer,\n\t\t\tvalues = this.sampleValues,\n\t\t\tvalueSize = this.valueSize,\n\t\t\toffset = index * valueSize * 3 + valueSize;\n\n\t\tfor ( let i = 0; i !== valueSize; i ++ ) {\n\n\t\t\tresult[ i ] = values[ offset + i ];\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tinterpolate_( i1, t0, t, t1 ) {\n\n\t\tconst result = this.resultBuffer;\n\t\tconst values = this.sampleValues;\n\t\tconst stride = this.valueSize;\n\n\t\tconst stride2 = stride * 2;\n\t\tconst stride3 = stride * 3;\n\n\t\tconst td = t1 - t0;\n\n\t\tconst p = ( t - t0 ) / td;\n\t\tconst pp = p * p;\n\t\tconst ppp = pp * p;\n\n\t\tconst offset1 = i1 * stride3;\n\t\tconst offset0 = offset1 - stride3;\n\n\t\tconst s2 = - 2 * ppp + 3 * pp;\n\t\tconst s3 = ppp - pp;\n\t\tconst s0 = 1 - s2;\n\t\tconst s1 = s3 - pp + p;\n\n\t\t// Layout of keyframe output values for CUBICSPLINE animations:\n\t\t//   [ inTangent_1, splineVertex_1, outTangent_1, inTangent_2, splineVertex_2, ... ]\n\t\tfor ( let i = 0; i !== stride; i ++ ) {\n\n\t\t\tconst p0 = values[ offset0 + i + stride ]; // splineVertex_k\n\t\t\tconst m0 = values[ offset0 + i + stride2 ] * td; // outTangent_k * (t_k+1 - t_k)\n\t\t\tconst p1 = values[ offset1 + i + stride ]; // splineVertex_k+1\n\t\t\tconst m1 = values[ offset1 + i ] * td; // inTangent_k+1 * (t_k+1 - t_k)\n\n\t\t\tresult[ i ] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n}\n\nconst _quaternion = new Quaternion();\n\nclass GLTFCubicSplineQuaternionInterpolant extends GLTFCubicSplineInterpolant {\n\n\tinterpolate_( i1, t0, t, t1 ) {\n\n\t\tconst result = super.interpolate_( i1, t0, t, t1 );\n\n\t\t_quaternion.fromArray( result ).normalize().toArray( result );\n\n\t\treturn result;\n\n\t}\n\n}\n\n\n/*********************************/\n/********** INTERNALS ************/\n/*********************************/\n\n/* CONSTANTS */\n\nconst WEBGL_CONSTANTS = {\n\tFLOAT: 5126,\n\t//FLOAT_MAT2: 35674,\n\tFLOAT_MAT3: 35675,\n\tFLOAT_MAT4: 35676,\n\tFLOAT_VEC2: 35664,\n\tFLOAT_VEC3: 35665,\n\tFLOAT_VEC4: 35666,\n\tLINEAR: 9729,\n\tREPEAT: 10497,\n\tSAMPLER_2D: 35678,\n\tPOINTS: 0,\n\tLINES: 1,\n\tLINE_LOOP: 2,\n\tLINE_STRIP: 3,\n\tTRIANGLES: 4,\n\tTRIANGLE_STRIP: 5,\n\tTRIANGLE_FAN: 6,\n\tUNSIGNED_BYTE: 5121,\n\tUNSIGNED_SHORT: 5123\n};\n\nconst WEBGL_COMPONENT_TYPES = {\n\t5120: Int8Array,\n\t5121: Uint8Array,\n\t5122: Int16Array,\n\t5123: Uint16Array,\n\t5125: Uint32Array,\n\t5126: Float32Array\n};\n\nconst WEBGL_FILTERS = {\n\t9728: NearestFilter,\n\t9729: LinearFilter,\n\t9984: NearestMipmapNearestFilter,\n\t9985: LinearMipmapNearestFilter,\n\t9986: NearestMipmapLinearFilter,\n\t9987: LinearMipmapLinearFilter\n};\n\nconst WEBGL_WRAPPINGS = {\n\t33071: ClampToEdgeWrapping,\n\t33648: MirroredRepeatWrapping,\n\t10497: RepeatWrapping\n};\n\nconst WEBGL_TYPE_SIZES = {\n\t'SCALAR': 1,\n\t'VEC2': 2,\n\t'VEC3': 3,\n\t'VEC4': 4,\n\t'MAT2': 4,\n\t'MAT3': 9,\n\t'MAT4': 16\n};\n\nconst ATTRIBUTES = {\n\tPOSITION: 'position',\n\tNORMAL: 'normal',\n\tTANGENT: 'tangent',\n\tTEXCOORD_0: 'uv',\n\tTEXCOORD_1: 'uv1',\n\tTEXCOORD_2: 'uv2',\n\tTEXCOORD_3: 'uv3',\n\tCOLOR_0: 'color',\n\tWEIGHTS_0: 'skinWeight',\n\tJOINTS_0: 'skinIndex',\n};\n\nconst PATH_PROPERTIES = {\n\tscale: 'scale',\n\ttranslation: 'position',\n\trotation: 'quaternion',\n\tweights: 'morphTargetInfluences'\n};\n\nconst INTERPOLATION = {\n\tCUBICSPLINE: undefined, // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each\n\t\t                        // keyframe track will be initialized with a default interpolation type, then modified.\n\tLINEAR: InterpolateLinear,\n\tSTEP: InterpolateDiscrete\n};\n\nconst ALPHA_MODES = {\n\tOPAQUE: 'OPAQUE',\n\tMASK: 'MASK',\n\tBLEND: 'BLEND'\n};\n\n/**\n * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#default-material\n *\n * @private\n * @param {Object<string, Material>} cache\n * @return {Material}\n */\nfunction createDefaultMaterial( cache ) {\n\n\tif ( cache[ 'DefaultMaterial' ] === undefined ) {\n\n\t\tcache[ 'DefaultMaterial' ] = new MeshStandardMaterial( {\n\t\t\tcolor: 0xFFFFFF,\n\t\t\temissive: 0x000000,\n\t\t\tmetalness: 1,\n\t\t\troughness: 1,\n\t\t\ttransparent: false,\n\t\t\tdepthTest: true,\n\t\t\tside: FrontSide\n\t\t} );\n\n\t}\n\n\treturn cache[ 'DefaultMaterial' ];\n\n}\n\nfunction addUnknownExtensionsToUserData( knownExtensions, object, objectDef ) {\n\n\t// Add unknown glTF extensions to an object's userData.\n\n\tfor ( const name in objectDef.extensions ) {\n\n\t\tif ( knownExtensions[ name ] === undefined ) {\n\n\t\t\tobject.userData.gltfExtensions = object.userData.gltfExtensions || {};\n\t\t\tobject.userData.gltfExtensions[ name ] = objectDef.extensions[ name ];\n\n\t\t}\n\n\t}\n\n}\n\n/**\n *\n * @private\n * @param {Object3D|Material|BufferGeometry|Object|AnimationClip} object\n * @param {GLTF.definition} gltfDef\n */\nfunction assignExtrasToUserData( object, gltfDef ) {\n\n\tif ( gltfDef.extras !== undefined ) {\n\n\t\tif ( typeof gltfDef.extras === 'object' ) {\n\n\t\t\tObject.assign( object.userData, gltfDef.extras );\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.GLTFLoader: Ignoring primitive type .extras, ' + gltfDef.extras );\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#morph-targets\n *\n * @private\n * @param {BufferGeometry} geometry\n * @param {Array<GLTF.Target>} targets\n * @param {GLTFParser} parser\n * @return {Promise<BufferGeometry>}\n */\nfunction addMorphTargets( geometry, targets, parser ) {\n\n\tlet hasMorphPosition = false;\n\tlet hasMorphNormal = false;\n\tlet hasMorphColor = false;\n\n\tfor ( let i = 0, il = targets.length; i < il; i ++ ) {\n\n\t\tconst target = targets[ i ];\n\n\t\tif ( target.POSITION !== undefined ) hasMorphPosition = true;\n\t\tif ( target.NORMAL !== undefined ) hasMorphNormal = true;\n\t\tif ( target.COLOR_0 !== undefined ) hasMorphColor = true;\n\n\t\tif ( hasMorphPosition && hasMorphNormal && hasMorphColor ) break;\n\n\t}\n\n\tif ( ! hasMorphPosition && ! hasMorphNormal && ! hasMorphColor ) return Promise.resolve( geometry );\n\n\tconst pendingPositionAccessors = [];\n\tconst pendingNormalAccessors = [];\n\tconst pendingColorAccessors = [];\n\n\tfor ( let i = 0, il = targets.length; i < il; i ++ ) {\n\n\t\tconst target = targets[ i ];\n\n\t\tif ( hasMorphPosition ) {\n\n\t\t\tconst pendingAccessor = target.POSITION !== undefined\n\t\t\t\t? parser.getDependency( 'accessor', target.POSITION )\n\t\t\t\t: geometry.attributes.position;\n\n\t\t\tpendingPositionAccessors.push( pendingAccessor );\n\n\t\t}\n\n\t\tif ( hasMorphNormal ) {\n\n\t\t\tconst pendingAccessor = target.NORMAL !== undefined\n\t\t\t\t? parser.getDependency( 'accessor', target.NORMAL )\n\t\t\t\t: geometry.attributes.normal;\n\n\t\t\tpendingNormalAccessors.push( pendingAccessor );\n\n\t\t}\n\n\t\tif ( hasMorphColor ) {\n\n\t\t\tconst pendingAccessor = target.COLOR_0 !== undefined\n\t\t\t\t? parser.getDependency( 'accessor', target.COLOR_0 )\n\t\t\t\t: geometry.attributes.color;\n\n\t\t\tpendingColorAccessors.push( pendingAccessor );\n\n\t\t}\n\n\t}\n\n\treturn Promise.all( [\n\t\tPromise.all( pendingPositionAccessors ),\n\t\tPromise.all( pendingNormalAccessors ),\n\t\tPromise.all( pendingColorAccessors )\n\t] ).then( function ( accessors ) {\n\n\t\tconst morphPositions = accessors[ 0 ];\n\t\tconst morphNormals = accessors[ 1 ];\n\t\tconst morphColors = accessors[ 2 ];\n\n\t\tif ( hasMorphPosition ) geometry.morphAttributes.position = morphPositions;\n\t\tif ( hasMorphNormal ) geometry.morphAttributes.normal = morphNormals;\n\t\tif ( hasMorphColor ) geometry.morphAttributes.color = morphColors;\n\t\tgeometry.morphTargetsRelative = true;\n\n\t\treturn geometry;\n\n\t} );\n\n}\n\n/**\n *\n * @private\n * @param {Mesh} mesh\n * @param {GLTF.Mesh} meshDef\n */\nfunction updateMorphTargets( mesh, meshDef ) {\n\n\tmesh.updateMorphTargets();\n\n\tif ( meshDef.weights !== undefined ) {\n\n\t\tfor ( let i = 0, il = meshDef.weights.length; i < il; i ++ ) {\n\n\t\t\tmesh.morphTargetInfluences[ i ] = meshDef.weights[ i ];\n\n\t\t}\n\n\t}\n\n\t// .extras has user-defined data, so check that .extras.targetNames is an array.\n\tif ( meshDef.extras && Array.isArray( meshDef.extras.targetNames ) ) {\n\n\t\tconst targetNames = meshDef.extras.targetNames;\n\n\t\tif ( mesh.morphTargetInfluences.length === targetNames.length ) {\n\n\t\t\tmesh.morphTargetDictionary = {};\n\n\t\t\tfor ( let i = 0, il = targetNames.length; i < il; i ++ ) {\n\n\t\t\t\tmesh.morphTargetDictionary[ targetNames[ i ] ] = i;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.' );\n\n\t\t}\n\n\t}\n\n}\n\nfunction createPrimitiveKey( primitiveDef ) {\n\n\tlet geometryKey;\n\n\tconst dracoExtension = primitiveDef.extensions && primitiveDef.extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ];\n\n\tif ( dracoExtension ) {\n\n\t\tgeometryKey = 'draco:' + dracoExtension.bufferView\n\t\t\t\t+ ':' + dracoExtension.indices\n\t\t\t\t+ ':' + createAttributesKey( dracoExtension.attributes );\n\n\t} else {\n\n\t\tgeometryKey = primitiveDef.indices + ':' + createAttributesKey( primitiveDef.attributes ) + ':' + primitiveDef.mode;\n\n\t}\n\n\tif ( primitiveDef.targets !== undefined ) {\n\n\t\tfor ( let i = 0, il = primitiveDef.targets.length; i < il; i ++ ) {\n\n\t\t\tgeometryKey += ':' + createAttributesKey( primitiveDef.targets[ i ] );\n\n\t\t}\n\n\t}\n\n\treturn geometryKey;\n\n}\n\nfunction createAttributesKey( attributes ) {\n\n\tlet attributesKey = '';\n\n\tconst keys = Object.keys( attributes ).sort();\n\n\tfor ( let i = 0, il = keys.length; i < il; i ++ ) {\n\n\t\tattributesKey += keys[ i ] + ':' + attributes[ keys[ i ] ] + ';';\n\n\t}\n\n\treturn attributesKey;\n\n}\n\nfunction getNormalizedComponentScale( constructor ) {\n\n\t// Reference:\n\t// https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization#encoding-quantized-data\n\n\tswitch ( constructor ) {\n\n\t\tcase Int8Array:\n\t\t\treturn 1 / 127;\n\n\t\tcase Uint8Array:\n\t\t\treturn 1 / 255;\n\n\t\tcase Int16Array:\n\t\t\treturn 1 / 32767;\n\n\t\tcase Uint16Array:\n\t\t\treturn 1 / 65535;\n\n\t\tdefault:\n\t\t\tthrow new Error( 'THREE.GLTFLoader: Unsupported normalized accessor component type.' );\n\n\t}\n\n}\n\nfunction getImageURIMimeType( uri ) {\n\n\tif ( uri.search( /\\.jpe?g($|\\?)/i ) > 0 || uri.search( /^data\\:image\\/jpeg/ ) === 0 ) return 'image/jpeg';\n\tif ( uri.search( /\\.webp($|\\?)/i ) > 0 || uri.search( /^data\\:image\\/webp/ ) === 0 ) return 'image/webp';\n\tif ( uri.search( /\\.ktx2($|\\?)/i ) > 0 || uri.search( /^data\\:image\\/ktx2/ ) === 0 ) return 'image/ktx2';\n\n\treturn 'image/png';\n\n}\n\nconst _identityMatrix = new Matrix4();\n\n/* GLTF PARSER */\n\nclass GLTFParser {\n\n\tconstructor( json = {}, options = {} ) {\n\n\t\tthis.json = json;\n\t\tthis.extensions = {};\n\t\tthis.plugins = {};\n\t\tthis.options = options;\n\n\t\t// loader object cache\n\t\tthis.cache = new GLTFRegistry();\n\n\t\t// associations between Three.js objects and glTF elements\n\t\tthis.associations = new Map();\n\n\t\t// BufferGeometry caching\n\t\tthis.primitiveCache = {};\n\n\t\t// Node cache\n\t\tthis.nodeCache = {};\n\n\t\t// Object3D instance caches\n\t\tthis.meshCache = { refs: {}, uses: {} };\n\t\tthis.cameraCache = { refs: {}, uses: {} };\n\t\tthis.lightCache = { refs: {}, uses: {} };\n\n\t\tthis.sourceCache = {};\n\t\tthis.textureCache = {};\n\n\t\t// Track node names, to ensure no duplicates\n\t\tthis.nodeNamesUsed = {};\n\n\t\t// Use an ImageBitmapLoader if imageBitmaps are supported. Moves much of the\n\t\t// expensive work of uploading a texture to the GPU off the main thread.\n\n\t\tlet isSafari = false;\n\t\tlet safariVersion = - 1;\n\t\tlet isFirefox = false;\n\t\tlet firefoxVersion = - 1;\n\n\t\tif ( typeof navigator !== 'undefined' ) {\n\n\t\t\tconst userAgent = navigator.userAgent;\n\n\t\t\tisSafari = /^((?!chrome|android).)*safari/i.test( userAgent ) === true;\n\t\t\tconst safariMatch = userAgent.match( /Version\\/(\\d+)/ );\n\t\t\tsafariVersion = isSafari && safariMatch ? parseInt( safariMatch[ 1 ], 10 ) : - 1;\n\n\t\t\tisFirefox = userAgent.indexOf( 'Firefox' ) > - 1;\n\t\t\tfirefoxVersion = isFirefox ? userAgent.match( /Firefox\\/([0-9]+)\\./ )[ 1 ] : - 1;\n\n\t\t}\n\n\t\tif ( typeof createImageBitmap === 'undefined' || ( isSafari && safariVersion < 17 ) || ( isFirefox && firefoxVersion < 98 ) ) {\n\n\t\t\tthis.textureLoader = new TextureLoader( this.options.manager );\n\n\t\t} else {\n\n\t\t\tthis.textureLoader = new ImageBitmapLoader( this.options.manager );\n\n\t\t}\n\n\t\tthis.textureLoader.setCrossOrigin( this.options.crossOrigin );\n\t\tthis.textureLoader.setRequestHeader( this.options.requestHeader );\n\n\t\tthis.fileLoader = new FileLoader( this.options.manager );\n\t\tthis.fileLoader.setResponseType( 'arraybuffer' );\n\n\t\tif ( this.options.crossOrigin === 'use-credentials' ) {\n\n\t\t\tthis.fileLoader.setWithCredentials( true );\n\n\t\t}\n\n\t}\n\n\tsetExtensions( extensions ) {\n\n\t\tthis.extensions = extensions;\n\n\t}\n\n\tsetPlugins( plugins ) {\n\n\t\tthis.plugins = plugins;\n\n\t}\n\n\tparse( onLoad, onError ) {\n\n\t\tconst parser = this;\n\t\tconst json = this.json;\n\t\tconst extensions = this.extensions;\n\n\t\t// Clear the loader cache\n\t\tthis.cache.removeAll();\n\t\tthis.nodeCache = {};\n\n\t\t// Mark the special nodes/meshes in json for efficient parse\n\t\tthis._invokeAll( function ( ext ) {\n\n\t\t\treturn ext._markDefs && ext._markDefs();\n\n\t\t} );\n\n\t\tPromise.all( this._invokeAll( function ( ext ) {\n\n\t\t\treturn ext.beforeRoot && ext.beforeRoot();\n\n\t\t} ) ).then( function () {\n\n\t\t\treturn Promise.all( [\n\n\t\t\t\tparser.getDependencies( 'scene' ),\n\t\t\t\tparser.getDependencies( 'animation' ),\n\t\t\t\tparser.getDependencies( 'camera' ),\n\n\t\t\t] );\n\n\t\t} ).then( function ( dependencies ) {\n\n\t\t\tconst result = {\n\t\t\t\tscene: dependencies[ 0 ][ json.scene || 0 ],\n\t\t\t\tscenes: dependencies[ 0 ],\n\t\t\t\tanimations: dependencies[ 1 ],\n\t\t\t\tcameras: dependencies[ 2 ],\n\t\t\t\tasset: json.asset,\n\t\t\t\tparser: parser,\n\t\t\t\tuserData: {}\n\t\t\t};\n\n\t\t\taddUnknownExtensionsToUserData( extensions, result, json );\n\n\t\t\tassignExtrasToUserData( result, json );\n\n\t\t\treturn Promise.all( parser._invokeAll( function ( ext ) {\n\n\t\t\t\treturn ext.afterRoot && ext.afterRoot( result );\n\n\t\t\t} ) ).then( function () {\n\n\t\t\t\tfor ( const scene of result.scenes ) {\n\n\t\t\t\t\tscene.updateMatrixWorld();\n\n\t\t\t\t}\n\n\t\t\t\tonLoad( result );\n\n\t\t\t} );\n\n\t\t} ).catch( onError );\n\n\t}\n\n\t/**\n\t * Marks the special nodes/meshes in json for efficient parse.\n\t *\n\t * @private\n\t */\n\t_markDefs() {\n\n\t\tconst nodeDefs = this.json.nodes || [];\n\t\tconst skinDefs = this.json.skins || [];\n\t\tconst meshDefs = this.json.meshes || [];\n\n\t\t// Nothing in the node definition indicates whether it is a Bone or an\n\t\t// Object3D. Use the skins' joint references to mark bones.\n\t\tfor ( let skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex ++ ) {\n\n\t\t\tconst joints = skinDefs[ skinIndex ].joints;\n\n\t\t\tfor ( let i = 0, il = joints.length; i < il; i ++ ) {\n\n\t\t\t\tnodeDefs[ joints[ i ] ].isBone = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Iterate over all nodes, marking references to shared resources,\n\t\t// as well as skeleton joints.\n\t\tfor ( let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex ++ ) {\n\n\t\t\tconst nodeDef = nodeDefs[ nodeIndex ];\n\n\t\t\tif ( nodeDef.mesh !== undefined ) {\n\n\t\t\t\tthis._addNodeRef( this.meshCache, nodeDef.mesh );\n\n\t\t\t\t// Nothing in the mesh definition indicates whether it is\n\t\t\t\t// a SkinnedMesh or Mesh. Use the node's mesh reference\n\t\t\t\t// to mark SkinnedMesh if node has skin.\n\t\t\t\tif ( nodeDef.skin !== undefined ) {\n\n\t\t\t\t\tmeshDefs[ nodeDef.mesh ].isSkinnedMesh = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( nodeDef.camera !== undefined ) {\n\n\t\t\t\tthis._addNodeRef( this.cameraCache, nodeDef.camera );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Counts references to shared node / Object3D resources. These resources\n\t * can be reused, or \"instantiated\", at multiple nodes in the scene\n\t * hierarchy. Mesh, Camera, and Light instances are instantiated and must\n\t * be marked. Non-scenegraph resources (like Materials, Geometries, and\n\t * Textures) can be reused directly and are not marked here.\n\t *\n\t * Example: CesiumMilkTruck sample model reuses \"Wheel\" meshes.\n\t *\n\t * @private\n\t * @param {Object} cache\n\t * @param {Object3D} index\n\t */\n\t_addNodeRef( cache, index ) {\n\n\t\tif ( index === undefined ) return;\n\n\t\tif ( cache.refs[ index ] === undefined ) {\n\n\t\t\tcache.refs[ index ] = cache.uses[ index ] = 0;\n\n\t\t}\n\n\t\tcache.refs[ index ] ++;\n\n\t}\n\n\t/**\n\t * Returns a reference to a shared resource, cloning it if necessary.\n\t *\n\t * @private\n\t * @param {Object} cache\n\t * @param {number} index\n\t * @param {Object} object\n\t * @return {Object}\n\t */\n\t_getNodeRef( cache, index, object ) {\n\n\t\tif ( cache.refs[ index ] <= 1 ) return object;\n\n\t\tconst ref = object.clone();\n\n\t\t// Propagates mappings to the cloned object, prevents mappings on the\n\t\t// original object from being lost.\n\t\tconst updateMappings = ( original, clone ) => {\n\n\t\t\tconst mappings = this.associations.get( original );\n\t\t\tif ( mappings != null ) {\n\n\t\t\t\tthis.associations.set( clone, mappings );\n\n\t\t\t}\n\n\t\t\tfor ( const [ i, child ] of original.children.entries() ) {\n\n\t\t\t\tupdateMappings( child, clone.children[ i ] );\n\n\t\t\t}\n\n\t\t};\n\n\t\tupdateMappings( object, ref );\n\n\t\tref.name += '_instance_' + ( cache.uses[ index ] ++ );\n\n\t\treturn ref;\n\n\t}\n\n\t_invokeOne( func ) {\n\n\t\tconst extensions = Object.values( this.plugins );\n\t\textensions.push( this );\n\n\t\tfor ( let i = 0; i < extensions.length; i ++ ) {\n\n\t\t\tconst result = func( extensions[ i ] );\n\n\t\t\tif ( result ) return result;\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\t_invokeAll( func ) {\n\n\t\tconst extensions = Object.values( this.plugins );\n\t\textensions.unshift( this );\n\n\t\tconst pending = [];\n\n\t\tfor ( let i = 0; i < extensions.length; i ++ ) {\n\n\t\t\tconst result = func( extensions[ i ] );\n\n\t\t\tif ( result ) pending.push( result );\n\n\t\t}\n\n\t\treturn pending;\n\n\t}\n\n\t/**\n\t * Requests the specified dependency asynchronously, with caching.\n\t *\n\t * @private\n\t * @param {string} type\n\t * @param {number} index\n\t * @return {Promise<Object3D|Material|Texture|AnimationClip|ArrayBuffer|Object>}\n\t */\n\tgetDependency( type, index ) {\n\n\t\tconst cacheKey = type + ':' + index;\n\t\tlet dependency = this.cache.get( cacheKey );\n\n\t\tif ( ! dependency ) {\n\n\t\t\tswitch ( type ) {\n\n\t\t\t\tcase 'scene':\n\t\t\t\t\tdependency = this.loadScene( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'node':\n\t\t\t\t\tdependency = this._invokeOne( function ( ext ) {\n\n\t\t\t\t\t\treturn ext.loadNode && ext.loadNode( index );\n\n\t\t\t\t\t} );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'mesh':\n\t\t\t\t\tdependency = this._invokeOne( function ( ext ) {\n\n\t\t\t\t\t\treturn ext.loadMesh && ext.loadMesh( index );\n\n\t\t\t\t\t} );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'accessor':\n\t\t\t\t\tdependency = this.loadAccessor( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'bufferView':\n\t\t\t\t\tdependency = this._invokeOne( function ( ext ) {\n\n\t\t\t\t\t\treturn ext.loadBufferView && ext.loadBufferView( index );\n\n\t\t\t\t\t} );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'buffer':\n\t\t\t\t\tdependency = this.loadBuffer( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'material':\n\t\t\t\t\tdependency = this._invokeOne( function ( ext ) {\n\n\t\t\t\t\t\treturn ext.loadMaterial && ext.loadMaterial( index );\n\n\t\t\t\t\t} );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'texture':\n\t\t\t\t\tdependency = this._invokeOne( function ( ext ) {\n\n\t\t\t\t\t\treturn ext.loadTexture && ext.loadTexture( index );\n\n\t\t\t\t\t} );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'skin':\n\t\t\t\t\tdependency = this.loadSkin( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'animation':\n\t\t\t\t\tdependency = this._invokeOne( function ( ext ) {\n\n\t\t\t\t\t\treturn ext.loadAnimation && ext.loadAnimation( index );\n\n\t\t\t\t\t} );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'camera':\n\t\t\t\t\tdependency = this.loadCamera( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tdependency = this._invokeOne( function ( ext ) {\n\n\t\t\t\t\t\treturn ext != this && ext.getDependency && ext.getDependency( type, index );\n\n\t\t\t\t\t} );\n\n\t\t\t\t\tif ( ! dependency ) {\n\n\t\t\t\t\t\tthrow new Error( 'Unknown type: ' + type );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tthis.cache.add( cacheKey, dependency );\n\n\t\t}\n\n\t\treturn dependency;\n\n\t}\n\n\t/**\n\t * Requests all dependencies of the specified type asynchronously, with caching.\n\t *\n\t * @private\n\t * @param {string} type\n\t * @return {Promise<Array<Object>>}\n\t */\n\tgetDependencies( type ) {\n\n\t\tlet dependencies = this.cache.get( type );\n\n\t\tif ( ! dependencies ) {\n\n\t\t\tconst parser = this;\n\t\t\tconst defs = this.json[ type + ( type === 'mesh' ? 'es' : 's' ) ] || [];\n\n\t\t\tdependencies = Promise.all( defs.map( function ( def, index ) {\n\n\t\t\t\treturn parser.getDependency( type, index );\n\n\t\t\t} ) );\n\n\t\t\tthis.cache.add( type, dependencies );\n\n\t\t}\n\n\t\treturn dependencies;\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n\t *\n\t * @private\n\t * @param {number} bufferIndex\n\t * @return {Promise<ArrayBuffer>}\n\t */\n\tloadBuffer( bufferIndex ) {\n\n\t\tconst bufferDef = this.json.buffers[ bufferIndex ];\n\t\tconst loader = this.fileLoader;\n\n\t\tif ( bufferDef.type && bufferDef.type !== 'arraybuffer' ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFLoader: ' + bufferDef.type + ' buffer type is not supported.' );\n\n\t\t}\n\n\t\t// If present, GLB container is required to be the first buffer.\n\t\tif ( bufferDef.uri === undefined && bufferIndex === 0 ) {\n\n\t\t\treturn Promise.resolve( this.extensions[ EXTENSIONS.KHR_BINARY_GLTF ].body );\n\n\t\t}\n\n\t\tconst options = this.options;\n\n\t\treturn new Promise( function ( resolve, reject ) {\n\n\t\t\tloader.load( LoaderUtils.resolveURL( bufferDef.uri, options.path ), resolve, undefined, function () {\n\n\t\t\t\treject( new Error( 'THREE.GLTFLoader: Failed to load buffer \"' + bufferDef.uri + '\".' ) );\n\n\t\t\t} );\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n\t *\n\t * @private\n\t * @param {number} bufferViewIndex\n\t * @return {Promise<ArrayBuffer>}\n\t */\n\tloadBufferView( bufferViewIndex ) {\n\n\t\tconst bufferViewDef = this.json.bufferViews[ bufferViewIndex ];\n\n\t\treturn this.getDependency( 'buffer', bufferViewDef.buffer ).then( function ( buffer ) {\n\n\t\t\tconst byteLength = bufferViewDef.byteLength || 0;\n\t\t\tconst byteOffset = bufferViewDef.byteOffset || 0;\n\t\t\treturn buffer.slice( byteOffset, byteOffset + byteLength );\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors\n\t *\n\t * @private\n\t * @param {number} accessorIndex\n\t * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}\n\t */\n\tloadAccessor( accessorIndex ) {\n\n\t\tconst parser = this;\n\t\tconst json = this.json;\n\n\t\tconst accessorDef = this.json.accessors[ accessorIndex ];\n\n\t\tif ( accessorDef.bufferView === undefined && accessorDef.sparse === undefined ) {\n\n\t\t\tconst itemSize = WEBGL_TYPE_SIZES[ accessorDef.type ];\n\t\t\tconst TypedArray = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];\n\t\t\tconst normalized = accessorDef.normalized === true;\n\n\t\t\tconst array = new TypedArray( accessorDef.count * itemSize );\n\t\t\treturn Promise.resolve( new BufferAttribute( array, itemSize, normalized ) );\n\n\t\t}\n\n\t\tconst pendingBufferViews = [];\n\n\t\tif ( accessorDef.bufferView !== undefined ) {\n\n\t\t\tpendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.bufferView ) );\n\n\t\t} else {\n\n\t\t\tpendingBufferViews.push( null );\n\n\t\t}\n\n\t\tif ( accessorDef.sparse !== undefined ) {\n\n\t\t\tpendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.sparse.indices.bufferView ) );\n\t\t\tpendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.sparse.values.bufferView ) );\n\n\t\t}\n\n\t\treturn Promise.all( pendingBufferViews ).then( function ( bufferViews ) {\n\n\t\t\tconst bufferView = bufferViews[ 0 ];\n\n\t\t\tconst itemSize = WEBGL_TYPE_SIZES[ accessorDef.type ];\n\t\t\tconst TypedArray = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];\n\n\t\t\t// For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.\n\t\t\tconst elementBytes = TypedArray.BYTES_PER_ELEMENT;\n\t\t\tconst itemBytes = elementBytes * itemSize;\n\t\t\tconst byteOffset = accessorDef.byteOffset || 0;\n\t\t\tconst byteStride = accessorDef.bufferView !== undefined ? json.bufferViews[ accessorDef.bufferView ].byteStride : undefined;\n\t\t\tconst normalized = accessorDef.normalized === true;\n\t\t\tlet array, bufferAttribute;\n\n\t\t\t// The buffer is not interleaved if the stride is the item size in bytes.\n\t\t\tif ( byteStride && byteStride !== itemBytes ) {\n\n\t\t\t\t// Each \"slice\" of the buffer, as defined by 'count' elements of 'byteStride' bytes, gets its own InterleavedBuffer\n\t\t\t\t// This makes sure that IBA.count reflects accessor.count properly\n\t\t\t\tconst ibSlice = Math.floor( byteOffset / byteStride );\n\t\t\t\tconst ibCacheKey = 'InterleavedBuffer:' + accessorDef.bufferView + ':' + accessorDef.componentType + ':' + ibSlice + ':' + accessorDef.count;\n\t\t\t\tlet ib = parser.cache.get( ibCacheKey );\n\n\t\t\t\tif ( ! ib ) {\n\n\t\t\t\t\tarray = new TypedArray( bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes );\n\n\t\t\t\t\t// Integer parameters to IB/IBA are in array elements, not bytes.\n\t\t\t\t\tib = new InterleavedBuffer( array, byteStride / elementBytes );\n\n\t\t\t\t\tparser.cache.add( ibCacheKey, ib );\n\n\t\t\t\t}\n\n\t\t\t\tbufferAttribute = new InterleavedBufferAttribute( ib, itemSize, ( byteOffset % byteStride ) / elementBytes, normalized );\n\n\t\t\t} else {\n\n\t\t\t\tif ( bufferView === null ) {\n\n\t\t\t\t\tarray = new TypedArray( accessorDef.count * itemSize );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tarray = new TypedArray( bufferView, byteOffset, accessorDef.count * itemSize );\n\n\t\t\t\t}\n\n\t\t\t\tbufferAttribute = new BufferAttribute( array, itemSize, normalized );\n\n\t\t\t}\n\n\t\t\t// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#sparse-accessors\n\t\t\tif ( accessorDef.sparse !== undefined ) {\n\n\t\t\t\tconst itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;\n\t\t\t\tconst TypedArrayIndices = WEBGL_COMPONENT_TYPES[ accessorDef.sparse.indices.componentType ];\n\n\t\t\t\tconst byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;\n\t\t\t\tconst byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;\n\n\t\t\t\tconst sparseIndices = new TypedArrayIndices( bufferViews[ 1 ], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices );\n\t\t\t\tconst sparseValues = new TypedArray( bufferViews[ 2 ], byteOffsetValues, accessorDef.sparse.count * itemSize );\n\n\t\t\t\tif ( bufferView !== null ) {\n\n\t\t\t\t\t// Avoid modifying the original ArrayBuffer, if the bufferView wasn't initialized with zeroes.\n\t\t\t\t\tbufferAttribute = new BufferAttribute( bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized );\n\n\t\t\t\t}\n\n\t\t\t\t// Ignore normalized since we copy from sparse\n\t\t\t\tbufferAttribute.normalized = false;\n\n\t\t\t\tfor ( let i = 0, il = sparseIndices.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst index = sparseIndices[ i ];\n\n\t\t\t\t\tbufferAttribute.setX( index, sparseValues[ i * itemSize ] );\n\t\t\t\t\tif ( itemSize >= 2 ) bufferAttribute.setY( index, sparseValues[ i * itemSize + 1 ] );\n\t\t\t\t\tif ( itemSize >= 3 ) bufferAttribute.setZ( index, sparseValues[ i * itemSize + 2 ] );\n\t\t\t\t\tif ( itemSize >= 4 ) bufferAttribute.setW( index, sparseValues[ i * itemSize + 3 ] );\n\t\t\t\t\tif ( itemSize >= 5 ) throw new Error( 'THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.' );\n\n\t\t\t\t}\n\n\t\t\t\tbufferAttribute.normalized = normalized;\n\n\t\t\t}\n\n\t\t\treturn bufferAttribute;\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures\n\t *\n\t * @private\n\t * @param {number} textureIndex\n\t * @return {Promise<?Texture>}\n\t */\n\tloadTexture( textureIndex ) {\n\n\t\tconst json = this.json;\n\t\tconst options = this.options;\n\t\tconst textureDef = json.textures[ textureIndex ];\n\t\tconst sourceIndex = textureDef.source;\n\t\tconst sourceDef = json.images[ sourceIndex ];\n\n\t\tlet loader = this.textureLoader;\n\n\t\tif ( sourceDef.uri ) {\n\n\t\t\tconst handler = options.manager.getHandler( sourceDef.uri );\n\t\t\tif ( handler !== null ) loader = handler;\n\n\t\t}\n\n\t\treturn this.loadTextureImage( textureIndex, sourceIndex, loader );\n\n\t}\n\n\tloadTextureImage( textureIndex, sourceIndex, loader ) {\n\n\t\tconst parser = this;\n\t\tconst json = this.json;\n\n\t\tconst textureDef = json.textures[ textureIndex ];\n\t\tconst sourceDef = json.images[ sourceIndex ];\n\n\t\tconst cacheKey = ( sourceDef.uri || sourceDef.bufferView ) + ':' + textureDef.sampler;\n\n\t\tif ( this.textureCache[ cacheKey ] ) {\n\n\t\t\t// See https://github.com/mrdoob/three.js/issues/21559.\n\t\t\treturn this.textureCache[ cacheKey ];\n\n\t\t}\n\n\t\tconst promise = this.loadImageSource( sourceIndex, loader ).then( function ( texture ) {\n\n\t\t\ttexture.flipY = false;\n\n\t\t\ttexture.name = textureDef.name || sourceDef.name || '';\n\n\t\t\tif ( texture.name === '' && typeof sourceDef.uri === 'string' && sourceDef.uri.startsWith( 'data:image/' ) === false ) {\n\n\t\t\t\ttexture.name = sourceDef.uri;\n\n\t\t\t}\n\n\t\t\tconst samplers = json.samplers || {};\n\t\t\tconst sampler = samplers[ textureDef.sampler ] || {};\n\n\t\t\ttexture.magFilter = WEBGL_FILTERS[ sampler.magFilter ] || LinearFilter;\n\t\t\ttexture.minFilter = WEBGL_FILTERS[ sampler.minFilter ] || LinearMipmapLinearFilter;\n\t\t\ttexture.wrapS = WEBGL_WRAPPINGS[ sampler.wrapS ] || RepeatWrapping;\n\t\t\ttexture.wrapT = WEBGL_WRAPPINGS[ sampler.wrapT ] || RepeatWrapping;\n\t\t\ttexture.generateMipmaps = ! texture.isCompressedTexture && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;\n\n\t\t\tparser.associations.set( texture, { textures: textureIndex } );\n\n\t\t\treturn texture;\n\n\t\t} ).catch( function () {\n\n\t\t\treturn null;\n\n\t\t} );\n\n\t\tthis.textureCache[ cacheKey ] = promise;\n\n\t\treturn promise;\n\n\t}\n\n\tloadImageSource( sourceIndex, loader ) {\n\n\t\tconst parser = this;\n\t\tconst json = this.json;\n\t\tconst options = this.options;\n\n\t\tif ( this.sourceCache[ sourceIndex ] !== undefined ) {\n\n\t\t\treturn this.sourceCache[ sourceIndex ].then( ( texture ) => texture.clone() );\n\n\t\t}\n\n\t\tconst sourceDef = json.images[ sourceIndex ];\n\n\t\tconst URL = self.URL || self.webkitURL;\n\n\t\tlet sourceURI = sourceDef.uri || '';\n\t\tlet isObjectURL = false;\n\n\t\tif ( sourceDef.bufferView !== undefined ) {\n\n\t\t\t// Load binary image data from bufferView, if provided.\n\n\t\t\tsourceURI = parser.getDependency( 'bufferView', sourceDef.bufferView ).then( function ( bufferView ) {\n\n\t\t\t\tisObjectURL = true;\n\t\t\t\tconst blob = new Blob( [ bufferView ], { type: sourceDef.mimeType } );\n\t\t\t\tsourceURI = URL.createObjectURL( blob );\n\t\t\t\treturn sourceURI;\n\n\t\t\t} );\n\n\t\t} else if ( sourceDef.uri === undefined ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFLoader: Image ' + sourceIndex + ' is missing URI and bufferView' );\n\n\t\t}\n\n\t\tconst promise = Promise.resolve( sourceURI ).then( function ( sourceURI ) {\n\n\t\t\treturn new Promise( function ( resolve, reject ) {\n\n\t\t\t\tlet onLoad = resolve;\n\n\t\t\t\tif ( loader.isImageBitmapLoader === true ) {\n\n\t\t\t\t\tonLoad = function ( imageBitmap ) {\n\n\t\t\t\t\t\tconst texture = new Texture( imageBitmap );\n\t\t\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\t\t\tresolve( texture );\n\n\t\t\t\t\t};\n\n\t\t\t\t}\n\n\t\t\t\tloader.load( LoaderUtils.resolveURL( sourceURI, options.path ), onLoad, undefined, reject );\n\n\t\t\t} );\n\n\t\t} ).then( function ( texture ) {\n\n\t\t\t// Clean up resources and configure Texture.\n\n\t\t\tif ( isObjectURL === true ) {\n\n\t\t\t\tURL.revokeObjectURL( sourceURI );\n\n\t\t\t}\n\n\t\t\tassignExtrasToUserData( texture, sourceDef );\n\n\t\t\ttexture.userData.mimeType = sourceDef.mimeType || getImageURIMimeType( sourceDef.uri );\n\n\t\t\treturn texture;\n\n\t\t} ).catch( function ( error ) {\n\n\t\t\tconsole.error( 'THREE.GLTFLoader: Couldn\\'t load texture', sourceURI );\n\t\t\tthrow error;\n\n\t\t} );\n\n\t\tthis.sourceCache[ sourceIndex ] = promise;\n\t\treturn promise;\n\n\t}\n\n\t/**\n\t * Asynchronously assigns a texture to the given material parameters.\n\t *\n\t * @private\n\t * @param {Object} materialParams\n\t * @param {string} mapName\n\t * @param {Object} mapDef\n\t * @param {string} [colorSpace]\n\t * @return {Promise<Texture>}\n\t */\n\tassignTexture( materialParams, mapName, mapDef, colorSpace ) {\n\n\t\tconst parser = this;\n\n\t\treturn this.getDependency( 'texture', mapDef.index ).then( function ( texture ) {\n\n\t\t\tif ( ! texture ) return null;\n\n\t\t\tif ( mapDef.texCoord !== undefined && mapDef.texCoord > 0 ) {\n\n\t\t\t\ttexture = texture.clone();\n\t\t\t\ttexture.channel = mapDef.texCoord;\n\n\t\t\t}\n\n\t\t\tif ( parser.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ] ) {\n\n\t\t\t\tconst transform = mapDef.extensions !== undefined ? mapDef.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ] : undefined;\n\n\t\t\t\tif ( transform ) {\n\n\t\t\t\t\tconst gltfReference = parser.associations.get( texture );\n\t\t\t\t\ttexture = parser.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ].extendTexture( texture, transform );\n\t\t\t\t\tparser.associations.set( texture, gltfReference );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( colorSpace !== undefined ) {\n\n\t\t\t\ttexture.colorSpace = colorSpace;\n\n\t\t\t}\n\n\t\t\tmaterialParams[ mapName ] = texture;\n\n\t\t\treturn texture;\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Assigns final material to a Mesh, Line, or Points instance. The instance\n\t * already has a material (generated from the glTF material options alone)\n\t * but reuse of the same glTF material may require multiple threejs materials\n\t * to accommodate different primitive types, defines, etc. New materials will\n\t * be created if necessary, and reused from a cache.\n\t *\n\t * @private\n\t * @param {Object3D} mesh Mesh, Line, or Points instance.\n\t */\n\tassignFinalMaterial( mesh ) {\n\n\t\tconst geometry = mesh.geometry;\n\t\tlet material = mesh.material;\n\n\t\tconst useDerivativeTangents = geometry.attributes.tangent === undefined;\n\t\tconst useVertexColors = geometry.attributes.color !== undefined;\n\t\tconst useFlatShading = geometry.attributes.normal === undefined;\n\n\t\tif ( mesh.isPoints ) {\n\n\t\t\tconst cacheKey = 'PointsMaterial:' + material.uuid;\n\n\t\t\tlet pointsMaterial = this.cache.get( cacheKey );\n\n\t\t\tif ( ! pointsMaterial ) {\n\n\t\t\t\tpointsMaterial = new PointsMaterial();\n\t\t\t\tMaterial.prototype.copy.call( pointsMaterial, material );\n\t\t\t\tpointsMaterial.color.copy( material.color );\n\t\t\t\tpointsMaterial.map = material.map;\n\t\t\t\tpointsMaterial.sizeAttenuation = false; // glTF spec says points should be 1px\n\n\t\t\t\tthis.cache.add( cacheKey, pointsMaterial );\n\n\t\t\t}\n\n\t\t\tmaterial = pointsMaterial;\n\n\t\t} else if ( mesh.isLine ) {\n\n\t\t\tconst cacheKey = 'LineBasicMaterial:' + material.uuid;\n\n\t\t\tlet lineMaterial = this.cache.get( cacheKey );\n\n\t\t\tif ( ! lineMaterial ) {\n\n\t\t\t\tlineMaterial = new LineBasicMaterial();\n\t\t\t\tMaterial.prototype.copy.call( lineMaterial, material );\n\t\t\t\tlineMaterial.color.copy( material.color );\n\t\t\t\tlineMaterial.map = material.map;\n\n\t\t\t\tthis.cache.add( cacheKey, lineMaterial );\n\n\t\t\t}\n\n\t\t\tmaterial = lineMaterial;\n\n\t\t}\n\n\t\t// Clone the material if it will be modified\n\t\tif ( useDerivativeTangents || useVertexColors || useFlatShading ) {\n\n\t\t\tlet cacheKey = 'ClonedMaterial:' + material.uuid + ':';\n\n\t\t\tif ( useDerivativeTangents ) cacheKey += 'derivative-tangents:';\n\t\t\tif ( useVertexColors ) cacheKey += 'vertex-colors:';\n\t\t\tif ( useFlatShading ) cacheKey += 'flat-shading:';\n\n\t\t\tlet cachedMaterial = this.cache.get( cacheKey );\n\n\t\t\tif ( ! cachedMaterial ) {\n\n\t\t\t\tcachedMaterial = material.clone();\n\n\t\t\t\tif ( useVertexColors ) cachedMaterial.vertexColors = true;\n\t\t\t\tif ( useFlatShading ) cachedMaterial.flatShading = true;\n\n\t\t\t\tif ( useDerivativeTangents ) {\n\n\t\t\t\t\t// https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995\n\t\t\t\t\tif ( cachedMaterial.normalScale ) cachedMaterial.normalScale.y *= - 1;\n\t\t\t\t\tif ( cachedMaterial.clearcoatNormalScale ) cachedMaterial.clearcoatNormalScale.y *= - 1;\n\n\t\t\t\t}\n\n\t\t\t\tthis.cache.add( cacheKey, cachedMaterial );\n\n\t\t\t\tthis.associations.set( cachedMaterial, this.associations.get( material ) );\n\n\t\t\t}\n\n\t\t\tmaterial = cachedMaterial;\n\n\t\t}\n\n\t\tmesh.material = material;\n\n\t}\n\n\tgetMaterialType( /* materialIndex */ ) {\n\n\t\treturn MeshStandardMaterial;\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials\n\t *\n\t * @private\n\t * @param {number} materialIndex\n\t * @return {Promise<Material>}\n\t */\n\tloadMaterial( materialIndex ) {\n\n\t\tconst parser = this;\n\t\tconst json = this.json;\n\t\tconst extensions = this.extensions;\n\t\tconst materialDef = json.materials[ materialIndex ];\n\n\t\tlet materialType;\n\t\tconst materialParams = {};\n\t\tconst materialExtensions = materialDef.extensions || {};\n\n\t\tconst pending = [];\n\n\t\tif ( materialExtensions[ EXTENSIONS.KHR_MATERIALS_UNLIT ] ) {\n\n\t\t\tconst kmuExtension = extensions[ EXTENSIONS.KHR_MATERIALS_UNLIT ];\n\t\t\tmaterialType = kmuExtension.getMaterialType();\n\t\t\tpending.push( kmuExtension.extendParams( materialParams, materialDef, parser ) );\n\n\t\t} else {\n\n\t\t\t// Specification:\n\t\t\t// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#metallic-roughness-material\n\n\t\t\tconst metallicRoughness = materialDef.pbrMetallicRoughness || {};\n\n\t\t\tmaterialParams.color = new Color( 1.0, 1.0, 1.0 );\n\t\t\tmaterialParams.opacity = 1.0;\n\n\t\t\tif ( Array.isArray( metallicRoughness.baseColorFactor ) ) {\n\n\t\t\t\tconst array = metallicRoughness.baseColorFactor;\n\n\t\t\t\tmaterialParams.color.setRGB( array[ 0 ], array[ 1 ], array[ 2 ], LinearSRGBColorSpace );\n\t\t\t\tmaterialParams.opacity = array[ 3 ];\n\n\t\t\t}\n\n\t\t\tif ( metallicRoughness.baseColorTexture !== undefined ) {\n\n\t\t\t\tpending.push( parser.assignTexture( materialParams, 'map', metallicRoughness.baseColorTexture, SRGBColorSpace ) );\n\n\t\t\t}\n\n\t\t\tmaterialParams.metalness = metallicRoughness.metallicFactor !== undefined ? metallicRoughness.metallicFactor : 1.0;\n\t\t\tmaterialParams.roughness = metallicRoughness.roughnessFactor !== undefined ? metallicRoughness.roughnessFactor : 1.0;\n\n\t\t\tif ( metallicRoughness.metallicRoughnessTexture !== undefined ) {\n\n\t\t\t\tpending.push( parser.assignTexture( materialParams, 'metalnessMap', metallicRoughness.metallicRoughnessTexture ) );\n\t\t\t\tpending.push( parser.assignTexture( materialParams, 'roughnessMap', metallicRoughness.metallicRoughnessTexture ) );\n\n\t\t\t}\n\n\t\t\tmaterialType = this._invokeOne( function ( ext ) {\n\n\t\t\t\treturn ext.getMaterialType && ext.getMaterialType( materialIndex );\n\n\t\t\t} );\n\n\t\t\tpending.push( Promise.all( this._invokeAll( function ( ext ) {\n\n\t\t\t\treturn ext.extendMaterialParams && ext.extendMaterialParams( materialIndex, materialParams );\n\n\t\t\t} ) ) );\n\n\t\t}\n\n\t\tif ( materialDef.doubleSided === true ) {\n\n\t\t\tmaterialParams.side = DoubleSide;\n\n\t\t}\n\n\t\tconst alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;\n\n\t\tif ( alphaMode === ALPHA_MODES.BLEND ) {\n\n\t\t\tmaterialParams.transparent = true;\n\n\t\t\t// See: https://github.com/mrdoob/three.js/issues/17706\n\t\t\tmaterialParams.depthWrite = false;\n\n\t\t} else {\n\n\t\t\tmaterialParams.transparent = false;\n\n\t\t\tif ( alphaMode === ALPHA_MODES.MASK ) {\n\n\t\t\t\tmaterialParams.alphaTest = materialDef.alphaCutoff !== undefined ? materialDef.alphaCutoff : 0.5;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( materialDef.normalTexture !== undefined && materialType !== MeshBasicMaterial ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'normalMap', materialDef.normalTexture ) );\n\n\t\t\tmaterialParams.normalScale = new Vector2( 1, 1 );\n\n\t\t\tif ( materialDef.normalTexture.scale !== undefined ) {\n\n\t\t\t\tconst scale = materialDef.normalTexture.scale;\n\n\t\t\t\tmaterialParams.normalScale.set( scale, scale );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( materialDef.occlusionTexture !== undefined && materialType !== MeshBasicMaterial ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'aoMap', materialDef.occlusionTexture ) );\n\n\t\t\tif ( materialDef.occlusionTexture.strength !== undefined ) {\n\n\t\t\t\tmaterialParams.aoMapIntensity = materialDef.occlusionTexture.strength;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( materialDef.emissiveFactor !== undefined && materialType !== MeshBasicMaterial ) {\n\n\t\t\tconst emissiveFactor = materialDef.emissiveFactor;\n\t\t\tmaterialParams.emissive = new Color().setRGB( emissiveFactor[ 0 ], emissiveFactor[ 1 ], emissiveFactor[ 2 ], LinearSRGBColorSpace );\n\n\t\t}\n\n\t\tif ( materialDef.emissiveTexture !== undefined && materialType !== MeshBasicMaterial ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'emissiveMap', materialDef.emissiveTexture, SRGBColorSpace ) );\n\n\t\t}\n\n\t\treturn Promise.all( pending ).then( function () {\n\n\t\t\tconst material = new materialType( materialParams );\n\n\t\t\tif ( materialDef.name ) material.name = materialDef.name;\n\n\t\t\tassignExtrasToUserData( material, materialDef );\n\n\t\t\tparser.associations.set( material, { materials: materialIndex } );\n\n\t\t\tif ( materialDef.extensions ) addUnknownExtensionsToUserData( extensions, material, materialDef );\n\n\t\t\treturn material;\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * When Object3D instances are targeted by animation, they need unique names.\n\t *\n\t * @private\n\t * @param {string} originalName\n\t * @return {string}\n\t */\n\tcreateUniqueName( originalName ) {\n\n\t\tconst sanitizedName = PropertyBinding.sanitizeNodeName( originalName || '' );\n\n\t\tif ( sanitizedName in this.nodeNamesUsed ) {\n\n\t\t\treturn sanitizedName + '_' + ( ++ this.nodeNamesUsed[ sanitizedName ] );\n\n\t\t} else {\n\n\t\t\tthis.nodeNamesUsed[ sanitizedName ] = 0;\n\n\t\t\treturn sanitizedName;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry\n\t *\n\t * Creates BufferGeometries from primitives.\n\t *\n\t * @private\n\t * @param {Array<GLTF.Primitive>} primitives\n\t * @return {Promise<Array<BufferGeometry>>}\n\t */\n\tloadGeometries( primitives ) {\n\n\t\tconst parser = this;\n\t\tconst extensions = this.extensions;\n\t\tconst cache = this.primitiveCache;\n\n\t\tfunction createDracoPrimitive( primitive ) {\n\n\t\t\treturn extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ]\n\t\t\t\t.decodePrimitive( primitive, parser )\n\t\t\t\t.then( function ( geometry ) {\n\n\t\t\t\t\treturn addPrimitiveAttributes( geometry, primitive, parser );\n\n\t\t\t\t} );\n\n\t\t}\n\n\t\tconst pending = [];\n\n\t\tfor ( let i = 0, il = primitives.length; i < il; i ++ ) {\n\n\t\t\tconst primitive = primitives[ i ];\n\t\t\tconst cacheKey = createPrimitiveKey( primitive );\n\n\t\t\t// See if we've already created this geometry\n\t\t\tconst cached = cache[ cacheKey ];\n\n\t\t\tif ( cached ) {\n\n\t\t\t\t// Use the cached geometry if it exists\n\t\t\t\tpending.push( cached.promise );\n\n\t\t\t} else {\n\n\t\t\t\tlet geometryPromise;\n\n\t\t\t\tif ( primitive.extensions && primitive.extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ] ) {\n\n\t\t\t\t\t// Use DRACO geometry if available\n\t\t\t\t\tgeometryPromise = createDracoPrimitive( primitive );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// Otherwise create a new geometry\n\t\t\t\t\tgeometryPromise = addPrimitiveAttributes( new BufferGeometry(), primitive, parser );\n\n\t\t\t\t}\n\n\t\t\t\t// Cache this geometry\n\t\t\t\tcache[ cacheKey ] = { primitive: primitive, promise: geometryPromise };\n\n\t\t\t\tpending.push( geometryPromise );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes\n\t *\n\t * @private\n\t * @param {number} meshIndex\n\t * @return {Promise<Group|Mesh|SkinnedMesh|Line|Points>}\n\t */\n\tloadMesh( meshIndex ) {\n\n\t\tconst parser = this;\n\t\tconst json = this.json;\n\t\tconst extensions = this.extensions;\n\n\t\tconst meshDef = json.meshes[ meshIndex ];\n\t\tconst primitives = meshDef.primitives;\n\n\t\tconst pending = [];\n\n\t\tfor ( let i = 0, il = primitives.length; i < il; i ++ ) {\n\n\t\t\tconst material = primitives[ i ].material === undefined\n\t\t\t\t? createDefaultMaterial( this.cache )\n\t\t\t\t: this.getDependency( 'material', primitives[ i ].material );\n\n\t\t\tpending.push( material );\n\n\t\t}\n\n\t\tpending.push( parser.loadGeometries( primitives ) );\n\n\t\treturn Promise.all( pending ).then( function ( results ) {\n\n\t\t\tconst materials = results.slice( 0, results.length - 1 );\n\t\t\tconst geometries = results[ results.length - 1 ];\n\n\t\t\tconst meshes = [];\n\n\t\t\tfor ( let i = 0, il = geometries.length; i < il; i ++ ) {\n\n\t\t\t\tconst geometry = geometries[ i ];\n\t\t\t\tconst primitive = primitives[ i ];\n\n\t\t\t\t// 1. create Mesh\n\n\t\t\t\tlet mesh;\n\n\t\t\t\tconst material = materials[ i ];\n\n\t\t\t\tif ( primitive.mode === WEBGL_CONSTANTS.TRIANGLES ||\n\t\t\t\t\t\tprimitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ||\n\t\t\t\t\t\tprimitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ||\n\t\t\t\t\t\tprimitive.mode === undefined ) {\n\n\t\t\t\t\t// .isSkinnedMesh isn't in glTF spec. See ._markDefs()\n\t\t\t\t\tmesh = meshDef.isSkinnedMesh === true\n\t\t\t\t\t\t? new SkinnedMesh( geometry, material )\n\t\t\t\t\t\t: new Mesh( geometry, material );\n\n\t\t\t\t\tif ( mesh.isSkinnedMesh === true ) {\n\n\t\t\t\t\t\t// normalize skin weights to fix malformed assets (see #15319)\n\t\t\t\t\t\tmesh.normalizeSkinWeights();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ) {\n\n\t\t\t\t\t\tmesh.geometry = toTrianglesDrawMode( mesh.geometry, TriangleStripDrawMode );\n\n\t\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ) {\n\n\t\t\t\t\t\tmesh.geometry = toTrianglesDrawMode( mesh.geometry, TriangleFanDrawMode );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.LINES ) {\n\n\t\t\t\t\tmesh = new LineSegments( geometry, material );\n\n\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.LINE_STRIP ) {\n\n\t\t\t\t\tmesh = new Line( geometry, material );\n\n\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.LINE_LOOP ) {\n\n\t\t\t\t\tmesh = new LineLoop( geometry, material );\n\n\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.POINTS ) {\n\n\t\t\t\t\tmesh = new Points( geometry, material );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrow new Error( 'THREE.GLTFLoader: Primitive mode unsupported: ' + primitive.mode );\n\n\t\t\t\t}\n\n\t\t\t\tif ( Object.keys( mesh.geometry.morphAttributes ).length > 0 ) {\n\n\t\t\t\t\tupdateMorphTargets( mesh, meshDef );\n\n\t\t\t\t}\n\n\t\t\t\tmesh.name = parser.createUniqueName( meshDef.name || ( 'mesh_' + meshIndex ) );\n\n\t\t\t\tassignExtrasToUserData( mesh, meshDef );\n\n\t\t\t\tif ( primitive.extensions ) addUnknownExtensionsToUserData( extensions, mesh, primitive );\n\n\t\t\t\tparser.assignFinalMaterial( mesh );\n\n\t\t\t\tmeshes.push( mesh );\n\n\t\t\t}\n\n\t\t\tfor ( let i = 0, il = meshes.length; i < il; i ++ ) {\n\n\t\t\t\tparser.associations.set( meshes[ i ], {\n\t\t\t\t\tmeshes: meshIndex,\n\t\t\t\t\tprimitives: i\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tif ( meshes.length === 1 ) {\n\n\t\t\t\tif ( meshDef.extensions ) addUnknownExtensionsToUserData( extensions, meshes[ 0 ], meshDef );\n\n\t\t\t\treturn meshes[ 0 ];\n\n\t\t\t}\n\n\t\t\tconst group = new Group();\n\n\t\t\tif ( meshDef.extensions ) addUnknownExtensionsToUserData( extensions, group, meshDef );\n\n\t\t\tparser.associations.set( group, { meshes: meshIndex } );\n\n\t\t\tfor ( let i = 0, il = meshes.length; i < il; i ++ ) {\n\n\t\t\t\tgroup.add( meshes[ i ] );\n\n\t\t\t}\n\n\t\t\treturn group;\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras\n\t *\n\t * @private\n\t * @param {number} cameraIndex\n\t * @return {Promise<Camera>|undefined}\n\t */\n\tloadCamera( cameraIndex ) {\n\n\t\tlet camera;\n\t\tconst cameraDef = this.json.cameras[ cameraIndex ];\n\t\tconst params = cameraDef[ cameraDef.type ];\n\n\t\tif ( ! params ) {\n\n\t\t\tconsole.warn( 'THREE.GLTFLoader: Missing camera parameters.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( cameraDef.type === 'perspective' ) {\n\n\t\t\tcamera = new PerspectiveCamera( MathUtils.radToDeg( params.yfov ), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6 );\n\n\t\t} else if ( cameraDef.type === 'orthographic' ) {\n\n\t\t\tcamera = new OrthographicCamera( - params.xmag, params.xmag, params.ymag, - params.ymag, params.znear, params.zfar );\n\n\t\t}\n\n\t\tif ( cameraDef.name ) camera.name = this.createUniqueName( cameraDef.name );\n\n\t\tassignExtrasToUserData( camera, cameraDef );\n\n\t\treturn Promise.resolve( camera );\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins\n\t *\n\t * @private\n\t * @param {number} skinIndex\n\t * @return {Promise<Skeleton>}\n\t */\n\tloadSkin( skinIndex ) {\n\n\t\tconst skinDef = this.json.skins[ skinIndex ];\n\n\t\tconst pending = [];\n\n\t\tfor ( let i = 0, il = skinDef.joints.length; i < il; i ++ ) {\n\n\t\t\tpending.push( this._loadNodeShallow( skinDef.joints[ i ] ) );\n\n\t\t}\n\n\t\tif ( skinDef.inverseBindMatrices !== undefined ) {\n\n\t\t\tpending.push( this.getDependency( 'accessor', skinDef.inverseBindMatrices ) );\n\n\t\t} else {\n\n\t\t\tpending.push( null );\n\n\t\t}\n\n\t\treturn Promise.all( pending ).then( function ( results ) {\n\n\t\t\tconst inverseBindMatrices = results.pop();\n\t\t\tconst jointNodes = results;\n\n\t\t\t// Note that bones (joint nodes) may or may not be in the\n\t\t\t// scene graph at this time.\n\n\t\t\tconst bones = [];\n\t\t\tconst boneInverses = [];\n\n\t\t\tfor ( let i = 0, il = jointNodes.length; i < il; i ++ ) {\n\n\t\t\t\tconst jointNode = jointNodes[ i ];\n\n\t\t\t\tif ( jointNode ) {\n\n\t\t\t\t\tbones.push( jointNode );\n\n\t\t\t\t\tconst mat = new Matrix4();\n\n\t\t\t\t\tif ( inverseBindMatrices !== null ) {\n\n\t\t\t\t\t\tmat.fromArray( inverseBindMatrices.array, i * 16 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tboneInverses.push( mat );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Joint \"%s\" could not be found.', skinDef.joints[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn new Skeleton( bones, boneInverses );\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations\n\t *\n\t * @private\n\t * @param {number} animationIndex\n\t * @return {Promise<AnimationClip>}\n\t */\n\tloadAnimation( animationIndex ) {\n\n\t\tconst json = this.json;\n\t\tconst parser = this;\n\n\t\tconst animationDef = json.animations[ animationIndex ];\n\t\tconst animationName = animationDef.name ? animationDef.name : 'animation_' + animationIndex;\n\n\t\tconst pendingNodes = [];\n\t\tconst pendingInputAccessors = [];\n\t\tconst pendingOutputAccessors = [];\n\t\tconst pendingSamplers = [];\n\t\tconst pendingTargets = [];\n\n\t\tfor ( let i = 0, il = animationDef.channels.length; i < il; i ++ ) {\n\n\t\t\tconst channel = animationDef.channels[ i ];\n\t\t\tconst sampler = animationDef.samplers[ channel.sampler ];\n\t\t\tconst target = channel.target;\n\t\t\tconst name = target.node;\n\t\t\tconst input = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.input ] : sampler.input;\n\t\t\tconst output = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.output ] : sampler.output;\n\n\t\t\tif ( target.node === undefined ) continue;\n\n\t\t\tpendingNodes.push( this.getDependency( 'node', name ) );\n\t\t\tpendingInputAccessors.push( this.getDependency( 'accessor', input ) );\n\t\t\tpendingOutputAccessors.push( this.getDependency( 'accessor', output ) );\n\t\t\tpendingSamplers.push( sampler );\n\t\t\tpendingTargets.push( target );\n\n\t\t}\n\n\t\treturn Promise.all( [\n\n\t\t\tPromise.all( pendingNodes ),\n\t\t\tPromise.all( pendingInputAccessors ),\n\t\t\tPromise.all( pendingOutputAccessors ),\n\t\t\tPromise.all( pendingSamplers ),\n\t\t\tPromise.all( pendingTargets )\n\n\t\t] ).then( function ( dependencies ) {\n\n\t\t\tconst nodes = dependencies[ 0 ];\n\t\t\tconst inputAccessors = dependencies[ 1 ];\n\t\t\tconst outputAccessors = dependencies[ 2 ];\n\t\t\tconst samplers = dependencies[ 3 ];\n\t\t\tconst targets = dependencies[ 4 ];\n\n\t\t\tconst tracks = [];\n\n\t\t\tfor ( let i = 0, il = nodes.length; i < il; i ++ ) {\n\n\t\t\t\tconst node = nodes[ i ];\n\t\t\t\tconst inputAccessor = inputAccessors[ i ];\n\t\t\t\tconst outputAccessor = outputAccessors[ i ];\n\t\t\t\tconst sampler = samplers[ i ];\n\t\t\t\tconst target = targets[ i ];\n\n\t\t\t\tif ( node === undefined ) continue;\n\n\t\t\t\tif ( node.updateMatrix ) {\n\n\t\t\t\t\tnode.updateMatrix();\n\n\t\t\t\t}\n\n\t\t\t\tconst createdTracks = parser._createAnimationTracks( node, inputAccessor, outputAccessor, sampler, target );\n\n\t\t\t\tif ( createdTracks ) {\n\n\t\t\t\t\tfor ( let k = 0; k < createdTracks.length; k ++ ) {\n\n\t\t\t\t\t\ttracks.push( createdTracks[ k ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst animation = new AnimationClip( animationName, undefined, tracks );\n\n\t\t\tassignExtrasToUserData( animation, animationDef );\n\n\t\t\treturn animation;\n\n\t\t} );\n\n\t}\n\n\tcreateNodeMesh( nodeIndex ) {\n\n\t\tconst json = this.json;\n\t\tconst parser = this;\n\t\tconst nodeDef = json.nodes[ nodeIndex ];\n\n\t\tif ( nodeDef.mesh === undefined ) return null;\n\n\t\treturn parser.getDependency( 'mesh', nodeDef.mesh ).then( function ( mesh ) {\n\n\t\t\tconst node = parser._getNodeRef( parser.meshCache, nodeDef.mesh, mesh );\n\n\t\t\t// if weights are provided on the node, override weights on the mesh.\n\t\t\tif ( nodeDef.weights !== undefined ) {\n\n\t\t\t\tnode.traverse( function ( o ) {\n\n\t\t\t\t\tif ( ! o.isMesh ) return;\n\n\t\t\t\t\tfor ( let i = 0, il = nodeDef.weights.length; i < il; i ++ ) {\n\n\t\t\t\t\t\to.morphTargetInfluences[ i ] = nodeDef.weights[ i ];\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\treturn node;\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy\n\t *\n\t * @private\n\t * @param {number} nodeIndex\n\t * @return {Promise<Object3D>}\n\t */\n\tloadNode( nodeIndex ) {\n\n\t\tconst json = this.json;\n\t\tconst parser = this;\n\n\t\tconst nodeDef = json.nodes[ nodeIndex ];\n\n\t\tconst nodePending = parser._loadNodeShallow( nodeIndex );\n\n\t\tconst childPending = [];\n\t\tconst childrenDef = nodeDef.children || [];\n\n\t\tfor ( let i = 0, il = childrenDef.length; i < il; i ++ ) {\n\n\t\t\tchildPending.push( parser.getDependency( 'node', childrenDef[ i ] ) );\n\n\t\t}\n\n\t\tconst skeletonPending = nodeDef.skin === undefined\n\t\t\t? Promise.resolve( null )\n\t\t\t: parser.getDependency( 'skin', nodeDef.skin );\n\n\t\treturn Promise.all( [\n\t\t\tnodePending,\n\t\t\tPromise.all( childPending ),\n\t\t\tskeletonPending\n\t\t] ).then( function ( results ) {\n\n\t\t\tconst node = results[ 0 ];\n\t\t\tconst children = results[ 1 ];\n\t\t\tconst skeleton = results[ 2 ];\n\n\t\t\tif ( skeleton !== null ) {\n\n\t\t\t\t// This full traverse should be fine because\n\t\t\t\t// child glTF nodes have not been added to this node yet.\n\t\t\t\tnode.traverse( function ( mesh ) {\n\n\t\t\t\t\tif ( ! mesh.isSkinnedMesh ) return;\n\n\t\t\t\t\tmesh.bind( skeleton, _identityMatrix );\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tfor ( let i = 0, il = children.length; i < il; i ++ ) {\n\n\t\t\t\tnode.add( children[ i ] );\n\n\t\t\t}\n\n\t\t\treturn node;\n\n\t\t} );\n\n\t}\n\n\t// ._loadNodeShallow() parses a single node.\n\t// skin and child nodes are created and added in .loadNode() (no '_' prefix).\n\t_loadNodeShallow( nodeIndex ) {\n\n\t\tconst json = this.json;\n\t\tconst extensions = this.extensions;\n\t\tconst parser = this;\n\n\t\t// This method is called from .loadNode() and .loadSkin().\n\t\t// Cache a node to avoid duplication.\n\n\t\tif ( this.nodeCache[ nodeIndex ] !== undefined ) {\n\n\t\t\treturn this.nodeCache[ nodeIndex ];\n\n\t\t}\n\n\t\tconst nodeDef = json.nodes[ nodeIndex ];\n\n\t\t// reserve node's name before its dependencies, so the root has the intended name.\n\t\tconst nodeName = nodeDef.name ? parser.createUniqueName( nodeDef.name ) : '';\n\n\t\tconst pending = [];\n\n\t\tconst meshPromise = parser._invokeOne( function ( ext ) {\n\n\t\t\treturn ext.createNodeMesh && ext.createNodeMesh( nodeIndex );\n\n\t\t} );\n\n\t\tif ( meshPromise ) {\n\n\t\t\tpending.push( meshPromise );\n\n\t\t}\n\n\t\tif ( nodeDef.camera !== undefined ) {\n\n\t\t\tpending.push( parser.getDependency( 'camera', nodeDef.camera ).then( function ( camera ) {\n\n\t\t\t\treturn parser._getNodeRef( parser.cameraCache, nodeDef.camera, camera );\n\n\t\t\t} ) );\n\n\t\t}\n\n\t\tparser._invokeAll( function ( ext ) {\n\n\t\t\treturn ext.createNodeAttachment && ext.createNodeAttachment( nodeIndex );\n\n\t\t} ).forEach( function ( promise ) {\n\n\t\t\tpending.push( promise );\n\n\t\t} );\n\n\t\tthis.nodeCache[ nodeIndex ] = Promise.all( pending ).then( function ( objects ) {\n\n\t\t\tlet node;\n\n\t\t\t// .isBone isn't in glTF spec. See ._markDefs\n\t\t\tif ( nodeDef.isBone === true ) {\n\n\t\t\t\tnode = new Bone();\n\n\t\t\t} else if ( objects.length > 1 ) {\n\n\t\t\t\tnode = new Group();\n\n\t\t\t} else if ( objects.length === 1 ) {\n\n\t\t\t\tnode = objects[ 0 ];\n\n\t\t\t} else {\n\n\t\t\t\tnode = new Object3D();\n\n\t\t\t}\n\n\t\t\tif ( node !== objects[ 0 ] ) {\n\n\t\t\t\tfor ( let i = 0, il = objects.length; i < il; i ++ ) {\n\n\t\t\t\t\tnode.add( objects[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( nodeDef.name ) {\n\n\t\t\t\tnode.userData.name = nodeDef.name;\n\t\t\t\tnode.name = nodeName;\n\n\t\t\t}\n\n\t\t\tassignExtrasToUserData( node, nodeDef );\n\n\t\t\tif ( nodeDef.extensions ) addUnknownExtensionsToUserData( extensions, node, nodeDef );\n\n\t\t\tif ( nodeDef.matrix !== undefined ) {\n\n\t\t\t\tconst matrix = new Matrix4();\n\t\t\t\tmatrix.fromArray( nodeDef.matrix );\n\t\t\t\tnode.applyMatrix4( matrix );\n\n\t\t\t} else {\n\n\t\t\t\tif ( nodeDef.translation !== undefined ) {\n\n\t\t\t\t\tnode.position.fromArray( nodeDef.translation );\n\n\t\t\t\t}\n\n\t\t\t\tif ( nodeDef.rotation !== undefined ) {\n\n\t\t\t\t\tnode.quaternion.fromArray( nodeDef.rotation );\n\n\t\t\t\t}\n\n\t\t\t\tif ( nodeDef.scale !== undefined ) {\n\n\t\t\t\t\tnode.scale.fromArray( nodeDef.scale );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( ! parser.associations.has( node ) ) {\n\n\t\t\t\tparser.associations.set( node, {} );\n\n\t\t\t} else if ( nodeDef.mesh !== undefined && parser.meshCache.refs[ nodeDef.mesh ] > 1 ) {\n\n\t\t\t\tconst mapping = parser.associations.get( node );\n\t\t\t\tparser.associations.set( node, { ...mapping } );\n\n\t\t\t}\n\n\t\t\tparser.associations.get( node ).nodes = nodeIndex;\n\n\t\t\treturn node;\n\n\t\t} );\n\n\t\treturn this.nodeCache[ nodeIndex ];\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes\n\t *\n\t * @private\n\t * @param {number} sceneIndex\n\t * @return {Promise<Group>}\n\t */\n\tloadScene( sceneIndex ) {\n\n\t\tconst extensions = this.extensions;\n\t\tconst sceneDef = this.json.scenes[ sceneIndex ];\n\t\tconst parser = this;\n\n\t\t// Loader returns Group, not Scene.\n\t\t// See: https://github.com/mrdoob/three.js/issues/18342#issuecomment-578981172\n\t\tconst scene = new Group();\n\t\tif ( sceneDef.name ) scene.name = parser.createUniqueName( sceneDef.name );\n\n\t\tassignExtrasToUserData( scene, sceneDef );\n\n\t\tif ( sceneDef.extensions ) addUnknownExtensionsToUserData( extensions, scene, sceneDef );\n\n\t\tconst nodeIds = sceneDef.nodes || [];\n\n\t\tconst pending = [];\n\n\t\tfor ( let i = 0, il = nodeIds.length; i < il; i ++ ) {\n\n\t\t\tpending.push( parser.getDependency( 'node', nodeIds[ i ] ) );\n\n\t\t}\n\n\t\treturn Promise.all( pending ).then( function ( nodes ) {\n\n\t\t\tfor ( let i = 0, il = nodes.length; i < il; i ++ ) {\n\n\t\t\t\tscene.add( nodes[ i ] );\n\n\t\t\t}\n\n\t\t\t// Removes dangling associations, associations that reference a node that\n\t\t\t// didn't make it into the scene.\n\t\t\tconst reduceAssociations = ( node ) => {\n\n\t\t\t\tconst reducedAssociations = new Map();\n\n\t\t\t\tfor ( const [ key, value ] of parser.associations ) {\n\n\t\t\t\t\tif ( key instanceof Material || key instanceof Texture ) {\n\n\t\t\t\t\t\treducedAssociations.set( key, value );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tnode.traverse( ( node ) => {\n\n\t\t\t\t\tconst mappings = parser.associations.get( node );\n\n\t\t\t\t\tif ( mappings != null ) {\n\n\t\t\t\t\t\treducedAssociations.set( node, mappings );\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\treturn reducedAssociations;\n\n\t\t\t};\n\n\t\t\tparser.associations = reduceAssociations( scene );\n\n\t\t\treturn scene;\n\n\t\t} );\n\n\t}\n\n\t_createAnimationTracks( node, inputAccessor, outputAccessor, sampler, target ) {\n\n\t\tconst tracks = [];\n\n\t\tconst targetName = node.name ? node.name : node.uuid;\n\t\tconst targetNames = [];\n\n\t\tif ( PATH_PROPERTIES[ target.path ] === PATH_PROPERTIES.weights ) {\n\n\t\t\tnode.traverse( function ( object ) {\n\n\t\t\t\tif ( object.morphTargetInfluences ) {\n\n\t\t\t\t\ttargetNames.push( object.name ? object.name : object.uuid );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t} else {\n\n\t\t\ttargetNames.push( targetName );\n\n\t\t}\n\n\t\tlet TypedKeyframeTrack;\n\n\t\tswitch ( PATH_PROPERTIES[ target.path ] ) {\n\n\t\t\tcase PATH_PROPERTIES.weights:\n\n\t\t\t\tTypedKeyframeTrack = NumberKeyframeTrack;\n\t\t\t\tbreak;\n\n\t\t\tcase PATH_PROPERTIES.rotation:\n\n\t\t\t\tTypedKeyframeTrack = QuaternionKeyframeTrack;\n\t\t\t\tbreak;\n\n\t\t\tcase PATH_PROPERTIES.translation:\n\t\t\tcase PATH_PROPERTIES.scale:\n\n\t\t\t\tTypedKeyframeTrack = VectorKeyframeTrack;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\n\t\t\t\tswitch ( outputAccessor.itemSize ) {\n\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tTypedKeyframeTrack = NumberKeyframeTrack;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\tcase 3:\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tTypedKeyframeTrack = VectorKeyframeTrack;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\tconst interpolation = sampler.interpolation !== undefined ? INTERPOLATION[ sampler.interpolation ] : InterpolateLinear;\n\n\n\t\tconst outputArray = this._getArrayFromAccessor( outputAccessor );\n\n\t\tfor ( let j = 0, jl = targetNames.length; j < jl; j ++ ) {\n\n\t\t\tconst track = new TypedKeyframeTrack(\n\t\t\t\ttargetNames[ j ] + '.' + PATH_PROPERTIES[ target.path ],\n\t\t\t\tinputAccessor.array,\n\t\t\t\toutputArray,\n\t\t\t\tinterpolation\n\t\t\t);\n\n\t\t\t// Override interpolation with custom factory method.\n\t\t\tif ( sampler.interpolation === 'CUBICSPLINE' ) {\n\n\t\t\t\tthis._createCubicSplineTrackInterpolant( track );\n\n\t\t\t}\n\n\t\t\ttracks.push( track );\n\n\t\t}\n\n\t\treturn tracks;\n\n\t}\n\n\t_getArrayFromAccessor( accessor ) {\n\n\t\tlet outputArray = accessor.array;\n\n\t\tif ( accessor.normalized ) {\n\n\t\t\tconst scale = getNormalizedComponentScale( outputArray.constructor );\n\t\t\tconst scaled = new Float32Array( outputArray.length );\n\n\t\t\tfor ( let j = 0, jl = outputArray.length; j < jl; j ++ ) {\n\n\t\t\t\tscaled[ j ] = outputArray[ j ] * scale;\n\n\t\t\t}\n\n\t\t\toutputArray = scaled;\n\n\t\t}\n\n\t\treturn outputArray;\n\n\t}\n\n\t_createCubicSplineTrackInterpolant( track ) {\n\n\t\ttrack.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline( result ) {\n\n\t\t\t// A CUBICSPLINE keyframe in glTF has three output values for each input value,\n\t\t\t// representing inTangent, splineVertex, and outTangent. As a result, track.getValueSize()\n\t\t\t// must be divided by three to get the interpolant's sampleSize argument.\n\n\t\t\tconst interpolantType = ( this instanceof QuaternionKeyframeTrack ) ? GLTFCubicSplineQuaternionInterpolant : GLTFCubicSplineInterpolant;\n\n\t\t\treturn new interpolantType( this.times, this.values, this.getValueSize() / 3, result );\n\n\t\t};\n\n\t\t// Mark as CUBICSPLINE. `track.getInterpolation()` doesn't support custom interpolants.\n\t\ttrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;\n\n\t}\n\n}\n\n/**\n *\n * @private\n * @param {BufferGeometry} geometry\n * @param {GLTF.Primitive} primitiveDef\n * @param {GLTFParser} parser\n */\nfunction computeBounds( geometry, primitiveDef, parser ) {\n\n\tconst attributes = primitiveDef.attributes;\n\n\tconst box = new Box3();\n\n\tif ( attributes.POSITION !== undefined ) {\n\n\t\tconst accessor = parser.json.accessors[ attributes.POSITION ];\n\n\t\tconst min = accessor.min;\n\t\tconst max = accessor.max;\n\n\t\t// glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.\n\n\t\tif ( min !== undefined && max !== undefined ) {\n\n\t\t\tbox.set(\n\t\t\t\tnew Vector3( min[ 0 ], min[ 1 ], min[ 2 ] ),\n\t\t\t\tnew Vector3( max[ 0 ], max[ 1 ], max[ 2 ] )\n\t\t\t);\n\n\t\t\tif ( accessor.normalized ) {\n\n\t\t\t\tconst boxScale = getNormalizedComponentScale( WEBGL_COMPONENT_TYPES[ accessor.componentType ] );\n\t\t\t\tbox.min.multiplyScalar( boxScale );\n\t\t\t\tbox.max.multiplyScalar( boxScale );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.GLTFLoader: Missing min/max properties for accessor POSITION.' );\n\n\t\t\treturn;\n\n\t\t}\n\n\t} else {\n\n\t\treturn;\n\n\t}\n\n\tconst targets = primitiveDef.targets;\n\n\tif ( targets !== undefined ) {\n\n\t\tconst maxDisplacement = new Vector3();\n\t\tconst vector = new Vector3();\n\n\t\tfor ( let i = 0, il = targets.length; i < il; i ++ ) {\n\n\t\t\tconst target = targets[ i ];\n\n\t\t\tif ( target.POSITION !== undefined ) {\n\n\t\t\t\tconst accessor = parser.json.accessors[ target.POSITION ];\n\t\t\t\tconst min = accessor.min;\n\t\t\t\tconst max = accessor.max;\n\n\t\t\t\t// glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.\n\n\t\t\t\tif ( min !== undefined && max !== undefined ) {\n\n\t\t\t\t\t// we need to get max of absolute components because target weight is [-1,1]\n\t\t\t\t\tvector.setX( Math.max( Math.abs( min[ 0 ] ), Math.abs( max[ 0 ] ) ) );\n\t\t\t\t\tvector.setY( Math.max( Math.abs( min[ 1 ] ), Math.abs( max[ 1 ] ) ) );\n\t\t\t\t\tvector.setZ( Math.max( Math.abs( min[ 2 ] ), Math.abs( max[ 2 ] ) ) );\n\n\n\t\t\t\t\tif ( accessor.normalized ) {\n\n\t\t\t\t\t\tconst boxScale = getNormalizedComponentScale( WEBGL_COMPONENT_TYPES[ accessor.componentType ] );\n\t\t\t\t\t\tvector.multiplyScalar( boxScale );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Note: this assumes that the sum of all weights is at most 1. This isn't quite correct - it's more conservative\n\t\t\t\t\t// to assume that each target can have a max weight of 1. However, for some use cases - notably, when morph targets\n\t\t\t\t\t// are used to implement key-frame animations and as such only two are active at a time - this results in very large\n\t\t\t\t\t// boxes. So for now we make a box that's sometimes a touch too small but is hopefully mostly of reasonable size.\n\t\t\t\t\tmaxDisplacement.max( vector );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Missing min/max properties for accessor POSITION.' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// As per comment above this box isn't conservative, but has a reasonable size for a very large number of morph targets.\n\t\tbox.expandByVector( maxDisplacement );\n\n\t}\n\n\tgeometry.boundingBox = box;\n\n\tconst sphere = new Sphere();\n\n\tbox.getCenter( sphere.center );\n\tsphere.radius = box.min.distanceTo( box.max ) / 2;\n\n\tgeometry.boundingSphere = sphere;\n\n}\n\n/**\n *\n * @private\n * @param {BufferGeometry} geometry\n * @param {GLTF.Primitive} primitiveDef\n * @param {GLTFParser} parser\n * @return {Promise<BufferGeometry>}\n */\nfunction addPrimitiveAttributes( geometry, primitiveDef, parser ) {\n\n\tconst attributes = primitiveDef.attributes;\n\n\tconst pending = [];\n\n\tfunction assignAttributeAccessor( accessorIndex, attributeName ) {\n\n\t\treturn parser.getDependency( 'accessor', accessorIndex )\n\t\t\t.then( function ( accessor ) {\n\n\t\t\t\tgeometry.setAttribute( attributeName, accessor );\n\n\t\t\t} );\n\n\t}\n\n\tfor ( const gltfAttributeName in attributes ) {\n\n\t\tconst threeAttributeName = ATTRIBUTES[ gltfAttributeName ] || gltfAttributeName.toLowerCase();\n\n\t\t// Skip attributes already provided by e.g. Draco extension.\n\t\tif ( threeAttributeName in geometry.attributes ) continue;\n\n\t\tpending.push( assignAttributeAccessor( attributes[ gltfAttributeName ], threeAttributeName ) );\n\n\t}\n\n\tif ( primitiveDef.indices !== undefined && ! geometry.index ) {\n\n\t\tconst accessor = parser.getDependency( 'accessor', primitiveDef.indices ).then( function ( accessor ) {\n\n\t\t\tgeometry.setIndex( accessor );\n\n\t\t} );\n\n\t\tpending.push( accessor );\n\n\t}\n\n\tif ( ColorManagement.workingColorSpace !== LinearSRGBColorSpace && 'COLOR_0' in attributes ) {\n\n\t\tconsole.warn( `THREE.GLTFLoader: Converting vertex colors from \"srgb-linear\" to \"${ColorManagement.workingColorSpace}\" not supported.` );\n\n\t}\n\n\tassignExtrasToUserData( geometry, primitiveDef );\n\n\tcomputeBounds( geometry, primitiveDef, parser );\n\n\treturn Promise.all( pending ).then( function () {\n\n\t\treturn primitiveDef.targets !== undefined\n\t\t\t? addMorphTargets( geometry, primitiveDef.targets, parser )\n\t\t\t: geometry;\n\n\t} );\n\n}\n\n/**\n * Loader result of `GLTFLoader`.\n *\n * @typedef {Object} GLTFLoader~LoadObject\n * @property {Array<AnimationClip>} animations - An array of animation clips.\n * @property {Object} asset - Meta data about the loaded asset.\n * @property {Array<Camera>} cameras - An array of cameras.\n * @property {GLTFParser} parser - A reference to the internal parser.\n * @property {Group} scene - The default scene.\n * @property {Array<Group>} scenes - glTF assets might define multiple scenes.\n * @property {Object} userData - Additional data.\n **/\n\nexport { GLTFLoader };\n","import * as THREE from 'three';\nimport { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';\n\n/**\n * Utility class for loading 3D models (GLTF/GLB format)\n */\nexport class ModelLoader {\n  constructor() {\n    this.loader = new GLTFLoader();\n  }\n\n  /**\n   * Load a GLTF/GLB model from a file path\n   * @param {string} path - Path to the model file (relative to public folder)\n   * @param {Object} options - Loading options\n   * @param {boolean} options.decolorize - Apply white/gray material for touch screen\n   * @returns {Promise<THREE.Object3D>} - The loaded model\n   */\n  async loadModel(path, options = {}) {\n    return new Promise((resolve, reject) => {\n      console.log(` Loading model from: ${path}`);\n      if (options.decolorize) {\n        console.log('    Will apply decolorized materials (white/gray)');\n      }\n      \n      this.loader.load(\n        path,\n        (gltf) => {\n          const model = gltf.scene;\n          \n          // Center the model at origin\n          const box = new THREE.Box3().setFromObject(model);\n          const center = box.getCenter(new THREE.Vector3());\n          model.position.sub(center);\n          \n          // Calculate size and scale to fit within 2x2x2 unit cube\n          const size = box.getSize(new THREE.Vector3());\n          const maxDim = Math.max(size.x, size.y, size.z);\n          const targetSize = 2.0; // Fit within 2 unit cube\n          const scale = targetSize / maxDim;\n          model.scale.setScalar(scale);\n          \n          // Enable shadows and apply materials\n          model.traverse((child) => {\n            if (child.isMesh) {\n              child.castShadow = true;\n              child.receiveShadow = true;\n              \n              // Apply decolorized material if requested\n              if (options.decolorize && child.material) {\n                const material = child.material.clone();\n                \n                // Convert to white/gray tones\n                if (material.color) {\n                  const gray = material.color.r * 0.299 + material.color.g * 0.587 + material.color.b * 0.114;\n                  // Make it lighter (more white) for touch screen\n                  const lightGray = Math.min(gray + 0.3, 1.0);\n                  material.color.setRGB(lightGray, lightGray, lightGray);\n                }\n                \n                child.material = material;\n              }\n              \n              // Ensure materials are visible\n              if (child.material) {\n                child.material.side = THREE.DoubleSide;\n              }\n            }\n          });\n          \n          console.log(' Model loaded successfully');\n          console.log(`   - Original size: ${size.x.toFixed(2)} x ${size.y.toFixed(2)} x ${size.z.toFixed(2)}`);\n          console.log(`   - Scale factor: ${scale.toFixed(2)}`);\n          console.log(`   - Meshes: ${this.countMeshes(model)}`);\n          if (options.decolorize) {\n            console.log('   - Materials: Decolorized (white/gray)');\n          }\n          \n          resolve(model);\n        },\n        (progress) => {\n          if (progress.total > 0) {\n            const percent = (progress.loaded / progress.total * 100).toFixed(0);\n            console.log(` Loading model: ${percent}%`);\n          }\n        },\n        (error) => {\n          console.error(' Error loading model:', error);\n          reject(error);\n        }\n      );\n    });\n  }\n\n  /**\n   * Count meshes in a model\n   * @param {THREE.Object3D} model \n   * @returns {number}\n   */\n  countMeshes(model) {\n    let count = 0;\n    model.traverse((child) => {\n      if (child.isMesh) count++;\n    });\n    return count;\n  }\n\n  /**\n   * Create a decolorized (grayscale) clone of a model\n   * @param {THREE.Object3D} model - Original model\n   * @returns {THREE.Object3D} - Grayscale clone\n   */\n  decolorizeModel(model) {\n    const clone = model.clone();\n    \n    clone.traverse((child) => {\n      if (child.isMesh && child.material) {\n        // Clone material to avoid affecting original\n        const material = child.material.clone();\n        \n        // Convert color to grayscale\n        if (material.color) {\n          const gray = material.color.r * 0.299 + material.color.g * 0.587 + material.color.b * 0.114;\n          material.color.setRGB(gray, gray, gray);\n        }\n        \n        // Reduce opacity slightly for touch screen\n        if (material.transparent) {\n          material.opacity *= 0.8;\n        }\n        \n        child.material = material;\n      }\n    });\n    \n    return clone;\n  }\n}\n\n\n\n","// Split strategy constants\nexport const CENTER = 0;\nexport const AVERAGE = 1;\nexport const SAH = 2;\n\n// Traversal constants\nexport const NOT_INTERSECTED = 0;\nexport const INTERSECTED = 1;\nexport const CONTAINED = 2;\n\n// SAH cost constants\n// TODO: hone these costs more. The relative difference between them should be the\n// difference in measured time to perform a primitive intersection vs traversing\n// bounds.\n// TODO: could be tuned per primitive type (triangles vs lines vs points)\nexport const PRIMITIVE_INTERSECT_COST = 1.25;\nexport const TRAVERSAL_COST = 1;\n\n\n// Build constants\nexport const BYTES_PER_NODE = 6 * 4 + 4 + 4;\nexport const UINT32_PER_NODE = BYTES_PER_NODE / 4;\nexport const IS_LEAFNODE_FLAG = 0xFFFF;\n\n// Bit masks for 32 bit node data\nexport const LEAFNODE_MASK_32 = IS_LEAFNODE_FLAG << 16;\n\n// EPSILON for computing floating point error during build\n// https://en.wikipedia.org/wiki/Machine_epsilon#Values_for_standard_hardware_floating_point_arithmetics\nexport const FLOAT32_EPSILON = Math.pow( 2, - 24 );\n\nexport const SKIP_GENERATION = Symbol( 'SKIP_GENERATION' );\n\nexport const DEFAULT_OPTIONS = {\n\tstrategy: CENTER,\n\tmaxDepth: 40,\n\tmaxLeafSize: 10,\n\tuseSharedArrayBuffer: false,\n\tsetBoundingBox: true,\n\tonProgress: null,\n\tindirect: false,\n\tverbose: true,\n\trange: null,\n\t[ SKIP_GENERATION ]: false,\n};\n\n","export function arrayToBox( nodeIndex32, array, target ) {\n\n\ttarget.min.x = array[ nodeIndex32 ];\n\ttarget.min.y = array[ nodeIndex32 + 1 ];\n\ttarget.min.z = array[ nodeIndex32 + 2 ];\n\n\ttarget.max.x = array[ nodeIndex32 + 3 ];\n\ttarget.max.y = array[ nodeIndex32 + 4 ];\n\ttarget.max.z = array[ nodeIndex32 + 5 ];\n\n\treturn target;\n\n}\n\nexport function makeEmptyBounds( target ) {\n\n\ttarget[ 0 ] = target[ 1 ] = target[ 2 ] = Infinity;\n\ttarget[ 3 ] = target[ 4 ] = target[ 5 ] = - Infinity;\n\n}\n\nexport function getLongestEdgeIndex( bounds ) {\n\n\tlet splitDimIdx = - 1;\n\tlet splitDist = - Infinity;\n\n\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\tconst dist = bounds[ i + 3 ] - bounds[ i ];\n\t\tif ( dist > splitDist ) {\n\n\t\t\tsplitDist = dist;\n\t\t\tsplitDimIdx = i;\n\n\t\t}\n\n\t}\n\n\treturn splitDimIdx;\n\n}\n\n// copies bounds a into bounds b\nexport function copyBounds( source, target ) {\n\n\ttarget.set( source );\n\n}\n\n// sets bounds target to the union of bounds a and b\nexport function unionBounds( a, b, target ) {\n\n\tlet aVal, bVal;\n\tfor ( let d = 0; d < 3; d ++ ) {\n\n\t\tconst d3 = d + 3;\n\n\t\t// set the minimum values\n\t\taVal = a[ d ];\n\t\tbVal = b[ d ];\n\t\ttarget[ d ] = aVal < bVal ? aVal : bVal;\n\n\t\t// set the max values\n\t\taVal = a[ d3 ];\n\t\tbVal = b[ d3 ];\n\t\ttarget[ d3 ] = aVal > bVal ? aVal : bVal;\n\n\t}\n\n}\n\n// expands the given bounds by the provided primitive bounds\nexport function expandByPrimitiveBounds( startIndex, primitiveBounds, bounds ) {\n\n\tfor ( let d = 0; d < 3; d ++ ) {\n\n\t\tconst tCenter = primitiveBounds[ startIndex + 2 * d ];\n\t\tconst tHalf = primitiveBounds[ startIndex + 2 * d + 1 ];\n\n\t\tconst tMin = tCenter - tHalf;\n\t\tconst tMax = tCenter + tHalf;\n\n\t\tif ( tMin < bounds[ d ] ) {\n\n\t\t\tbounds[ d ] = tMin;\n\n\t\t}\n\n\t\tif ( tMax > bounds[ d + 3 ] ) {\n\n\t\t\tbounds[ d + 3 ] = tMax;\n\n\t\t}\n\n\t}\n\n}\n\n// compute bounds surface area\nexport function computeSurfaceArea( bounds ) {\n\n\tconst d0 = bounds[ 3 ] - bounds[ 0 ];\n\tconst d1 = bounds[ 4 ] - bounds[ 1 ];\n\tconst d2 = bounds[ 5 ] - bounds[ 2 ];\n\n\treturn 2 * ( d0 * d1 + d1 * d2 + d2 * d0 );\n\n}\n","import { IS_LEAFNODE_FLAG, UINT32_PER_NODE } from '../Constants.js';\n\nexport function IS_LEAF( n16, uint16Array ) {\n\n\treturn uint16Array[ n16 + 15 ] === IS_LEAFNODE_FLAG;\n\n}\n\nexport function OFFSET( n32, uint32Array ) {\n\n\treturn uint32Array[ n32 + 6 ];\n\n}\n\nexport function COUNT( n16, uint16Array ) {\n\n\treturn uint16Array[ n16 + 14 ];\n\n}\n\n// Returns the uint32-aligned offset of the left child node for performance\nexport function LEFT_NODE( n32 ) {\n\n\treturn n32 + UINT32_PER_NODE;\n\n}\n\n// Returns the uint32-aligned offset of the right child node for performance\nexport function RIGHT_NODE( n32, uint32Array ) {\n\n\t// stored value is relative offset from parent, convert to absolute uint32 index\n\tconst relativeOffset = uint32Array[ n32 + 6 ];\n\treturn n32 + relativeOffset * UINT32_PER_NODE;\n\n}\n\nexport function SPLIT_AXIS( n32, uint32Array ) {\n\n\treturn uint32Array[ n32 + 7 ];\n\n}\n\nexport function BOUNDING_DATA_INDEX( n32 ) {\n\n\treturn n32;\n\n}\n","// computes the union of the bounds of all of the given primitives and puts the resulting box in \"target\".\n// A bounding box is computed for the centroids of the primitives, as well, and placed in \"centroidTarget\".\n// These are computed together to avoid redundant accesses to bounds array.\nexport function getBounds( primitiveBounds, offset, count, target, centroidTarget ) {\n\n\tlet minx = Infinity;\n\tlet miny = Infinity;\n\tlet minz = Infinity;\n\tlet maxx = - Infinity;\n\tlet maxy = - Infinity;\n\tlet maxz = - Infinity;\n\n\tlet cminx = Infinity;\n\tlet cminy = Infinity;\n\tlet cminz = Infinity;\n\tlet cmaxx = - Infinity;\n\tlet cmaxy = - Infinity;\n\tlet cmaxz = - Infinity;\n\n\tconst boundsOffset = primitiveBounds.offset || 0;\n\tfor ( let i = ( offset - boundsOffset ) * 6, end = ( offset + count - boundsOffset ) * 6; i < end; i += 6 ) {\n\n\t\tconst cx = primitiveBounds[ i + 0 ];\n\t\tconst hx = primitiveBounds[ i + 1 ];\n\t\tconst lx = cx - hx;\n\t\tconst rx = cx + hx;\n\t\tif ( lx < minx ) minx = lx;\n\t\tif ( rx > maxx ) maxx = rx;\n\t\tif ( cx < cminx ) cminx = cx;\n\t\tif ( cx > cmaxx ) cmaxx = cx;\n\n\t\tconst cy = primitiveBounds[ i + 2 ];\n\t\tconst hy = primitiveBounds[ i + 3 ];\n\t\tconst ly = cy - hy;\n\t\tconst ry = cy + hy;\n\t\tif ( ly < miny ) miny = ly;\n\t\tif ( ry > maxy ) maxy = ry;\n\t\tif ( cy < cminy ) cminy = cy;\n\t\tif ( cy > cmaxy ) cmaxy = cy;\n\n\t\tconst cz = primitiveBounds[ i + 4 ];\n\t\tconst hz = primitiveBounds[ i + 5 ];\n\t\tconst lz = cz - hz;\n\t\tconst rz = cz + hz;\n\t\tif ( lz < minz ) minz = lz;\n\t\tif ( rz > maxz ) maxz = rz;\n\t\tif ( cz < cminz ) cminz = cz;\n\t\tif ( cz > cmaxz ) cmaxz = cz;\n\n\t}\n\n\ttarget[ 0 ] = minx;\n\ttarget[ 1 ] = miny;\n\ttarget[ 2 ] = minz;\n\n\ttarget[ 3 ] = maxx;\n\ttarget[ 4 ] = maxy;\n\ttarget[ 5 ] = maxz;\n\n\tcentroidTarget[ 0 ] = cminx;\n\tcentroidTarget[ 1 ] = cminy;\n\tcentroidTarget[ 2 ] = cminz;\n\n\tcentroidTarget[ 3 ] = cmaxx;\n\tcentroidTarget[ 4 ] = cmaxy;\n\tcentroidTarget[ 5 ] = cmaxz;\n\n}\n","import { getLongestEdgeIndex, computeSurfaceArea, copyBounds, unionBounds, expandByPrimitiveBounds } from '../../utils/ArrayBoxUtilities.js';\nimport { CENTER, AVERAGE, SAH, PRIMITIVE_INTERSECT_COST, TRAVERSAL_COST } from '../Constants.js';\n\nconst BIN_COUNT = 32;\nconst binsSort = ( a, b ) => a.candidate - b.candidate;\nconst sahBins = /* @__PURE__ */ new Array( BIN_COUNT ).fill().map( () => {\n\n\treturn {\n\n\t\tcount: 0,\n\t\tbounds: new Float32Array( 6 ),\n\t\trightCacheBounds: new Float32Array( 6 ),\n\t\tleftCacheBounds: new Float32Array( 6 ),\n\t\tcandidate: 0,\n\n\t};\n\n} );\nconst leftBounds = /* @__PURE__ */ new Float32Array( 6 );\n\nexport function getOptimalSplit( nodeBoundingData, centroidBoundingData, primitiveBounds, offset, count, strategy ) {\n\n\tlet axis = - 1;\n\tlet pos = 0;\n\n\t// Center\n\tif ( strategy === CENTER ) {\n\n\t\taxis = getLongestEdgeIndex( centroidBoundingData );\n\t\tif ( axis !== - 1 ) {\n\n\t\t\tpos = ( centroidBoundingData[ axis ] + centroidBoundingData[ axis + 3 ] ) / 2;\n\n\t\t}\n\n\t} else if ( strategy === AVERAGE ) {\n\n\t\taxis = getLongestEdgeIndex( nodeBoundingData );\n\t\tif ( axis !== - 1 ) {\n\n\t\t\tpos = getAverage( primitiveBounds, offset, count, axis );\n\n\t\t}\n\n\t} else if ( strategy === SAH ) {\n\n\t\tconst rootSurfaceArea = computeSurfaceArea( nodeBoundingData );\n\t\tlet bestCost = PRIMITIVE_INTERSECT_COST * count;\n\n\t\t// iterate over all axes\n\t\tconst boundsOffset = primitiveBounds.offset || 0;\n\t\tconst cStart = ( offset - boundsOffset ) * 6;\n\t\tconst cEnd = ( offset + count - boundsOffset ) * 6;\n\t\tfor ( let a = 0; a < 3; a ++ ) {\n\n\t\t\tconst axisLeft = centroidBoundingData[ a ];\n\t\t\tconst axisRight = centroidBoundingData[ a + 3 ];\n\t\t\tconst axisLength = axisRight - axisLeft;\n\t\t\tconst binWidth = axisLength / BIN_COUNT;\n\n\t\t\t// If we have fewer primitives than we're planning to split then just check all\n\t\t\t// the primitive positions because it will be faster.\n\t\t\tif ( count < BIN_COUNT / 4 ) {\n\n\t\t\t\t// initialize the bin candidates\n\t\t\t\tconst truncatedBins = [ ...sahBins ];\n\t\t\t\ttruncatedBins.length = count;\n\n\t\t\t\t// set the candidates\n\t\t\t\tlet b = 0;\n\t\t\t\tfor ( let c = cStart; c < cEnd; c += 6, b ++ ) {\n\n\t\t\t\t\tconst bin = truncatedBins[ b ];\n\t\t\t\t\tbin.candidate = primitiveBounds[ c + 2 * a ];\n\t\t\t\t\tbin.count = 0;\n\n\t\t\t\t\tconst {\n\t\t\t\t\t\tbounds,\n\t\t\t\t\t\tleftCacheBounds,\n\t\t\t\t\t\trightCacheBounds,\n\t\t\t\t\t} = bin;\n\t\t\t\t\tfor ( let d = 0; d < 3; d ++ ) {\n\n\t\t\t\t\t\trightCacheBounds[ d ] = Infinity;\n\t\t\t\t\t\trightCacheBounds[ d + 3 ] = - Infinity;\n\n\t\t\t\t\t\tleftCacheBounds[ d ] = Infinity;\n\t\t\t\t\t\tleftCacheBounds[ d + 3 ] = - Infinity;\n\n\t\t\t\t\t\tbounds[ d ] = Infinity;\n\t\t\t\t\t\tbounds[ d + 3 ] = - Infinity;\n\n\t\t\t\t\t}\n\n\t\t\t\t\texpandByPrimitiveBounds( c, primitiveBounds, bounds );\n\n\t\t\t\t}\n\n\t\t\t\ttruncatedBins.sort( binsSort );\n\n\t\t\t\t// remove redundant splits\n\t\t\t\tlet splitCount = count;\n\t\t\t\tfor ( let bi = 0; bi < splitCount; bi ++ ) {\n\n\t\t\t\t\tconst bin = truncatedBins[ bi ];\n\t\t\t\t\twhile ( bi + 1 < splitCount && truncatedBins[ bi + 1 ].candidate === bin.candidate ) {\n\n\t\t\t\t\t\ttruncatedBins.splice( bi + 1, 1 );\n\t\t\t\t\t\tsplitCount --;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// find the appropriate bin for each primitive and expand the bounds.\n\t\t\t\tfor ( let c = cStart; c < cEnd; c += 6 ) {\n\n\t\t\t\t\tconst center = primitiveBounds[ c + 2 * a ];\n\t\t\t\t\tfor ( let bi = 0; bi < splitCount; bi ++ ) {\n\n\t\t\t\t\t\tconst bin = truncatedBins[ bi ];\n\t\t\t\t\t\tif ( center >= bin.candidate ) {\n\n\t\t\t\t\t\t\texpandByPrimitiveBounds( c, primitiveBounds, bin.rightCacheBounds );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\texpandByPrimitiveBounds( c, primitiveBounds, bin.leftCacheBounds );\n\t\t\t\t\t\t\tbin.count ++;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// expand all the bounds\n\t\t\t\tfor ( let bi = 0; bi < splitCount; bi ++ ) {\n\n\t\t\t\t\tconst bin = truncatedBins[ bi ];\n\t\t\t\t\tconst leftCount = bin.count;\n\t\t\t\t\tconst rightCount = count - bin.count;\n\n\t\t\t\t\t// check the cost of this split\n\t\t\t\t\tconst leftBounds = bin.leftCacheBounds;\n\t\t\t\t\tconst rightBounds = bin.rightCacheBounds;\n\n\t\t\t\t\tlet leftProb = 0;\n\t\t\t\t\tif ( leftCount !== 0 ) {\n\n\t\t\t\t\t\tleftProb = computeSurfaceArea( leftBounds ) / rootSurfaceArea;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tlet rightProb = 0;\n\t\t\t\t\tif ( rightCount !== 0 ) {\n\n\t\t\t\t\t\trightProb = computeSurfaceArea( rightBounds ) / rootSurfaceArea;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst cost = TRAVERSAL_COST + PRIMITIVE_INTERSECT_COST * (\n\t\t\t\t\t\tleftProb * leftCount + rightProb * rightCount\n\t\t\t\t\t);\n\n\t\t\t\t\tif ( cost < bestCost ) {\n\n\t\t\t\t\t\taxis = a;\n\t\t\t\t\t\tbestCost = cost;\n\t\t\t\t\t\tpos = bin.candidate;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// reset the bins\n\t\t\t\tfor ( let i = 0; i < BIN_COUNT; i ++ ) {\n\n\t\t\t\t\tconst bin = sahBins[ i ];\n\t\t\t\t\tbin.count = 0;\n\t\t\t\t\tbin.candidate = axisLeft + binWidth + i * binWidth;\n\n\t\t\t\t\tconst bounds = bin.bounds;\n\t\t\t\t\tfor ( let d = 0; d < 3; d ++ ) {\n\n\t\t\t\t\t\tbounds[ d ] = Infinity;\n\t\t\t\t\t\tbounds[ d + 3 ] = - Infinity;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// iterate over all center positions\n\t\t\t\tfor ( let c = cStart; c < cEnd; c += 6 ) {\n\n\t\t\t\t\tconst triCenter = primitiveBounds[ c + 2 * a ];\n\t\t\t\t\tconst relativeCenter = triCenter - axisLeft;\n\n\t\t\t\t\t// in the partition function if the centroid lies on the split plane then it is\n\t\t\t\t\t// considered to be on the right side of the split\n\t\t\t\t\tlet binIndex = ~ ~ ( relativeCenter / binWidth );\n\t\t\t\t\tif ( binIndex >= BIN_COUNT ) binIndex = BIN_COUNT - 1;\n\n\t\t\t\t\tconst bin = sahBins[ binIndex ];\n\t\t\t\t\tbin.count ++;\n\n\t\t\t\t\texpandByPrimitiveBounds( c, primitiveBounds, bin.bounds );\n\n\t\t\t\t}\n\n\t\t\t\t// cache the unioned bounds from right to left so we don't have to regenerate them each time\n\t\t\t\tconst lastBin = sahBins[ BIN_COUNT - 1 ];\n\t\t\t\tcopyBounds( lastBin.bounds, lastBin.rightCacheBounds );\n\t\t\t\tfor ( let i = BIN_COUNT - 2; i >= 0; i -- ) {\n\n\t\t\t\t\tconst bin = sahBins[ i ];\n\t\t\t\t\tconst nextBin = sahBins[ i + 1 ];\n\t\t\t\t\tunionBounds( bin.bounds, nextBin.rightCacheBounds, bin.rightCacheBounds );\n\n\t\t\t\t}\n\n\t\t\t\tlet leftCount = 0;\n\t\t\t\tfor ( let i = 0; i < BIN_COUNT - 1; i ++ ) {\n\n\t\t\t\t\tconst bin = sahBins[ i ];\n\t\t\t\t\tconst binCount = bin.count;\n\t\t\t\t\tconst bounds = bin.bounds;\n\n\t\t\t\t\tconst nextBin = sahBins[ i + 1 ];\n\t\t\t\t\tconst rightBounds = nextBin.rightCacheBounds;\n\n\t\t\t\t\t// don't do anything with the bounds if the new bounds have no primitives\n\t\t\t\t\tif ( binCount !== 0 ) {\n\n\t\t\t\t\t\tif ( leftCount === 0 ) {\n\n\t\t\t\t\t\t\tcopyBounds( bounds, leftBounds );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tunionBounds( bounds, leftBounds, leftBounds );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tleftCount += binCount;\n\n\t\t\t\t\t// check the cost of this split\n\t\t\t\t\tlet leftProb = 0;\n\t\t\t\t\tlet rightProb = 0;\n\n\t\t\t\t\tif ( leftCount !== 0 ) {\n\n\t\t\t\t\t\tleftProb = computeSurfaceArea( leftBounds ) / rootSurfaceArea;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst rightCount = count - leftCount;\n\t\t\t\t\tif ( rightCount !== 0 ) {\n\n\t\t\t\t\t\trightProb = computeSurfaceArea( rightBounds ) / rootSurfaceArea;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst cost = TRAVERSAL_COST + PRIMITIVE_INTERSECT_COST * (\n\t\t\t\t\t\tleftProb * leftCount + rightProb * rightCount\n\t\t\t\t\t);\n\n\t\t\t\t\tif ( cost < bestCost ) {\n\n\t\t\t\t\t\taxis = a;\n\t\t\t\t\t\tbestCost = cost;\n\t\t\t\t\t\tpos = bin.candidate;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t} else {\n\n\t\tconsole.warn( `BVH: Invalid build strategy value ${ strategy } used.` );\n\n\t}\n\n\treturn { axis, pos };\n\n}\n\n// returns the average coordinate on the specified axis of all the provided primitives\nfunction getAverage( primitiveBounds, offset, count, axis ) {\n\n\tlet avg = 0;\n\tconst boundsOffset = primitiveBounds.offset;\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\t\tavg += primitiveBounds[ ( i - boundsOffset ) * 6 + axis * 2 ];\n\n\t}\n\n\treturn avg / count;\n\n}\n","export class BVHNode {\n\n\tconstructor() {\n\n\t\t// internal nodes have boundingData, left, right, and splitAxis\n\t\t// leaf nodes have offset and count (referring to primitives in the mesh geometry)\n\n\t\tthis.boundingData = new Float32Array( 6 );\n\n\t}\n\n}\n","// reorders the partition buffer such that for `count` elements after `offset`, elements on the left side of the split\n// will be on the left and elements on the right side of the split will be on the right. returns the index\n// of the first element on the right side, or offset + count if there are no elements on the right side.\nexport function partition( buffer, stride, primitiveBounds, offset, count, split ) {\n\n\tlet left = offset;\n\tlet right = offset + count - 1;\n\tconst pos = split.pos;\n\tconst axisOffset = split.axis * 2;\n\tconst boundsOffset = primitiveBounds.offset || 0;\n\n\t// hoare partitioning, see e.g. https://en.wikipedia.org/wiki/Quicksort#Hoare_partition_scheme\n\twhile ( true ) {\n\n\t\twhile ( left <= right && primitiveBounds[ ( left - boundsOffset ) * 6 + axisOffset ] < pos ) {\n\n\t\t\tleft ++;\n\n\t\t}\n\n\t\t// if a primitive center lies on the partition plane it is considered to be on the right side\n\t\twhile ( left <= right && primitiveBounds[ ( right - boundsOffset ) * 6 + axisOffset ] >= pos ) {\n\n\t\t\tright --;\n\n\t\t}\n\n\t\tif ( left < right ) {\n\n\t\t\t// we need to swap all of the information associated with the primitives at index\n\t\t\t// left and right; that's the elements in the partition buffer and the bounds\n\t\t\tfor ( let i = 0; i < stride; i ++ ) {\n\n\t\t\t\tlet t0 = buffer[ left * stride + i ];\n\t\t\t\tbuffer[ left * stride + i ] = buffer[ right * stride + i ];\n\t\t\t\tbuffer[ right * stride + i ] = t0;\n\n\t\t\t}\n\n\t\t\t// swap bounds\n\t\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\t\tconst l = left - boundsOffset;\n\t\t\t\tconst r = right - boundsOffset;\n\t\t\t\tconst tb = primitiveBounds[ l * 6 + i ];\n\t\t\t\tprimitiveBounds[ l * 6 + i ] = primitiveBounds[ r * 6 + i ];\n\t\t\t\tprimitiveBounds[ r * 6 + i ] = tb;\n\n\t\t\t}\n\n\t\t\tleft ++;\n\t\t\tright --;\n\n\t\t} else {\n\n\t\t\treturn left;\n\n\t\t}\n\n\t}\n\n}\n","import { BYTES_PER_NODE, IS_LEAFNODE_FLAG } from '../Constants.js';\n\nlet float32Array, uint32Array, uint16Array, uint8Array;\nconst MAX_POINTER = Math.pow( 2, 32 );\n\nexport function countNodes( node ) {\n\n\tif ( 'count' in node ) {\n\n\t\treturn 1;\n\n\t} else {\n\n\t\treturn 1 + countNodes( node.left ) + countNodes( node.right );\n\n\t}\n\n}\n\nexport function populateBuffer( byteOffset, node, buffer ) {\n\n\tfloat32Array = new Float32Array( buffer );\n\tuint32Array = new Uint32Array( buffer );\n\tuint16Array = new Uint16Array( buffer );\n\tuint8Array = new Uint8Array( buffer );\n\n\treturn _populateBuffer( byteOffset, node );\n\n}\n\n// pack structure\n// boundingData  \t\t\t\t: 6 float32\n// right / offset \t\t\t\t: 1 uint32\n// splitAxis / isLeaf + count \t: 1 uint32 / 2 uint16\nfunction _populateBuffer( byteOffset, node ) {\n\n\tconst node32Index = byteOffset / 4;\n\tconst node16Index = byteOffset / 2;\n\tconst isLeaf = 'count' in node;\n\tconst boundingData = node.boundingData;\n\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\tfloat32Array[ node32Index + i ] = boundingData[ i ];\n\n\t}\n\n\tif ( isLeaf ) {\n\n\t\tif ( node.buffer ) {\n\n\t\t\tuint8Array.set( new Uint8Array( node.buffer ), byteOffset );\n\t\t\treturn byteOffset + node.buffer.byteLength;\n\n\t\t} else {\n\n\t\t\tuint32Array[ node32Index + 6 ] = node.offset;\n\t\t\tuint16Array[ node16Index + 14 ] = node.count;\n\t\t\tuint16Array[ node16Index + 15 ] = IS_LEAFNODE_FLAG;\n\t\t\treturn byteOffset + BYTES_PER_NODE;\n\n\t\t}\n\n\t} else {\n\n\t\tconst { left, right, splitAxis } = node;\n\n\t\t// fill in the left node contents\n\t\tconst leftByteOffset = byteOffset + BYTES_PER_NODE;\n\t\tlet rightByteOffset = _populateBuffer( leftByteOffset, left );\n\n\t\t// calculate relative offset from parent to right child\n\t\tconst currentNodeIndex = byteOffset / BYTES_PER_NODE;\n\t\tconst rightNodeIndex = rightByteOffset / BYTES_PER_NODE;\n\t\tconst relativeRightIndex = rightNodeIndex - currentNodeIndex;\n\n\t\t// check if the relative offset is too high\n\t\tif ( relativeRightIndex > MAX_POINTER ) {\n\n\t\t\tthrow new Error( 'MeshBVH: Cannot store relative child node offset greater than 32 bits.' );\n\n\t\t}\n\n\t\t// fill in the right node contents (store as relative offset)\n\t\tuint32Array[ node32Index + 6 ] = relativeRightIndex;\n\t\tuint32Array[ node32Index + 7 ] = splitAxis;\n\n\t\t// return the next available buffer pointer\n\t\treturn _populateBuffer( rightByteOffset, right );\n\n\t}\n\n}\n","import { getBounds } from './computeBoundsUtils.js';\nimport { getOptimalSplit } from './splitUtils.js';\nimport { BVHNode } from '../BVHNode.js';\nimport { BYTES_PER_NODE } from '../Constants.js';\n\nimport { partition } from './sortUtils.js';\nimport { countNodes, populateBuffer } from './buildUtils.js';\n\nexport function buildTree( bvh, primitiveBounds, offset, count, options ) {\n\n\t// expand variables\n\tconst {\n\t\tmaxDepth,\n\t\tverbose,\n\t\tmaxLeafSize,\n\t\tstrategy,\n\t\tonProgress,\n\t} = options;\n\n\tconst partitionBuffer = bvh.primitiveBuffer;\n\tconst partitionStride = bvh.primitiveBufferStride;\n\n\t// generate intermediate variables\n\tconst cacheCentroidBoundingData = new Float32Array( 6 );\n\tlet reachedMaxDepth = false;\n\n\tconst root = new BVHNode();\n\tgetBounds( primitiveBounds, offset, count, root.boundingData, cacheCentroidBoundingData );\n\tsplitNode( root, offset, count, cacheCentroidBoundingData );\n\treturn root;\n\n\tfunction triggerProgress( primitivesProcessed ) {\n\n\t\tif ( onProgress ) {\n\n\t\t\tonProgress( primitivesProcessed / count );\n\n\t\t}\n\n\t}\n\n\t// either recursively splits the given node, creating left and right subtrees for it, or makes it a leaf node,\n\t// recording the offset and count of its primitives and writing them into the reordered geometry index.\n\tfunction splitNode( node, offset, count, centroidBoundingData = null, depth = 0 ) {\n\n\t\tif ( ! reachedMaxDepth && depth >= maxDepth ) {\n\n\t\t\treachedMaxDepth = true;\n\t\t\tif ( verbose ) {\n\n\t\t\t\tconsole.warn( `BVH: Max depth of ${ maxDepth } reached when generating BVH. Consider increasing maxDepth.` );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// early out if we've met our capacity\n\t\tif ( count <= maxLeafSize || depth >= maxDepth ) {\n\n\t\t\ttriggerProgress( offset + count );\n\t\t\tnode.offset = offset;\n\t\t\tnode.count = count;\n\t\t\treturn node;\n\n\t\t}\n\n\t\t// Find where to split the volume\n\t\tconst split = getOptimalSplit( node.boundingData, centroidBoundingData, primitiveBounds, offset, count, strategy );\n\t\tif ( split.axis === - 1 ) {\n\n\t\t\ttriggerProgress( offset + count );\n\t\t\tnode.offset = offset;\n\t\t\tnode.count = count;\n\t\t\treturn node;\n\n\t\t}\n\n\t\tconst splitOffset = partition( partitionBuffer, partitionStride, primitiveBounds, offset, count, split );\n\n\t\t// create the two new child nodes\n\t\tif ( splitOffset === offset || splitOffset === offset + count ) {\n\n\t\t\ttriggerProgress( offset + count );\n\t\t\tnode.offset = offset;\n\t\t\tnode.count = count;\n\n\t\t} else {\n\n\t\t\tnode.splitAxis = split.axis;\n\n\t\t\t// create the left child and compute its bounding box\n\t\t\tconst left = new BVHNode();\n\t\t\tconst lstart = offset;\n\t\t\tconst lcount = splitOffset - offset;\n\t\t\tnode.left = left;\n\n\t\t\tgetBounds( primitiveBounds, lstart, lcount, left.boundingData, cacheCentroidBoundingData );\n\t\t\tsplitNode( left, lstart, lcount, cacheCentroidBoundingData, depth + 1 );\n\n\t\t\t// repeat for right\n\t\t\tconst right = new BVHNode();\n\t\t\tconst rstart = splitOffset;\n\t\t\tconst rcount = count - lcount;\n\t\t\tnode.right = right;\n\n\t\t\tgetBounds( primitiveBounds, rstart, rcount, right.boundingData, cacheCentroidBoundingData );\n\t\t\tsplitNode( right, rstart, rcount, cacheCentroidBoundingData, depth + 1 );\n\n\t\t}\n\n\t\treturn node;\n\n\t}\n\n}\n\nexport function buildPackedTree( bvh, options ) {\n\n\tconst BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;\n\n\t// get the range of buffer data to construct / arrange\n\tconst rootRanges = bvh.getRootRanges( options.range );\n\tconst firstRange = rootRanges[ 0 ];\n\tconst lastRange = rootRanges[ rootRanges.length - 1 ];\n\tconst fullRange = {\n\t\toffset: firstRange.offset,\n\t\tcount: lastRange.offset + lastRange.count - firstRange.offset,\n\t};\n\n\t// construct the primitive bounds for sorting\n\tconst primitiveBounds = new Float32Array( 6 * fullRange.count );\n\tprimitiveBounds.offset = fullRange.offset;\n\tbvh.computePrimitiveBounds( fullRange.offset, fullRange.count, primitiveBounds );\n\n\t// Build BVH roots\n\tbvh._roots = rootRanges.map( range => {\n\n\t\tconst root = buildTree( bvh, primitiveBounds, range.offset, range.count, options );\n\t\tconst nodeCount = countNodes( root );\n\t\tconst buffer = new BufferConstructor( BYTES_PER_NODE * nodeCount );\n\t\tpopulateBuffer( 0, root, buffer );\n\t\treturn buffer;\n\n\t} );\n\n}\n","export class PrimitivePool {\n\n\tconstructor( getNewPrimitive ) {\n\n\t\tthis._getNewPrimitive = getNewPrimitive;\n\t\tthis._primitives = [];\n\n\t}\n\n\tgetPrimitive() {\n\n\t\tconst primitives = this._primitives;\n\t\tif ( primitives.length === 0 ) {\n\n\t\t\treturn this._getNewPrimitive();\n\n\t\t} else {\n\n\t\t\treturn primitives.pop();\n\n\t\t}\n\n\t}\n\n\treleasePrimitive( primitive ) {\n\n\t\tthis._primitives.push( primitive );\n\n\t}\n\n}\n","class _BufferStack {\n\n\tconstructor() {\n\n\t\tthis.float32Array = null;\n\t\tthis.uint16Array = null;\n\t\tthis.uint32Array = null;\n\n\t\tconst stack = [];\n\t\tlet prevBuffer = null;\n\t\tthis.setBuffer = buffer => {\n\n\t\t\tif ( prevBuffer ) {\n\n\t\t\t\tstack.push( prevBuffer );\n\n\t\t\t}\n\n\t\t\tprevBuffer = buffer;\n\t\t\tthis.float32Array = new Float32Array( buffer );\n\t\t\tthis.uint16Array = new Uint16Array( buffer );\n\t\t\tthis.uint32Array = new Uint32Array( buffer );\n\n\t\t};\n\n\t\tthis.clearBuffer = () => {\n\n\t\t\tprevBuffer = null;\n\t\t\tthis.float32Array = null;\n\t\t\tthis.uint16Array = null;\n\t\t\tthis.uint32Array = null;\n\n\t\t\tif ( stack.length !== 0 ) {\n\n\t\t\t\tthis.setBuffer( stack.pop() );\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n}\n\nexport const BufferStack = /* @__PURE__ */ new _BufferStack();\n","import { Box3 } from 'three';\nimport { CONTAINED, UINT32_PER_NODE } from '../Constants.js';\nimport { arrayToBox } from '../../utils/ArrayBoxUtilities.js';\nimport { PrimitivePool } from '../../utils/PrimitivePool.js';\nimport { COUNT, OFFSET, LEFT_NODE, RIGHT_NODE, IS_LEAF, BOUNDING_DATA_INDEX } from '../utils/nodeBufferUtils.js';\nimport { BufferStack } from '../utils/BufferStack.js';\n\nlet _box1, _box2;\nconst boxStack = [];\nconst boxPool = /* @__PURE__ */ new PrimitivePool( () => new Box3() );\n\nexport function shapecast( bvh, root, intersectsBounds, intersectsRange, boundsTraverseOrder, nodeOffset ) {\n\n\t// setup\n\t_box1 = boxPool.getPrimitive();\n\t_box2 = boxPool.getPrimitive();\n\tboxStack.push( _box1, _box2 );\n\tBufferStack.setBuffer( bvh._roots[ root ] );\n\n\tconst result = shapecastTraverse( 0, bvh.geometry, intersectsBounds, intersectsRange, boundsTraverseOrder, nodeOffset );\n\n\t// cleanup\n\tBufferStack.clearBuffer();\n\tboxPool.releasePrimitive( _box1 );\n\tboxPool.releasePrimitive( _box2 );\n\tboxStack.pop();\n\tboxStack.pop();\n\n\tconst length = boxStack.length;\n\tif ( length > 0 ) {\n\n\t\t_box2 = boxStack[ length - 1 ];\n\t\t_box1 = boxStack[ length - 2 ];\n\n\t}\n\n\treturn result;\n\n}\n\nfunction shapecastTraverse(\n\tnodeIndex32,\n\tgeometry,\n\tintersectsBoundsFunc,\n\tintersectsRangeFunc,\n\tnodeScoreFunc = null,\n\tnodeIndexOffset = 0, // offset for unique node identifier\n\tdepth = 0\n) {\n\n\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\t\tarrayToBox( BOUNDING_DATA_INDEX( nodeIndex32 ), float32Array, _box1 );\n\t\treturn intersectsRangeFunc( offset, count, false, depth, nodeIndexOffset + nodeIndex32 / UINT32_PER_NODE, _box1 );\n\n\t} else {\n\n\t\tconst left = LEFT_NODE( nodeIndex32 );\n\t\tconst right = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\tlet c1 = left;\n\t\tlet c2 = right;\n\n\t\tlet score1, score2;\n\t\tlet box1, box2;\n\t\tif ( nodeScoreFunc ) {\n\n\t\t\tbox1 = _box1;\n\t\t\tbox2 = _box2;\n\n\t\t\t// bounding data is not offset\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( c1 ), float32Array, box1 );\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( c2 ), float32Array, box2 );\n\n\t\t\tscore1 = nodeScoreFunc( box1 );\n\t\t\tscore2 = nodeScoreFunc( box2 );\n\n\t\t\tif ( score2 < score1 ) {\n\n\t\t\t\tc1 = right;\n\t\t\t\tc2 = left;\n\n\t\t\t\tconst temp = score1;\n\t\t\t\tscore1 = score2;\n\t\t\t\tscore2 = temp;\n\n\t\t\t\tbox1 = box2;\n\t\t\t\t// box2 is always set before use below\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Check box 1 intersection\n\t\tif ( ! box1 ) {\n\n\t\t\tbox1 = _box1;\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( c1 ), float32Array, box1 );\n\n\t\t}\n\n\t\tconst isC1Leaf = IS_LEAF( c1 * 2, uint16Array );\n\t\tconst c1Intersection = intersectsBoundsFunc( box1, isC1Leaf, score1, depth + 1, nodeIndexOffset + c1 / UINT32_PER_NODE );\n\n\t\tlet c1StopTraversal;\n\t\tif ( c1Intersection === CONTAINED ) {\n\n\t\t\tconst offset = getLeftOffset( c1 );\n\t\t\tconst end = getRightEndOffset( c1 );\n\t\t\tconst count = end - offset;\n\n\t\t\tc1StopTraversal = intersectsRangeFunc( offset, count, true, depth + 1, nodeIndexOffset + c1 / UINT32_PER_NODE, box1 );\n\n\t\t} else {\n\n\t\t\tc1StopTraversal =\n\t\t\t\tc1Intersection &&\n\t\t\t\tshapecastTraverse(\n\t\t\t\t\tc1,\n\t\t\t\t\tgeometry,\n\t\t\t\t\tintersectsBoundsFunc,\n\t\t\t\t\tintersectsRangeFunc,\n\t\t\t\t\tnodeScoreFunc,\n\t\t\t\t\tnodeIndexOffset,\n\t\t\t\t\tdepth + 1\n\t\t\t\t);\n\n\t\t}\n\n\t\tif ( c1StopTraversal ) return true;\n\n\t\t// Check box 2 intersection\n\t\t// cached box2 will have been overwritten by previous traversal\n\t\tbox2 = _box2;\n\t\tarrayToBox( BOUNDING_DATA_INDEX( c2 ), float32Array, box2 );\n\n\t\tconst isC2Leaf = IS_LEAF( c2 * 2, uint16Array );\n\t\tconst c2Intersection = intersectsBoundsFunc( box2, isC2Leaf, score2, depth + 1, nodeIndexOffset + c2 / UINT32_PER_NODE );\n\n\t\tlet c2StopTraversal;\n\t\tif ( c2Intersection === CONTAINED ) {\n\n\t\t\tconst offset = getLeftOffset( c2 );\n\t\t\tconst end = getRightEndOffset( c2 );\n\t\t\tconst count = end - offset;\n\n\t\t\tc2StopTraversal = intersectsRangeFunc( offset, count, true, depth + 1, nodeIndexOffset + c2 / UINT32_PER_NODE, box2 );\n\n\t\t} else {\n\n\t\t\tc2StopTraversal =\n\t\t\t\tc2Intersection &&\n\t\t\t\tshapecastTraverse(\n\t\t\t\t\tc2,\n\t\t\t\t\tgeometry,\n\t\t\t\t\tintersectsBoundsFunc,\n\t\t\t\t\tintersectsRangeFunc,\n\t\t\t\t\tnodeScoreFunc,\n\t\t\t\t\tnodeIndexOffset,\n\t\t\t\t\tdepth + 1\n\t\t\t\t);\n\n\t\t}\n\n\t\tif ( c2StopTraversal ) return true;\n\n\t\treturn false;\n\n\t\t// Define these inside the function so it has access to the local variables needed\n\t\t// when converting to the buffer equivalents\n\t\tfunction getLeftOffset( nodeIndex32 ) {\n\n\t\t\tconst { uint16Array, uint32Array } = BufferStack;\n\t\t\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\t\t\t// traverse until we find a leaf\n\t\t\twhile ( ! IS_LEAF( nodeIndex16, uint16Array ) ) {\n\n\t\t\t\tnodeIndex32 = LEFT_NODE( nodeIndex32 );\n\t\t\t\tnodeIndex16 = nodeIndex32 * 2;\n\n\t\t\t}\n\n\t\t\treturn OFFSET( nodeIndex32, uint32Array );\n\n\t\t}\n\n\t\tfunction getRightEndOffset( nodeIndex32 ) {\n\n\t\t\tconst { uint16Array, uint32Array } = BufferStack;\n\t\t\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\t\t\t// traverse until we find a leaf\n\t\t\twhile ( ! IS_LEAF( nodeIndex16, uint16Array ) ) {\n\n\t\t\t\t// adjust offset to point to the right node\n\t\t\t\tnodeIndex32 = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\t\t\tnodeIndex16 = nodeIndex32 * 2;\n\n\t\t\t}\n\n\t\t\t// return the end offset of the triangle range\n\t\t\treturn OFFSET( nodeIndex32, uint32Array ) + COUNT( nodeIndex16, uint16Array );\n\n\t\t}\n\n\t}\n\n}\n","import { Box3, Matrix4 } from 'three';\nimport { BufferStack } from '../utils/BufferStack.js';\nimport { BOUNDING_DATA_INDEX, COUNT, IS_LEAF, LEFT_NODE, OFFSET, RIGHT_NODE } from '../utils/nodeBufferUtils.js';\nimport { arrayToBox } from '../../utils/ArrayBoxUtilities.js';\nimport { PrimitivePool } from '../../utils/PrimitivePool.js';\nimport { BYTES_PER_NODE, UINT32_PER_NODE } from '../Constants.js';\n\nconst _bufferStack1 = /* @__PURE__ */ new BufferStack.constructor();\nconst _bufferStack2 = /* @__PURE__ */ new BufferStack.constructor();\nconst _boxPool = /* @__PURE__ */ new PrimitivePool( () => new Box3() );\nconst _leftBox1 = /* @__PURE__ */ new Box3();\nconst _rightBox1 = /* @__PURE__ */ new Box3();\n\nconst _leftBox2 = /* @__PURE__ */ new Box3();\nconst _rightBox2 = /* @__PURE__ */ new Box3();\n\nlet _active = false;\n\nexport function bvhcast( bvh, otherBvh, matrixToLocal, intersectsRanges ) {\n\n\tif ( _active ) {\n\n\t\tthrow new Error( 'MeshBVH: Recursive calls to bvhcast not supported.' );\n\n\t}\n\n\t_active = true;\n\n\tconst roots = bvh._roots;\n\tconst otherRoots = otherBvh._roots;\n\tlet result;\n\tlet nodeOffset1 = 0;\n\tlet nodeOffset2 = 0;\n\tconst invMat = new Matrix4().copy( matrixToLocal ).invert();\n\n\t// iterate over the first set of roots\n\tfor ( let i = 0, il = roots.length; i < il; i ++ ) {\n\n\t\t_bufferStack1.setBuffer( roots[ i ] );\n\t\tnodeOffset2 = 0;\n\n\t\t// prep the initial root box\n\t\tconst localBox = _boxPool.getPrimitive();\n\t\tarrayToBox( BOUNDING_DATA_INDEX( 0 ), _bufferStack1.float32Array, localBox );\n\t\tlocalBox.applyMatrix4( invMat );\n\n\t\t// iterate over the second set of roots\n\t\tfor ( let j = 0, jl = otherRoots.length; j < jl; j ++ ) {\n\n\t\t\t_bufferStack2.setBuffer( otherRoots[ j ] );\n\n\t\t\tresult = _traverse(\n\t\t\t\t0, 0, matrixToLocal, invMat, intersectsRanges,\n\t\t\t\tnodeOffset1, nodeOffset2, 0, 0,\n\t\t\t\tlocalBox,\n\t\t\t);\n\n\t\t\t_bufferStack2.clearBuffer();\n\t\t\tnodeOffset2 += otherRoots[ j ].byteLength / BYTES_PER_NODE;\n\n\t\t\tif ( result ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// release stack info\n\t\t_boxPool.releasePrimitive( localBox );\n\t\t_bufferStack1.clearBuffer();\n\t\tnodeOffset1 += roots[ i ].byteLength / BYTES_PER_NODE;\n\n\t\tif ( result ) {\n\n\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n\t_active = false;\n\treturn result;\n\n}\n\nfunction _traverse(\n\tnode1Index32,\n\tnode2Index32,\n\tmatrix2to1,\n\tmatrix1to2,\n\tintersectsRangesFunc,\n\n\t// offsets for ids\n\tnode1IndexOffset = 0,\n\tnode2IndexOffset = 0,\n\n\t// tree depth\n\tdepth1 = 0,\n\tdepth2 = 0,\n\n\tcurrBox = null,\n\treversed = false,\n\n) {\n\n\t// get the buffer stacks associated with the current indices\n\tlet bufferStack1, bufferStack2;\n\tif ( reversed ) {\n\n\t\tbufferStack1 = _bufferStack2;\n\t\tbufferStack2 = _bufferStack1;\n\n\t} else {\n\n\t\tbufferStack1 = _bufferStack1;\n\t\tbufferStack2 = _bufferStack2;\n\n\t}\n\n\t// get the local instances of the typed buffers\n\tconst\n\t\tfloat32Array1 = bufferStack1.float32Array,\n\t\tuint32Array1 = bufferStack1.uint32Array,\n\t\tuint16Array1 = bufferStack1.uint16Array,\n\t\tfloat32Array2 = bufferStack2.float32Array,\n\t\tuint32Array2 = bufferStack2.uint32Array,\n\t\tuint16Array2 = bufferStack2.uint16Array;\n\n\tconst node1Index16 = node1Index32 * 2;\n\tconst node2Index16 = node2Index32 * 2;\n\tconst isLeaf1 = IS_LEAF( node1Index16, uint16Array1 );\n\tconst isLeaf2 = IS_LEAF( node2Index16, uint16Array2 );\n\tlet result = false;\n\tif ( isLeaf2 && isLeaf1 ) {\n\n\t\t// if both bounds are leaf nodes then fire the callback if the boxes intersect\n\t\t// Note the \"nodeIndex\" values are just intended to be used as unique identifiers in the tree and\n\t\t// not used for accessing data\n\t\tif ( reversed ) {\n\n\t\t\tresult = intersectsRangesFunc(\n\t\t\t\tOFFSET( node2Index32, uint32Array2 ), COUNT( node2Index32 * 2, uint16Array2 ),\n\t\t\t\tOFFSET( node1Index32, uint32Array1 ), COUNT( node1Index32 * 2, uint16Array1 ),\n\t\t\t\tdepth2, node2IndexOffset + node2Index32 / UINT32_PER_NODE,\n\t\t\t\tdepth1, node1IndexOffset + node1Index32 / UINT32_PER_NODE,\n\t\t\t);\n\n\t\t} else {\n\n\t\t\tresult = intersectsRangesFunc(\n\t\t\t\tOFFSET( node1Index32, uint32Array1 ), COUNT( node1Index32 * 2, uint16Array1 ),\n\t\t\t\tOFFSET( node2Index32, uint32Array2 ), COUNT( node2Index32 * 2, uint16Array2 ),\n\t\t\t\tdepth1, node1IndexOffset + node1Index32 / UINT32_PER_NODE,\n\t\t\t\tdepth2, node2IndexOffset + node2Index32 / UINT32_PER_NODE,\n\t\t\t);\n\n\t\t}\n\n\t} else if ( isLeaf2 ) {\n\n\t\t// SWAP\n\t\t// If we've traversed to the leaf node on the other bvh then we need to swap over\n\t\t// to traverse down the first one\n\n\t\t// get the new box to use\n\t\tconst newBox = _boxPool.getPrimitive();\n\t\tarrayToBox( BOUNDING_DATA_INDEX( node2Index32 ), float32Array2, newBox );\n\t\tnewBox.applyMatrix4( matrix2to1 );\n\n\t\t// get the child bounds to check before traversal\n\t\tconst cl1 = LEFT_NODE( node1Index32 );\n\t\tconst cr1 = RIGHT_NODE( node1Index32, uint32Array1 );\n\t\tarrayToBox( BOUNDING_DATA_INDEX( cl1 ), float32Array1, _leftBox1 );\n\t\tarrayToBox( BOUNDING_DATA_INDEX( cr1 ), float32Array1, _rightBox1 );\n\n\t\t// precompute the intersections otherwise the global boxes will be modified during traversal\n\t\tconst intersectCl1 = newBox.intersectsBox( _leftBox1 );\n\t\tconst intersectCr1 = newBox.intersectsBox( _rightBox1 );\n\t\tresult = (\n\t\t\tintersectCl1 && _traverse(\n\t\t\t\tnode2Index32, cl1, matrix1to2, matrix2to1, intersectsRangesFunc,\n\t\t\t\tnode2IndexOffset, node1IndexOffset, depth2, depth1 + 1,\n\t\t\t\tnewBox, ! reversed,\n\t\t\t)\n\t\t) || (\n\t\t\tintersectCr1 && _traverse(\n\t\t\t\tnode2Index32, cr1, matrix1to2, matrix2to1, intersectsRangesFunc,\n\t\t\t\tnode2IndexOffset, node1IndexOffset, depth2, depth1 + 1,\n\t\t\t\tnewBox, ! reversed,\n\t\t\t)\n\t\t);\n\n\t\t_boxPool.releasePrimitive( newBox );\n\n\t} else {\n\n\t\t// if neither are leaves then we should swap if one of the children does not\n\t\t// intersect with the current bounds\n\n\t\t// get the child bounds to check\n\t\tconst cl2 = LEFT_NODE( node2Index32 );\n\t\tconst cr2 = RIGHT_NODE( node2Index32, uint32Array2 );\n\t\tarrayToBox( BOUNDING_DATA_INDEX( cl2 ), float32Array2, _leftBox2 );\n\t\tarrayToBox( BOUNDING_DATA_INDEX( cr2 ), float32Array2, _rightBox2 );\n\n\t\tconst leftIntersects = currBox.intersectsBox( _leftBox2 );\n\t\tconst rightIntersects = currBox.intersectsBox( _rightBox2 );\n\t\tif ( leftIntersects && rightIntersects ) {\n\n\t\t\t// continue to traverse both children if they both intersect\n\t\t\tresult = _traverse(\n\t\t\t\tnode1Index32, cl2, matrix2to1, matrix1to2, intersectsRangesFunc,\n\t\t\t\tnode1IndexOffset, node2IndexOffset, depth1, depth2 + 1,\n\t\t\t\tcurrBox, reversed,\n\t\t\t) || _traverse(\n\t\t\t\tnode1Index32, cr2, matrix2to1, matrix1to2, intersectsRangesFunc,\n\t\t\t\tnode1IndexOffset, node2IndexOffset, depth1, depth2 + 1,\n\t\t\t\tcurrBox, reversed,\n\t\t\t);\n\n\t\t} else if ( leftIntersects ) {\n\n\t\t\tif ( isLeaf1 ) {\n\n\t\t\t\t// if the current box is a leaf then just continue\n\t\t\t\tresult = _traverse(\n\t\t\t\t\tnode1Index32, cl2, matrix2to1, matrix1to2, intersectsRangesFunc,\n\t\t\t\t\tnode1IndexOffset, node2IndexOffset, depth1, depth2 + 1,\n\t\t\t\t\tcurrBox, reversed,\n\t\t\t\t);\n\n\t\t\t} else {\n\n\t\t\t\t// SWAP\n\t\t\t\t// if only one box intersects then we have to swap to the other bvh to continue\n\t\t\t\tconst newBox = _boxPool.getPrimitive();\n\t\t\t\tnewBox.copy( _leftBox2 ).applyMatrix4( matrix2to1 );\n\n\t\t\t\tconst cl1 = LEFT_NODE( node1Index32 );\n\t\t\t\tconst cr1 = RIGHT_NODE( node1Index32, uint32Array1 );\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( cl1 ), float32Array1, _leftBox1 );\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( cr1 ), float32Array1, _rightBox1 );\n\n\t\t\t\t// precompute the intersections otherwise the global boxes will be modified during traversal\n\t\t\t\tconst intersectCl1 = newBox.intersectsBox( _leftBox1 );\n\t\t\t\tconst intersectCr1 = newBox.intersectsBox( _rightBox1 );\n\t\t\t\tresult = (\n\t\t\t\t\tintersectCl1 && _traverse(\n\t\t\t\t\t\tcl2, cl1, matrix1to2, matrix2to1, intersectsRangesFunc,\n\t\t\t\t\t\tnode2IndexOffset, node1IndexOffset, depth2, depth1 + 1,\n\t\t\t\t\t\tnewBox, ! reversed,\n\t\t\t\t\t)\n\t\t\t\t) || (\n\t\t\t\t\tintersectCr1 && _traverse(\n\t\t\t\t\t\tcl2, cr1, matrix1to2, matrix2to1, intersectsRangesFunc,\n\t\t\t\t\t\tnode2IndexOffset, node1IndexOffset, depth2, depth1 + 1,\n\t\t\t\t\t\tnewBox, ! reversed,\n\t\t\t\t\t)\n\t\t\t\t);\n\n\t\t\t\t_boxPool.releasePrimitive( newBox );\n\n\t\t\t}\n\n\t\t} else if ( rightIntersects ) {\n\n\t\t\tif ( isLeaf1 ) {\n\n\t\t\t\t// if the current box is a leaf then just continue\n\t\t\t\tresult = _traverse(\n\t\t\t\t\tnode1Index32, cr2, matrix2to1, matrix1to2, intersectsRangesFunc,\n\t\t\t\t\tnode1IndexOffset, node2IndexOffset, depth1, depth2 + 1,\n\t\t\t\t\tcurrBox, reversed,\n\t\t\t\t);\n\n\t\t\t} else {\n\n\t\t\t\t// SWAP\n\t\t\t\t// if only one box intersects then we have to swap to the other bvh to continue\n\t\t\t\tconst newBox = _boxPool.getPrimitive();\n\t\t\t\tnewBox.copy( _rightBox2 ).applyMatrix4( matrix2to1 );\n\n\t\t\t\tconst cl1 = LEFT_NODE( node1Index32 );\n\t\t\t\tconst cr1 = RIGHT_NODE( node1Index32, uint32Array1 );\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( cl1 ), float32Array1, _leftBox1 );\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( cr1 ), float32Array1, _rightBox1 );\n\n\t\t\t\t// precompute the intersections otherwise the global boxes will be modified during traversal\n\t\t\t\tconst intersectCl1 = newBox.intersectsBox( _leftBox1 );\n\t\t\t\tconst intersectCr1 = newBox.intersectsBox( _rightBox1 );\n\t\t\t\tresult = (\n\t\t\t\t\tintersectCl1 && _traverse(\n\t\t\t\t\t\tcr2, cl1, matrix1to2, matrix2to1, intersectsRangesFunc,\n\t\t\t\t\t\tnode2IndexOffset, node1IndexOffset, depth2, depth1 + 1,\n\t\t\t\t\t\tnewBox, ! reversed,\n\t\t\t\t\t)\n\t\t\t\t) || (\n\t\t\t\t\tintersectCr1 && _traverse(\n\t\t\t\t\t\tcr2, cr1, matrix1to2, matrix2to1, intersectsRangesFunc,\n\t\t\t\t\t\tnode2IndexOffset, node1IndexOffset, depth2, depth1 + 1,\n\t\t\t\t\t\tnewBox, ! reversed,\n\t\t\t\t\t)\n\t\t\t\t);\n\n\t\t\t\t_boxPool.releasePrimitive( newBox );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn result;\n\n}\n\n","import { Box3 } from 'three';\nimport { BYTES_PER_NODE, UINT32_PER_NODE, DEFAULT_OPTIONS, FLOAT32_EPSILON } from './Constants.js';\nimport { arrayToBox } from '../utils/ArrayBoxUtilities.js';\nimport { IS_LEAF, LEFT_NODE, RIGHT_NODE, SPLIT_AXIS, COUNT, OFFSET } from './utils/nodeBufferUtils.js';\nimport { buildPackedTree } from './build/buildTree.js';\nimport { shapecast as shapecastFunc } from './cast/shapecast.js';\nimport { bvhcast } from './cast/bvhcast.js';\n\nconst _tempBox = /* @__PURE__ */ new Box3();\nconst _tempBuffer = /* @__PURE__ */ new Float32Array( 6 );\n\nexport class BVH {\n\n\tconstructor() {\n\n\t\tthis._roots = null;\n\t\tthis.primitiveBuffer = null;\n\t\tthis.primitiveBufferStride = null;\n\n\t}\n\n\tinit( options ) {\n\n\t\toptions = {\n\t\t\t...DEFAULT_OPTIONS,\n\t\t\t...options,\n\t\t};\n\n\t\tbuildPackedTree( this, options );\n\n\t}\n\n\tgetRootRanges( /* range */ ) {\n\n\t\t// TODO: can we avoid passing range in here?\n\t\tthrow new Error( 'BVH: getRootRanges() not implemented' );\n\n\t}\n\n\t// write the i-th primitive bounds in a 6-value min / max format to the buffer\n\t// starting at the given \"writeOffset\"\n\twritePrimitiveBounds( /* i, buffer, writeOffset */ ) {\n\n\t\tthrow new Error( 'BVH: writePrimitiveBounds() not implemented' );\n\n\t}\n\n\t// writes the union bounds of all primitives in the given range in a min / max format\n\t// to the buffer\n\twritePrimitiveRangeBounds( offset, count, targetBuffer, baseIndex ) {\n\n\t\t// Initialize bounds\n\t\tlet minX = Infinity;\n\t\tlet minY = Infinity;\n\t\tlet minZ = Infinity;\n\t\tlet maxX = - Infinity;\n\t\tlet maxY = - Infinity;\n\t\tlet maxZ = - Infinity;\n\n\t\t// compute union of all bounds\n\t\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\t\t\tthis.writePrimitiveBounds( i, _tempBuffer, 0 );\n\n\t\t\t// compute union\n\t\t\tconst [ lx, ly, lz, rx, ry, rz ] = _tempBuffer;\n\t\t\tif ( lx < minX ) minX = lx;\n\t\t\tif ( rx > maxX ) maxX = rx;\n\t\t\tif ( ly < minY ) minY = ly;\n\t\t\tif ( ry > maxY ) maxY = ry;\n\t\t\tif ( lz < minZ ) minZ = lz;\n\t\t\tif ( rz > maxZ ) maxZ = rz;\n\n\t\t}\n\n\t\t// write bounds\n\t\ttargetBuffer[ baseIndex + 0 ] = minX;\n\t\ttargetBuffer[ baseIndex + 1 ] = minY;\n\t\ttargetBuffer[ baseIndex + 2 ] = minZ;\n\t\ttargetBuffer[ baseIndex + 3 ] = maxX;\n\t\ttargetBuffer[ baseIndex + 4 ] = maxY;\n\t\ttargetBuffer[ baseIndex + 5 ] = maxZ;\n\n\t\treturn targetBuffer;\n\n\t}\n\n\tcomputePrimitiveBounds( offset, count, targetBuffer ) {\n\n\t\tconst boundsOffset = targetBuffer.offset || 0;\n\t\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\t\t\tthis.writePrimitiveBounds( i, _tempBuffer, 0 );\n\n\t\t\t// construction primitive bounds requires a center + half extents format\n\t\t\tconst [ lx, ly, lz, rx, ry, rz ] = _tempBuffer;\n\n\t\t\tconst cx = ( lx + rx ) / 2;\n\t\t\tconst cy = ( ly + ry ) / 2;\n\t\t\tconst cz = ( lz + rz ) / 2;\n\n\t\t\tconst hx = ( rx - lx ) / 2;\n\t\t\tconst hy = ( ry - ly ) / 2;\n\t\t\tconst hz = ( rz - lz ) / 2;\n\n\t\t\tconst baseIndex = ( i - boundsOffset ) * 6;\n\t\t\ttargetBuffer[ baseIndex + 0 ] = cx;\n\t\t\ttargetBuffer[ baseIndex + 1 ] = hx + ( Math.abs( cx ) + hx ) * FLOAT32_EPSILON;\n\t\t\ttargetBuffer[ baseIndex + 2 ] = cy;\n\t\t\ttargetBuffer[ baseIndex + 3 ] = hy + ( Math.abs( cy ) + hy ) * FLOAT32_EPSILON;\n\t\t\ttargetBuffer[ baseIndex + 4 ] = cz;\n\t\t\ttargetBuffer[ baseIndex + 5 ] = hz + ( Math.abs( cz ) + hz ) * FLOAT32_EPSILON;\n\n\t\t}\n\n\t\treturn targetBuffer;\n\n\t}\n\n\tshiftPrimitiveOffsets( offset ) {\n\n\t\tconst indirectBuffer = this._indirectBuffer;\n\t\tif ( indirectBuffer ) {\n\n\t\t\t// the offsets are embedded in the indirect buffer\n\t\t\tfor ( let i = 0, l = indirectBuffer.length; i < l; i ++ ) {\n\n\t\t\t\tindirectBuffer[ i ] += offset;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// offsets are embedded in the leaf nodes\n\t\t\tconst roots = this._roots;\n\t\t\tfor ( let rootIndex = 0; rootIndex < roots.length; rootIndex ++ ) {\n\n\t\t\t\tconst root = roots[ rootIndex ];\n\t\t\t\tconst uint32Array = new Uint32Array( root );\n\t\t\t\tconst uint16Array = new Uint16Array( root );\n\t\t\t\tconst totalNodes = root.byteLength / BYTES_PER_NODE;\n\t\t\t\tfor ( let node = 0; node < totalNodes; node ++ ) {\n\n\t\t\t\t\tconst node32Index = UINT32_PER_NODE * node;\n\t\t\t\t\tconst node16Index = 2 * node32Index;\n\t\t\t\t\tif ( IS_LEAF( node16Index, uint16Array ) ) {\n\n\t\t\t\t\t\t// offset value\n\t\t\t\t\t\tuint32Array[ node32Index + 6 ] += offset;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\ttraverse( callback, rootIndex = 0 ) {\n\n\t\tconst buffer = this._roots[ rootIndex ];\n\t\tconst uint32Array = new Uint32Array( buffer );\n\t\tconst uint16Array = new Uint16Array( buffer );\n\t\t_traverse( 0 );\n\n\t\tfunction _traverse( node32Index, depth = 0 ) {\n\n\t\t\tconst node16Index = node32Index * 2;\n\t\t\tconst isLeaf = IS_LEAF( node16Index, uint16Array );\n\t\t\tif ( isLeaf ) {\n\n\t\t\t\tconst offset = uint32Array[ node32Index + 6 ];\n\t\t\t\tconst count = uint16Array[ node16Index + 14 ];\n\t\t\t\tcallback( depth, isLeaf, new Float32Array( buffer, node32Index * 4, 6 ), offset, count );\n\n\t\t\t} else {\n\n\t\t\t\tconst left = LEFT_NODE( node32Index );\n\t\t\t\tconst right = RIGHT_NODE( node32Index, uint32Array );\n\t\t\t\tconst splitAxis = SPLIT_AXIS( node32Index, uint32Array );\n\t\t\t\tconst stopTraversal = callback( depth, isLeaf, new Float32Array( buffer, node32Index * 4, 6 ), splitAxis );\n\n\t\t\t\tif ( ! stopTraversal ) {\n\n\t\t\t\t\t_traverse( left, depth + 1 );\n\t\t\t\t\t_traverse( right, depth + 1 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\trefit( /* nodeIndices = null */ ) {\n\n\t\t// TODO: add support for \"nodeIndices\"\n\t\t// if ( nodeIndices && Array.isArray( nodeIndices ) ) {\n\n\t\t// \tnodeIndices = new Set( nodeIndices );\n\n\t\t// }\n\n\t\tconst roots = this._roots;\n\t\tfor ( let rootIndex = 0, rootCount = roots.length; rootIndex < rootCount; rootIndex ++ ) {\n\n\t\t\tconst buffer = roots[ rootIndex ];\n\t\t\tconst uint32Array = new Uint32Array( buffer );\n\t\t\tconst uint16Array = new Uint16Array( buffer );\n\t\t\tconst float32Array = new Float32Array( buffer );\n\t\t\tconst totalNodes = buffer.byteLength / BYTES_PER_NODE;\n\n\t\t\t// Traverse nodes from right to left so children are updated before parents\n\t\t\tfor ( let nodeIndex = totalNodes - 1; nodeIndex >= 0; nodeIndex -- ) {\n\n\t\t\t\tconst nodeIndex32 = nodeIndex * UINT32_PER_NODE;\n\t\t\t\tconst nodeIndex16 = nodeIndex32 * 2;\n\t\t\t\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\n\t\t\t\tif ( isLeaf ) {\n\n\t\t\t\t\t// get the bounds\n\t\t\t\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\t\t\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\t\t\t\t\tthis.writePrimitiveRangeBounds( offset, count, _tempBuffer, 0 );\n\n\t\t\t\t\t// write directly to node bounds (already in min/max format)\n\t\t\t\t\tfloat32Array.set( _tempBuffer, nodeIndex32 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconst left = LEFT_NODE( nodeIndex32 );\n\t\t\t\t\tconst right = RIGHT_NODE( nodeIndex32, uint32Array );\n\n\t\t\t\t\t// Union the bounds of left and right children\n\t\t\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\t\tconst leftMin = float32Array[ left + i ];\n\t\t\t\t\t\tconst leftMax = float32Array[ left + i + 3 ];\n\t\t\t\t\t\tconst rightMin = float32Array[ right + i ];\n\t\t\t\t\t\tconst rightMax = float32Array[ right + i + 3 ];\n\n\t\t\t\t\t\tfloat32Array[ nodeIndex32 + i ] = leftMin < rightMin ? leftMin : rightMin;\n\t\t\t\t\t\tfloat32Array[ nodeIndex32 + i + 3 ] = leftMax > rightMax ? leftMax : rightMax;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tgetBoundingBox( target ) {\n\n\t\ttarget.makeEmpty();\n\n\t\tconst roots = this._roots;\n\t\troots.forEach( buffer => {\n\n\t\t\tarrayToBox( 0, new Float32Array( buffer ), _tempBox );\n\t\t\ttarget.union( _tempBox );\n\n\t\t} );\n\n\t\treturn target;\n\n\t}\n\n\t// Base shapecast implementation that can be used by subclasses\n\t// TODO: see if we can get rid of \"iterateFunc\" here as well as the primitive so the function\n\t// API aligns with the \"shapecast\" implementation\n\tshapecast( callbacks ) {\n\n\t\t// TODO: can we get rid of \"scratchPrimitive\" and / or \"iterate\"? Or merge them somehow\n\t\tlet {\n\t\t\tboundsTraverseOrder,\n\t\t\tintersectsBounds,\n\t\t\tintersectsRange,\n\t\t\tintersectsPrimitive,\n\t\t\tscratchPrimitive,\n\t\t\titerate,\n\t\t} = callbacks;\n\n\t\t// wrap the intersectsRange function\n\t\tif ( intersectsRange && intersectsPrimitive ) {\n\n\t\t\tconst originalIntersectsRange = intersectsRange;\n\t\t\tintersectsRange = ( offset, count, contained, depth, nodeIndex ) => {\n\n\t\t\t\tif ( ! originalIntersectsRange( offset, count, contained, depth, nodeIndex ) ) {\n\n\t\t\t\t\treturn iterate( offset, count, this, intersectsPrimitive, contained, depth, scratchPrimitive );\n\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\n\t\t\t};\n\n\t\t} else if ( ! intersectsRange ) {\n\n\t\t\tif ( intersectsPrimitive ) {\n\n\t\t\t\tintersectsRange = ( offset, count, contained, depth ) => {\n\n\t\t\t\t\treturn iterate( offset, count, this, intersectsPrimitive, contained, depth, scratchPrimitive );\n\n\t\t\t\t};\n\n\t\t\t} else {\n\n\t\t\t\tintersectsRange = ( offset, count, contained ) => {\n\n\t\t\t\t\treturn contained;\n\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t}\n\n\t\t// run shapecast\n\t\tlet result = false;\n\t\tlet nodeOffset = 0;\n\t\tconst roots = this._roots;\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\t\tconst root = roots[ i ];\n\t\t\tresult = shapecastFunc( this, i, intersectsBounds, intersectsRange, boundsTraverseOrder, nodeOffset );\n\n\t\t\tif ( result ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tnodeOffset += root.byteLength / BYTES_PER_NODE;\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tbvhcast( otherBvh, matrixToLocal, callbacks ) {\n\n\t\tlet { intersectsRanges } = callbacks;\n\t\treturn bvhcast( this, otherBvh, matrixToLocal, intersectsRanges );\n\n\n\t}\n\n}\n","export function isSharedArrayBufferSupported() {\n\n\treturn typeof SharedArrayBuffer !== 'undefined';\n\n}\n\nexport function convertToBufferType( array, BufferConstructor ) {\n\n\tif ( array === null ) {\n\n\t\treturn array;\n\n\t} else if ( array.buffer ) {\n\n\t\tconst buffer = array.buffer;\n\t\tif ( buffer.constructor === BufferConstructor ) {\n\n\t\t\treturn array;\n\n\t\t}\n\n\t\tconst ArrayConstructor = array.constructor;\n\t\tconst result = new ArrayConstructor( new BufferConstructor( buffer.byteLength ) );\n\t\tresult.set( array );\n\t\treturn result;\n\n\t} else {\n\n\t\tif ( array.constructor === BufferConstructor ) {\n\n\t\t\treturn array;\n\n\t\t}\n\n\t\tconst result = new BufferConstructor( array.byteLength );\n\t\tnew Uint8Array( result ).set( new Uint8Array( array ) );\n\t\treturn result;\n\n\t}\n\n}\n","import { BufferAttribute } from 'three';\n\nexport function getVertexCount( geo ) {\n\n\treturn geo.index ? geo.index.count : geo.attributes.position.count;\n\n}\n\nexport function getTriCount( geo ) {\n\n\treturn getVertexCount( geo ) / 3;\n\n}\n\nexport function getIndexArray( vertexCount, BufferConstructor = ArrayBuffer ) {\n\n\tif ( vertexCount > 65535 ) {\n\n\t\treturn new Uint32Array( new BufferConstructor( 4 * vertexCount ) );\n\n\t} else {\n\n\t\treturn new Uint16Array( new BufferConstructor( 2 * vertexCount ) );\n\n\t}\n\n}\n\n// ensures that an index is present on the geometry\nexport function ensureIndex( geo, options ) {\n\n\tif ( ! geo.index ) {\n\n\t\tconst vertexCount = geo.attributes.position.count;\n\t\tconst BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;\n\t\tconst index = getIndexArray( vertexCount, BufferConstructor );\n\t\tgeo.setIndex( new BufferAttribute( index, 1 ) );\n\n\t\tfor ( let i = 0; i < vertexCount; i ++ ) {\n\n\t\t\tindex[ i ] = i;\n\n\t\t}\n\n\t}\n\n}\n\n// Computes the set of { offset, count } ranges which need independent BVH roots. Each\n// region in the geometry index that belongs to a different set of material groups requires\n// a separate BVH root, so that triangles indices belonging to one group never get swapped\n// with triangle indices belongs to another group. For example, if the groups were like this:\n//\n// [-------------------------------------------------------------]\n// |__________________|\n//   g0 = [0, 20]  |______________________||_____________________|\n//                      g1 = [16, 40]           g2 = [41, 60]\n//\n// we would need four BVH roots: [0, 15], [16, 20], [21, 40], [41, 60].\nfunction getFullPrimitiveRange( geo, range, stride ) {\n\n\tconst primitiveCount = getVertexCount( geo ) / stride;\n\tconst drawRange = range ? range : geo.drawRange;\n\tconst start = drawRange.start / stride;\n\tconst end = ( drawRange.start + drawRange.count ) / stride;\n\n\tconst offset = Math.max( 0, start );\n\tconst count = Math.min( primitiveCount, end ) - offset;\n\treturn {\n\t\toffset: Math.floor( offset ),\n\t\tcount: Math.floor( count ),\n\t};\n\n}\n\nfunction getPrimitiveGroupRanges( geo, stride ) {\n\n\treturn geo.groups.map( group => ( {\n\t\toffset: group.start / stride,\n\t\tcount: group.count / stride,\n\t} ));\n\n}\n\n// Function that extracts a set of mutually exclusive ranges representing the primitives being\n// drawn as determined by the geometry groups, draw range, and user specified range\nexport function getRootPrimitiveRanges( geo, range, stride ) {\n\n\tconst drawRange = getFullPrimitiveRange( geo, range, stride );\n\tconst primitiveRanges = getPrimitiveGroupRanges( geo, stride );\n\tif ( ! primitiveRanges.length ) {\n\n\t\treturn [ drawRange ];\n\n\t}\n\n\tconst ranges = [];\n\tconst drawRangeStart = drawRange.offset;\n\tconst drawRangeEnd = drawRange.offset + drawRange.count;\n\n\t// Create events for group boundaries\n\tconst primitiveCount = getVertexCount( geo ) / stride;\n\tconst events = [];\n\tfor ( const group of primitiveRanges ) {\n\n\t\t// Account for cases where group size is set to Infinity\n\t\tconst { offset, count } = group;\n\t\tconst groupStart = offset;\n\t\tconst groupCount = isFinite( count ) ? count : ( primitiveCount - offset );\n\t\tconst groupEnd = ( offset + groupCount );\n\n\t\t// Only add events if the group intersects with the draw range\n\t\tif ( groupStart < drawRangeEnd && groupEnd > drawRangeStart ) {\n\n\t\t\tevents.push( { pos: Math.max( drawRangeStart, groupStart ), isStart: true } );\n\t\t\tevents.push( { pos: Math.min( drawRangeEnd, groupEnd ), isStart: false } );\n\n\t\t}\n\n\t}\n\n\t// Sort events by position, with 'end' events before 'start' events at the same position\n\tevents.sort( ( a, b ) => {\n\n\t\tif ( a.pos !== b.pos ) {\n\n\t\t\treturn a.pos - b.pos;\n\n\t\t} else {\n\n\t\t\treturn a.type === 'end' ? - 1 : 1;\n\n\t\t}\n\n\t} );\n\n\t// sweep through events and create ranges where activeGroups > 0\n\tlet activeGroups = 0;\n\tlet lastPos = null;\n\tfor ( const event of events ) {\n\n\t\tconst newPos = event.pos;\n\t\tif ( activeGroups !== 0 && newPos !== lastPos ) {\n\n\t\t\tranges.push( {\n\t\t\t\toffset: lastPos,\n\t\t\t\tcount: newPos - lastPos,\n\t\t\t} );\n\n\t\t}\n\n\t\tactiveGroups += event.isStart ? 1 : - 1;\n\t\tlastPos = newPos;\n\n\t}\n\n\treturn ranges;\n\n}\n","import { Box3 } from 'three';\nimport { SKIP_GENERATION, DEFAULT_OPTIONS } from './Constants.js';\nimport { isSharedArrayBufferSupported } from '../utils/BufferUtils.js';\nimport { ensureIndex, getRootPrimitiveRanges } from './build/geometryUtils.js';\nimport { BVH } from './BVH.js';\n\n// construct a new buffer that points to the set of triangles represented by the given ranges\nexport function generateIndirectBuffer( ranges, useSharedArrayBuffer ) {\n\n\tconst lastRange = ranges[ ranges.length - 1 ];\n\tconst useUint32 = lastRange.offset + lastRange.count > 2 ** 16;\n\n\t// use getRootIndexRanges which excludes gaps\n\tconst length = ranges.reduce( ( acc, val ) => acc + val.count, 0 );\n\tconst byteCount = useUint32 ? 4 : 2;\n\tconst buffer = useSharedArrayBuffer ? new SharedArrayBuffer( length * byteCount ) : new ArrayBuffer( length * byteCount );\n\tconst indirectBuffer = useUint32 ? new Uint32Array( buffer ) : new Uint16Array( buffer );\n\n\t// construct a compact form of the triangles in these ranges\n\tlet index = 0;\n\tfor ( let r = 0; r < ranges.length; r ++ ) {\n\n\t\tconst { offset, count } = ranges[ r ];\n\t\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\t\tindirectBuffer[ index + i ] = offset + i;\n\n\t\t}\n\n\t\tindex += count;\n\n\t}\n\n\treturn indirectBuffer;\n\n}\n\nexport class GeometryBVH extends BVH {\n\n\tget indirect() {\n\n\t\treturn ! ! this._indirectBuffer;\n\n\t}\n\n\tget primitiveStride() {\n\n\t\treturn null;\n\n\t}\n\n\tget primitiveBufferStride() {\n\n\t\treturn this.indirect ? 1 : this.primitiveStride;\n\n\t}\n\tset primitiveBufferStride( v ) {}\n\n\tget primitiveBuffer() {\n\n\t\treturn this.indirect ? this._indirectBuffer : this.geometry.index.array;\n\n\t}\n\tset primitiveBuffer( v ) {}\n\n\tconstructor( geometry, options = {} ) {\n\n\t\tif ( ! geometry.isBufferGeometry ) {\n\n\t\t\tthrow new Error( 'BVH: Only BufferGeometries are supported.' );\n\n\t\t} else if ( geometry.index && geometry.index.isInterleavedBufferAttribute ) {\n\n\t\t\tthrow new Error( 'BVH: InterleavedBufferAttribute is not supported for the index attribute.' );\n\n\t\t}\n\n\t\tif ( options.useSharedArrayBuffer && ! isSharedArrayBufferSupported() ) {\n\n\t\t\tthrow new Error( 'BVH: SharedArrayBuffer is not available.' );\n\n\t\t}\n\n\t\tsuper();\n\n\t\t// retain references to the geometry so we can use them it without having to\n\t\t// take a geometry reference in every function.\n\t\tthis.geometry = geometry;\n\t\tthis.resolvePrimitiveIndex = options.indirect ? i => this._indirectBuffer[ i ] : i => i;\n\t\tthis.primitiveBuffer = null;\n\t\tthis.primitiveBufferStride = null;\n\t\tthis._indirectBuffer = null;\n\n\t\toptions = {\n\t\t\t...DEFAULT_OPTIONS,\n\t\t\t...options,\n\t\t};\n\n\t\t// build the BVH unless we're deserializing\n\t\tif ( ! options[ SKIP_GENERATION ] ) {\n\n\t\t\tthis.init( options );\n\n\t\t}\n\n\t}\n\n\tinit( options ) {\n\n\t\tconst { geometry, primitiveStride } = this;\n\n\t\tif ( options.indirect ) {\n\n\t\t\t// construct an buffer that is indirectly sorts the triangles used for the BVH\n\t\t\tconst ranges = getRootPrimitiveRanges( geometry, options.range, primitiveStride );\n\t\t\tconst indirectBuffer = generateIndirectBuffer( ranges, options.useSharedArrayBuffer );\n\t\t\tthis._indirectBuffer = indirectBuffer;\n\n\t\t} else {\n\n\t\t\tensureIndex( geometry, options );\n\n\t\t}\n\n\t\tsuper.init( options );\n\n\t\tif ( ! geometry.boundingBox && options.setBoundingBox ) {\n\n\t\t\tgeometry.boundingBox = this.getBoundingBox( new Box3() );\n\n\t\t}\n\n\t}\n\n\t// Abstract methods to be implemented by subclasses\n\tgetRootRanges( range ) {\n\n\t\t// TODO: can we avoid passing options in here\n\t\tif ( this.indirect ) {\n\n\t\t\treturn [ { offset: 0, count: this._indirectBuffer.length } ];\n\n\n\t\t} else {\n\n\t\t\treturn getRootPrimitiveRanges( this.geometry, range, this.primitiveStride );\n\n\t\t}\n\n\t}\n\n\traycastObject3D( /* object, raycaster, intersects = [] */ ) {\n\n\t\tthrow new Error( 'BVH: raycastObject3D() not implemented' );\n\n\t}\n\n}\n","import { Vector3 } from 'three';\n\nexport class SeparatingAxisBounds {\n\n\tconstructor() {\n\n\t\tthis.min = Infinity;\n\t\tthis.max = - Infinity;\n\n\t}\n\n\tsetFromPointsField( points, field ) {\n\n\t\tlet min = Infinity;\n\t\tlet max = - Infinity;\n\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\tconst p = points[ i ];\n\t\t\tconst val = p[ field ];\n\t\t\tmin = val < min ? val : min;\n\t\t\tmax = val > max ? val : max;\n\n\t\t}\n\n\t\tthis.min = min;\n\t\tthis.max = max;\n\n\t}\n\n\tsetFromPoints( axis, points ) {\n\n\t\tlet min = Infinity;\n\t\tlet max = - Infinity;\n\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\tconst p = points[ i ];\n\t\t\tconst val = axis.dot( p );\n\t\t\tmin = val < min ? val : min;\n\t\t\tmax = val > max ? val : max;\n\n\t\t}\n\n\t\tthis.min = min;\n\t\tthis.max = max;\n\n\t}\n\n\tisSeparated( other ) {\n\n\t\treturn this.min > other.max || other.min > this.max;\n\n\t}\n\n}\n\nSeparatingAxisBounds.prototype.setFromBox = ( function () {\n\n\tconst p = /* @__PURE__ */ new Vector3();\n\treturn function setFromBox( axis, box ) {\n\n\t\tconst boxMin = box.min;\n\t\tconst boxMax = box.max;\n\t\tlet min = Infinity;\n\t\tlet max = - Infinity;\n\t\tfor ( let x = 0; x <= 1; x ++ ) {\n\n\t\t\tfor ( let y = 0; y <= 1; y ++ ) {\n\n\t\t\t\tfor ( let z = 0; z <= 1; z ++ ) {\n\n\t\t\t\t\tp.x = boxMin.x * x + boxMax.x * ( 1 - x );\n\t\t\t\t\tp.y = boxMin.y * y + boxMax.y * ( 1 - y );\n\t\t\t\t\tp.z = boxMin.z * z + boxMax.z * ( 1 - z );\n\n\t\t\t\t\tconst val = axis.dot( p );\n\t\t\t\t\tmin = Math.min( val, min );\n\t\t\t\t\tmax = Math.max( val, max );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.min = min;\n\t\tthis.max = max;\n\n\t};\n\n} )();\n\nexport const areIntersecting = ( function () {\n\n\tconst cacheSatBounds = /* @__PURE__ */ new SeparatingAxisBounds();\n\treturn function areIntersecting( shape1, shape2 ) {\n\n\t\tconst points1 = shape1.points;\n\t\tconst satAxes1 = shape1.satAxes;\n\t\tconst satBounds1 = shape1.satBounds;\n\n\t\tconst points2 = shape2.points;\n\t\tconst satAxes2 = shape2.satAxes;\n\t\tconst satBounds2 = shape2.satBounds;\n\n\t\t// check axes of the first shape\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst sb = satBounds1[ i ];\n\t\t\tconst sa = satAxes1[ i ];\n\t\t\tcacheSatBounds.setFromPoints( sa, points2 );\n\t\t\tif ( sb.isSeparated( cacheSatBounds ) ) return false;\n\n\t\t}\n\n\t\t// check axes of the second shape\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst sb = satBounds2[ i ];\n\t\t\tconst sa = satAxes2[ i ];\n\t\t\tcacheSatBounds.setFromPoints( sa, points1 );\n\t\t\tif ( sb.isSeparated( cacheSatBounds ) ) return false;\n\n\t\t}\n\n\t};\n\n} )();\n","import { Vector3, Vector2, Plane, Line3 } from 'three';\n\nexport const closestPointLineToLine = ( function () {\n\n\t// https://github.com/juj/MathGeoLib/blob/master/src/Geometry/Line.cpp#L56\n\tconst dir1 = /* @__PURE__ */ new Vector3();\n\tconst dir2 = /* @__PURE__ */ new Vector3();\n\tconst v02 = /* @__PURE__ */ new Vector3();\n\treturn function closestPointLineToLine( l1, l2, result ) {\n\n\t\tconst v0 = l1.start;\n\t\tconst v10 = dir1;\n\t\tconst v2 = l2.start;\n\t\tconst v32 = dir2;\n\n\t\tv02.subVectors( v0, v2 );\n\t\tdir1.subVectors( l1.end, l1.start );\n\t\tdir2.subVectors( l2.end, l2.start );\n\n\t\t// float d0232 = v02.Dot(v32);\n\t\tconst d0232 = v02.dot( v32 );\n\n\t\t// float d3210 = v32.Dot(v10);\n\t\tconst d3210 = v32.dot( v10 );\n\n\t\t// float d3232 = v32.Dot(v32);\n\t\tconst d3232 = v32.dot( v32 );\n\n\t\t// float d0210 = v02.Dot(v10);\n\t\tconst d0210 = v02.dot( v10 );\n\n\t\t// float d1010 = v10.Dot(v10);\n\t\tconst d1010 = v10.dot( v10 );\n\n\t\t// float denom = d1010*d3232 - d3210*d3210;\n\t\tconst denom = d1010 * d3232 - d3210 * d3210;\n\n\t\tlet d, d2;\n\t\tif ( denom !== 0 ) {\n\n\t\t\td = ( d0232 * d3210 - d0210 * d3232 ) / denom;\n\n\t\t} else {\n\n\t\t\td = 0;\n\n\t\t}\n\n\t\td2 = ( d0232 + d * d3210 ) / d3232;\n\n\t\tresult.x = d;\n\t\tresult.y = d2;\n\n\t};\n\n} )();\n\nexport const closestPointsSegmentToSegment = ( function () {\n\n\t// https://github.com/juj/MathGeoLib/blob/master/src/Geometry/LineSegment.cpp#L187\n\tconst paramResult = /* @__PURE__ */ new Vector2();\n\tconst temp1 = /* @__PURE__ */ new Vector3();\n\tconst temp2 = /* @__PURE__ */ new Vector3();\n\treturn function closestPointsSegmentToSegment( l1, l2, target1, target2 ) {\n\n\t\tclosestPointLineToLine( l1, l2, paramResult );\n\n\t\tlet d = paramResult.x;\n\t\tlet d2 = paramResult.y;\n\t\tif ( d >= 0 && d <= 1 && d2 >= 0 && d2 <= 1 ) {\n\n\t\t\tl1.at( d, target1 );\n\t\t\tl2.at( d2, target2 );\n\n\t\t\treturn;\n\n\t\t} else if ( d >= 0 && d <= 1 ) {\n\n\t\t\t// Only d2 is out of bounds.\n\t\t\tif ( d2 < 0 ) {\n\n\t\t\t\tl2.at( 0, target2 );\n\n\t\t\t} else {\n\n\t\t\t\tl2.at( 1, target2 );\n\n\t\t\t}\n\n\t\t\tl1.closestPointToPoint( target2, true, target1 );\n\t\t\treturn;\n\n\t\t} else if ( d2 >= 0 && d2 <= 1 ) {\n\n\t\t\t// Only d is out of bounds.\n\t\t\tif ( d < 0 ) {\n\n\t\t\t\tl1.at( 0, target1 );\n\n\t\t\t} else {\n\n\t\t\t\tl1.at( 1, target1 );\n\n\t\t\t}\n\n\t\t\tl2.closestPointToPoint( target1, true, target2 );\n\t\t\treturn;\n\n\t\t} else {\n\n\t\t\t// Both u and u2 are out of bounds.\n\t\t\tlet p;\n\t\t\tif ( d < 0 ) {\n\n\t\t\t\tp = l1.start;\n\n\t\t\t} else {\n\n\t\t\t\tp = l1.end;\n\n\t\t\t}\n\n\t\t\tlet p2;\n\t\t\tif ( d2 < 0 ) {\n\n\t\t\t\tp2 = l2.start;\n\n\t\t\t} else {\n\n\t\t\t\tp2 = l2.end;\n\n\t\t\t}\n\n\t\t\tconst closestPoint = temp1;\n\t\t\tconst closestPoint2 = temp2;\n\t\t\tl1.closestPointToPoint( p2, true, temp1 );\n\t\t\tl2.closestPointToPoint( p, true, temp2 );\n\n\t\t\tif ( closestPoint.distanceToSquared( p2 ) <= closestPoint2.distanceToSquared( p ) ) {\n\n\t\t\t\ttarget1.copy( closestPoint );\n\t\t\t\ttarget2.copy( p2 );\n\t\t\t\treturn;\n\n\t\t\t} else {\n\n\t\t\t\ttarget1.copy( p );\n\t\t\t\ttarget2.copy( closestPoint2 );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n} )();\n\n\nexport const sphereIntersectTriangle = ( function () {\n\n\t// https://stackoverflow.com/questions/34043955/detect-collision-between-sphere-and-triangle-in-three-js\n\tconst closestPointTemp = /* @__PURE__ */ new Vector3();\n\tconst projectedPointTemp = /* @__PURE__ */ new Vector3();\n\tconst planeTemp = /* @__PURE__ */ new Plane();\n\tconst lineTemp = /* @__PURE__ */ new Line3();\n\treturn function sphereIntersectTriangle( sphere, triangle ) {\n\n\t\tconst { radius, center } = sphere;\n\t\tconst { a, b, c } = triangle;\n\n\t\t// phase 1\n\t\tlineTemp.start = a;\n\t\tlineTemp.end = b;\n\t\tconst closestPoint1 = lineTemp.closestPointToPoint( center, true, closestPointTemp );\n\t\tif ( closestPoint1.distanceTo( center ) <= radius ) return true;\n\n\t\tlineTemp.start = a;\n\t\tlineTemp.end = c;\n\t\tconst closestPoint2 = lineTemp.closestPointToPoint( center, true, closestPointTemp );\n\t\tif ( closestPoint2.distanceTo( center ) <= radius ) return true;\n\n\t\tlineTemp.start = b;\n\t\tlineTemp.end = c;\n\t\tconst closestPoint3 = lineTemp.closestPointToPoint( center, true, closestPointTemp );\n\t\tif ( closestPoint3.distanceTo( center ) <= radius ) return true;\n\n\t\t// phase 2\n\t\tconst plane = triangle.getPlane( planeTemp );\n\t\tconst dp = Math.abs( plane.distanceToPoint( center ) );\n\t\tif ( dp <= radius ) {\n\n\t\t\tconst pp = plane.projectPoint( center, projectedPointTemp );\n\t\t\tconst cp = triangle.containsPoint( pp );\n\t\t\tif ( cp ) return true;\n\n\t\t}\n\n\t\treturn false;\n\n\t};\n\n} )();\n","import { Triangle, Vector3, Vector2, Line3, Plane } from 'three';\nimport { SeparatingAxisBounds } from './SeparatingAxisBounds.js';\nimport { closestPointsSegmentToSegment, sphereIntersectTriangle } from './MathUtilities.js';\n\nconst componentKeys = [ 'x', 'y', 'z' ];\nconst ZERO_EPSILON = 1e-15;\nconst ZERO_EPSILON_SQR = ZERO_EPSILON * ZERO_EPSILON;\nfunction isNearZero( value ) {\n\n\treturn Math.abs( value ) < ZERO_EPSILON;\n\n}\n\nexport class ExtendedTriangle extends Triangle {\n\n\tconstructor( ...args ) {\n\n\t\tsuper( ...args );\n\n\t\tthis.isExtendedTriangle = true;\n\t\tthis.satAxes = new Array( 4 ).fill().map( () => new Vector3() );\n\t\tthis.satBounds = new Array( 4 ).fill().map( () => new SeparatingAxisBounds() );\n\t\tthis.points = [ this.a, this.b, this.c ];\n\t\tthis.plane = new Plane();\n\t\tthis.isDegenerateIntoSegment = false;\n\t\tthis.isDegenerateIntoPoint = false;\n\t\tthis.degenerateSegment = new Line3();\n\t\tthis.needsUpdate = true;\n\n\t}\n\n\tintersectsSphere( sphere ) {\n\n\t\treturn sphereIntersectTriangle( sphere, this );\n\n\t}\n\n\tupdate() {\n\n\t\tconst a = this.a;\n\t\tconst b = this.b;\n\t\tconst c = this.c;\n\t\tconst points = this.points;\n\n\t\tconst satAxes = this.satAxes;\n\t\tconst satBounds = this.satBounds;\n\n\t\tconst axis0 = satAxes[ 0 ];\n\t\tconst sab0 = satBounds[ 0 ];\n\t\tthis.getNormal( axis0 );\n\t\tsab0.setFromPoints( axis0, points );\n\n\t\tconst axis1 = satAxes[ 1 ];\n\t\tconst sab1 = satBounds[ 1 ];\n\t\taxis1.subVectors( a, b );\n\t\tsab1.setFromPoints( axis1, points );\n\n\t\tconst axis2 = satAxes[ 2 ];\n\t\tconst sab2 = satBounds[ 2 ];\n\t\taxis2.subVectors( b, c );\n\t\tsab2.setFromPoints( axis2, points );\n\n\t\tconst axis3 = satAxes[ 3 ];\n\t\tconst sab3 = satBounds[ 3 ];\n\t\taxis3.subVectors( c, a );\n\t\tsab3.setFromPoints( axis3, points );\n\n\t\tconst lengthAB = axis1.length();\n\t\tconst lengthBC = axis2.length();\n\t\tconst lengthCA = axis3.length();\n\n\t\tthis.isDegenerateIntoPoint = false;\n\t\tthis.isDegenerateIntoSegment = false;\n\n\t\tif ( lengthAB < ZERO_EPSILON ) {\n\n\t\t\tif ( lengthBC < ZERO_EPSILON || lengthCA < ZERO_EPSILON ) {\n\n\t\t\t\tthis.isDegenerateIntoPoint = true;\n\n\t\t\t} else {\n\n\t\t\t\tthis.isDegenerateIntoSegment = true;\n\t\t\t\tthis.degenerateSegment.start.copy( a );\n\t\t\t\tthis.degenerateSegment.end.copy( c );\n\n\t\t\t}\n\n\t\t} else if ( lengthBC < ZERO_EPSILON ) {\n\n\t\t\tif ( lengthCA < ZERO_EPSILON ) {\n\n\t\t\t\tthis.isDegenerateIntoPoint = true;\n\n\t\t\t} else {\n\n\t\t\t\tthis.isDegenerateIntoSegment = true;\n\t\t\t\tthis.degenerateSegment.start.copy( b );\n\t\t\t\tthis.degenerateSegment.end.copy( a );\n\n\t\t\t}\n\n\t\t} else if ( lengthCA < ZERO_EPSILON ) {\n\n\t\t\tthis.isDegenerateIntoSegment = true;\n\t\t\tthis.degenerateSegment.start.copy( c );\n\t\t\tthis.degenerateSegment.end.copy( b );\n\n\t\t}\n\n\t\tthis.plane.setFromNormalAndCoplanarPoint( axis0, a );\n\n\t\tthis.needsUpdate = false;\n\n\t}\n\n}\n\nExtendedTriangle.prototype.closestPointToSegment = ( function () {\n\n\tconst point1 = /* @__PURE__ */ new Vector3();\n\tconst point2 = /* @__PURE__ */ new Vector3();\n\tconst edge = /* @__PURE__ */ new Line3();\n\n\treturn function distanceToSegment( segment, target1 = null, target2 = null ) {\n\n\t\tconst { start, end } = segment;\n\t\tconst points = this.points;\n\t\tlet distSq;\n\t\tlet closestDistanceSq = Infinity;\n\n\t\t// check the triangle edges\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst nexti = ( i + 1 ) % 3;\n\t\t\tedge.start.copy( points[ i ] );\n\t\t\tedge.end.copy( points[ nexti ] );\n\n\t\t\tclosestPointsSegmentToSegment( edge, segment, point1, point2 );\n\n\t\t\tdistSq = point1.distanceToSquared( point2 );\n\t\t\tif ( distSq < closestDistanceSq ) {\n\n\t\t\t\tclosestDistanceSq = distSq;\n\t\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// check end points\n\t\tthis.closestPointToPoint( start, point1 );\n\t\tdistSq = start.distanceToSquared( point1 );\n\t\tif ( distSq < closestDistanceSq ) {\n\n\t\t\tclosestDistanceSq = distSq;\n\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\tif ( target2 ) target2.copy( start );\n\n\t\t}\n\n\t\tthis.closestPointToPoint( end, point1 );\n\t\tdistSq = end.distanceToSquared( point1 );\n\t\tif ( distSq < closestDistanceSq ) {\n\n\t\t\tclosestDistanceSq = distSq;\n\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\tif ( target2 ) target2.copy( end );\n\n\t\t}\n\n\t\treturn Math.sqrt( closestDistanceSq );\n\n\t};\n\n} )();\n\nExtendedTriangle.prototype.intersectsTriangle = ( function () {\n\n\tconst saTri2 = /* @__PURE__ */ new ExtendedTriangle();\n\tconst cachedSatBounds = /* @__PURE__ */ new SeparatingAxisBounds();\n\tconst cachedSatBounds2 = /* @__PURE__ */ new SeparatingAxisBounds();\n\tconst tmpVec = /* @__PURE__ */ new Vector3();\n\tconst dir1 = /* @__PURE__ */ new Vector3();\n\tconst dir2 = /* @__PURE__ */ new Vector3();\n\tconst tempDir = /* @__PURE__ */ new Vector3();\n\tconst edge1 = /* @__PURE__ */ new Line3();\n\tconst edge2 = /* @__PURE__ */ new Line3();\n\tconst tempPoint = /* @__PURE__ */ new Vector3();\n\tconst bounds1 = /* @__PURE__ */ new Vector2();\n\tconst bounds2 = /* @__PURE__ */ new Vector2();\n\n\tfunction coplanarIntersectsTriangle( self, other, target, suppressLog ) {\n\n\t\t// Perform separating axis intersection test only for coplanar triangles\n\t\t// There should be at least one non-degenerate triangle when calling this\n\t\t// Otherwise we won't know the plane normal\n\t\tconst planeNormal = tmpVec;\n\t\tif ( ! self.isDegenerateIntoPoint && ! self.isDegenerateIntoSegment ) {\n\n\t\t\tplaneNormal.copy( self.plane.normal );\n\n\t\t} else {\n\n\t\t\tplaneNormal.copy( other.plane.normal );\n\n\t\t}\n\n\t\tconst satBounds1 = self.satBounds;\n\t\tconst satAxes1 = self.satAxes;\n\t\tfor ( let i = 1; i < 4; i ++ ) {\n\n\t\t\tconst sb = satBounds1[ i ];\n\t\t\tconst sa = satAxes1[ i ];\n\t\t\tcachedSatBounds.setFromPoints( sa, other.points );\n\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\n\n\t\t\ttempDir.copy( planeNormal ).cross( sa );\n\t\t\tcachedSatBounds.setFromPoints( tempDir, self.points );\n\t\t\tcachedSatBounds2.setFromPoints( tempDir, other.points );\n\t\t\tif ( cachedSatBounds.isSeparated( cachedSatBounds2 ) ) return false;\n\n\t\t}\n\n\t\tconst satBounds2 = other.satBounds;\n\t\tconst satAxes2 = other.satAxes;\n\t\tfor ( let i = 1; i < 4; i ++ ) {\n\n\t\t\tconst sb = satBounds2[ i ];\n\t\t\tconst sa = satAxes2[ i ];\n\t\t\tcachedSatBounds.setFromPoints( sa, self.points );\n\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\n\n\t\t\ttempDir.crossVectors( planeNormal, sa );\n\t\t\tcachedSatBounds.setFromPoints( tempDir, self.points );\n\t\t\tcachedSatBounds2.setFromPoints( tempDir, other.points );\n\t\t\tif ( cachedSatBounds.isSeparated( cachedSatBounds2 ) ) return false;\n\n\t\t}\n\n\t\tif ( target ) {\n\n\t\t\t// TODO find two points that intersect on the edges and make that the result\n\t\t\tif ( ! suppressLog ) {\n\n\t\t\t\tconsole.warn( 'ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0.' );\n\n\t\t\t}\n\n\t\t\ttarget.start.set( 0, 0, 0 );\n\t\t\ttarget.end.set( 0, 0, 0 );\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\tfunction findSingleBounds( a, b, c, aProj, bProj, cProj, aDist, bDist, cDist, bounds, edge ) {\n\n\t\tlet t = aDist / ( aDist - bDist );\n\t\tbounds.x = aProj + ( bProj - aProj ) * t;\n\t\tedge.start.subVectors( b, a ).multiplyScalar( t ).add( a );\n\n\t\tt = aDist / ( aDist - cDist );\n\t\tbounds.y = aProj + ( cProj - aProj ) * t;\n\t\tedge.end.subVectors( c, a ).multiplyScalar( t ).add( a );\n\n\t}\n\n\t/**\n\t * Calculates intersection segment of a triangle with intersection line.\n\t * Intersection line is snapped to its biggest component.\n\t * And triangle points are passed as a projection on that component.\n\t * @returns whether this is a coplanar case or not\n\t */\n\tfunction findIntersectionLineBounds( self, aProj, bProj, cProj, abDist, acDist, aDist, bDist, cDist, bounds, edge ) {\n\n\t\tif ( abDist > 0 ) {\n\n\t\t\t// then bcDist < 0\n\t\t\tfindSingleBounds( self.c, self.a, self.b, cProj, aProj, bProj, cDist, aDist, bDist, bounds, edge );\n\n\t\t} else if ( acDist > 0 ) {\n\n\t\t\tfindSingleBounds( self.b, self.a, self.c, bProj, aProj, cProj, bDist, aDist, cDist, bounds, edge );\n\n\t\t} else if ( bDist * cDist > 0 || aDist != 0 ) {\n\n\t\t\tfindSingleBounds( self.a, self.b, self.c, aProj, bProj, cProj, aDist, bDist, cDist, bounds, edge );\n\n\t\t} else if ( bDist != 0 ) {\n\n\t\t\tfindSingleBounds( self.b, self.a, self.c, bProj, aProj, cProj, bDist, aDist, cDist, bounds, edge );\n\n\t\t} else if ( cDist != 0 ) {\n\n\t\t\tfindSingleBounds( self.c, self.a, self.b, cProj, aProj, bProj, cDist, aDist, bDist, bounds, edge );\n\n\t\t} else {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\tfunction intersectTriangleSegment( triangle, degenerateTriangle, target, suppressLog ) {\n\n\t\tconst segment = degenerateTriangle.degenerateSegment;\n\t\tconst startDist = triangle.plane.distanceToPoint( segment.start );\n\t\tconst endDist = triangle.plane.distanceToPoint( segment.end );\n\t\tif ( isNearZero( startDist ) ) {\n\n\t\t\tif ( isNearZero( endDist ) ) {\n\n\t\t\t\treturn coplanarIntersectsTriangle( triangle, degenerateTriangle, target, suppressLog );\n\n\t\t\t} else {\n\n\t\t\t\t// Is this fine to modify target even if there might be no intersection?\n\t\t\t\tif ( target ) {\n\n\t\t\t\t\ttarget.start.copy( segment.start );\n\t\t\t\t\ttarget.end.copy( segment.start );\n\n\t\t\t\t}\n\n\t\t\t\treturn triangle.containsPoint( segment.start );\n\n\t\t\t}\n\n\t\t} else if ( isNearZero( endDist ) ) {\n\n\t\t\tif ( target ) {\n\n\t\t\t\ttarget.start.copy( segment.end );\n\t\t\t\ttarget.end.copy( segment.end );\n\n\t\t\t}\n\n\t\t\treturn triangle.containsPoint( segment.end );\n\n\t\t} else {\n\n\t\t\tif ( triangle.plane.intersectLine( segment, tmpVec ) != null ) {\n\n\t\t\t\tif ( target ) {\n\n\t\t\t\t\ttarget.start.copy( tmpVec );\n\t\t\t\t\ttarget.end.copy( tmpVec );\n\n\t\t\t\t}\n\n\t\t\t\treturn triangle.containsPoint( tmpVec );\n\n\t\t\t} else {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction intersectTrianglePoint( triangle, degenerateTriangle, target ) {\n\n\t\tconst point = degenerateTriangle.a;\n\n\t\tif ( isNearZero( triangle.plane.distanceToPoint( point ) ) && triangle.containsPoint( point ) ) {\n\n\t\t\tif ( target ) {\n\n\t\t\t\ttarget.start.copy( point );\n\t\t\t\ttarget.end.copy( point );\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t} else {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t}\n\n\tfunction intersectSegmentPoint( segmentTri, pointTri, target ) {\n\n\t\tconst segment = segmentTri.degenerateSegment;\n\t\tconst point = pointTri.a;\n\n\t\tsegment.closestPointToPoint( point, true, tmpVec );\n\n\t\tif ( point.distanceToSquared( tmpVec ) < ZERO_EPSILON_SQR ) {\n\n\t\t\tif ( target ) {\n\n\t\t\t\ttarget.start.copy( point );\n\t\t\t\ttarget.end.copy( point );\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t} else {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t}\n\n\tfunction handleDegenerateCases( self, other, target, suppressLog ) {\n\n\t\tif ( self.isDegenerateIntoSegment ) {\n\n\t\t\tif ( other.isDegenerateIntoSegment ) {\n\n\t\t\t\t// TODO: replace with Line.distanceSqToLine3 after r179\n\t\t\t\tconst segment1 = self.degenerateSegment;\n\t\t\t\tconst segment2 = other.degenerateSegment;\n\t\t\t\tconst delta1 = dir1;\n\t\t\t\tconst delta2 = dir2;\n\t\t\t\tsegment1.delta( delta1 );\n\t\t\t\tsegment2.delta( delta2 );\n\t\t\t\tconst startDelta = tmpVec.subVectors( segment2.start, segment1.start );\n\n\t\t\t\tconst denom = delta1.x * delta2.y - delta1.y * delta2.x;\n\t\t\t\tif ( isNearZero( denom ) ) {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t\tconst t = ( startDelta.x * delta2.y - startDelta.y * delta2.x ) / denom;\n\t\t\t\tconst u = - ( delta1.x * startDelta.y - delta1.y * startDelta.x ) / denom;\n\n\t\t\t\tif ( t < 0 || t > 1 || u < 0 || u > 1 ) {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t\tconst z1 = segment1.start.z + delta1.z * t;\n\t\t\t\tconst z2 = segment2.start.z + delta2.z * u;\n\n\t\t\t\tif ( isNearZero( z1 - z2 ) ) {\n\n\t\t\t\t\tif ( target ) {\n\n\t\t\t\t\t\ttarget.start.copy( segment1.start ).addScaledVector( delta1, t );\n\t\t\t\t\t\ttarget.end.copy( segment1.start ).addScaledVector( delta1, t );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t} else if ( other.isDegenerateIntoPoint ) {\n\n\t\t\t\treturn intersectSegmentPoint( self, other, target );\n\n\t\t\t} else {\n\n\t\t\t\treturn intersectTriangleSegment( other, self, target, suppressLog );\n\n\t\t\t}\n\n\t\t} else if ( self.isDegenerateIntoPoint ) {\n\n\t\t\tif ( other.isDegenerateIntoPoint ) {\n\n\t\t\t\tif ( other.a.distanceToSquared( self.a ) < ZERO_EPSILON_SQR ) {\n\n\t\t\t\t\tif ( target ) {\n\n\t\t\t\t\t\ttarget.start.copy( self.a );\n\t\t\t\t\t\ttarget.end.copy( self.a );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t} else if ( other.isDegenerateIntoSegment ) {\n\n\t\t\t\treturn intersectSegmentPoint( other, self, target );\n\n\t\t\t} else {\n\n\t\t\t\treturn intersectTrianglePoint( other, self, target );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif ( other.isDegenerateIntoPoint ) {\n\n\t\t\t\treturn intersectTrianglePoint( self, other, target );\n\n\t\t\t} else if ( other.isDegenerateIntoSegment ) {\n\n\t\t\t\treturn intersectTriangleSegment( self, other, target, suppressLog );\n\n\t\t\t} /* else this is a general triangle-traingle case, so return undefined */\n\n\t\t}\n\n\t}\n\n\t/* TODO: If the triangles are coplanar and intersecting the target is nonsensical. It should at least\n\t * be a line contained by both triangles if not a different special case somehow represented in the return result.\n\t *\n\t * General triangle intersection code is based on Moller's algorithm from here: https://web.stanford.edu/class/cs277/resources/papers/Moller1997b.pdf\n\t * Reference implementation from here: https://github.com/erich666/jgt-code/blob/master/Volume_08/Number_1/Shen2003/tri_tri_test/include/Moller97.c#L570\n\t * All degeneracies are handled before the general algorithm.\n\t * Coplanar check is different from Moller's and based on SAT tests.\n\t */\n\treturn function intersectsTriangle( other, target = null, suppressLog = false ) {\n\n\t\tif ( this.needsUpdate ) {\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\tif ( ! other.isExtendedTriangle ) {\n\n\t\t\tsaTri2.copy( other );\n\t\t\tsaTri2.update();\n\t\t\tother = saTri2;\n\n\t\t} else if ( other.needsUpdate ) {\n\n\t\t\tother.update();\n\n\t\t}\n\n\t\tconst res = handleDegenerateCases( this, other, target, suppressLog );\n\t\tif ( res !== undefined ) {\n\n\t\t\treturn res;\n\n\t\t}\n\n\t\tconst plane1 = this.plane;\n\t\tconst plane2 = other.plane;\n\n\t\tlet a1Dist = plane2.distanceToPoint( this.a );\n\t\tlet b1Dist = plane2.distanceToPoint( this.b );\n\t\tlet c1Dist = plane2.distanceToPoint( this.c );\n\n\t\tif ( isNearZero( a1Dist ) )\n\t\t\ta1Dist = 0;\n\n\t\tif ( isNearZero( b1Dist ) )\n\t\t\tb1Dist = 0;\n\n\t\tif ( isNearZero( c1Dist ) )\n\t\t\tc1Dist = 0;\n\n\t\tconst a1b1Dist = a1Dist * b1Dist;\n\t\tconst a1c1Dist = a1Dist * c1Dist;\n\t\tif ( a1b1Dist > 0 && a1c1Dist > 0 ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\tlet a2Dist = plane1.distanceToPoint( other.a );\n\t\tlet b2Dist = plane1.distanceToPoint( other.b );\n\t\tlet c2Dist = plane1.distanceToPoint( other.c );\n\n\t\tif ( isNearZero( a2Dist ) )\n\t\t\ta2Dist = 0;\n\n\t\tif ( isNearZero( b2Dist ) )\n\t\t\tb2Dist = 0;\n\n\t\tif ( isNearZero( c2Dist ) )\n\t\t\tc2Dist = 0;\n\n\t\tconst a2b2Dist = a2Dist * b2Dist;\n\t\tconst a2c2Dist = a2Dist * c2Dist;\n\t\tif ( a2b2Dist > 0 && a2c2Dist > 0 ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\tdir1.copy( plane1.normal );\n\t\tdir2.copy( plane2.normal );\n\t\tconst intersectionLine = dir1.cross( dir2 );\n\n\t\tlet componentIndex = 0;\n\t\tlet maxComponent = Math.abs( intersectionLine.x );\n\t\tconst comp1 = Math.abs( intersectionLine.y );\n\t\tif ( comp1 > maxComponent ) {\n\n\t\t\tmaxComponent = comp1;\n\t\t\tcomponentIndex = 1;\n\n\t\t}\n\n\t\tconst comp2 = Math.abs( intersectionLine.z );\n\t\tif ( comp2 > maxComponent ) {\n\n\t\t\tcomponentIndex = 2;\n\n\t\t}\n\n\t\tconst key = componentKeys[ componentIndex ];\n\t\tconst a1Proj = this.a[ key ];\n\t\tconst b1Proj = this.b[ key ];\n\t\tconst c1Proj = this.c[ key ];\n\n\t\tconst a2Proj = other.a[ key ];\n\t\tconst b2Proj = other.b[ key ];\n\t\tconst c2Proj = other.c[ key ];\n\n\t\tif ( findIntersectionLineBounds( this, a1Proj, b1Proj, c1Proj, a1b1Dist, a1c1Dist, a1Dist, b1Dist, c1Dist, bounds1, edge1 ) ) {\n\n\t\t\treturn coplanarIntersectsTriangle( this, other, target, suppressLog );\n\n\t\t}\n\n\t\tif ( findIntersectionLineBounds( other, a2Proj, b2Proj, c2Proj, a2b2Dist, a2c2Dist, a2Dist, b2Dist, c2Dist, bounds2, edge2 ) ) {\n\n\t\t\treturn coplanarIntersectsTriangle( this, other, target, suppressLog );\n\n\t\t}\n\n\t\tif ( bounds1.y < bounds1.x ) {\n\n\t\t\tconst tmp = bounds1.y;\n\t\t\tbounds1.y = bounds1.x;\n\t\t\tbounds1.x = tmp;\n\n\t\t\ttempPoint.copy( edge1.start );\n\t\t\tedge1.start.copy( edge1.end );\n\t\t\tedge1.end.copy( tempPoint );\n\n\t\t}\n\n\t\tif ( bounds2.y < bounds2.x ) {\n\n\t\t\tconst tmp = bounds2.y;\n\t\t\tbounds2.y = bounds2.x;\n\t\t\tbounds2.x = tmp;\n\n\t\t\ttempPoint.copy( edge2.start );\n\t\t\tedge2.start.copy( edge2.end );\n\t\t\tedge2.end.copy( tempPoint );\n\n\t\t}\n\n\t\tif ( bounds1.y < bounds2.x || bounds2.y < bounds1.x ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\tif ( target ) {\n\n\t\t\tif ( bounds2.x > bounds1.x ) {\n\n\t\t\t\ttarget.start.copy( edge2.start );\n\n\t\t\t} else {\n\n\t\t\t\ttarget.start.copy( edge1.start );\n\n\t\t\t}\n\n\t\t\tif ( bounds2.y < bounds1.y ) {\n\n\t\t\t\ttarget.end.copy( edge2.end );\n\n\t\t\t} else {\n\n\t\t\t\ttarget.end.copy( edge1.end );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t};\n\n} )();\n\n\nExtendedTriangle.prototype.distanceToPoint = ( function () {\n\n\tconst target = /* @__PURE__ */ new Vector3();\n\treturn function distanceToPoint( point ) {\n\n\t\tthis.closestPointToPoint( point, target );\n\t\treturn point.distanceTo( target );\n\n\t};\n\n} )();\n\n\nExtendedTriangle.prototype.distanceToTriangle = ( function () {\n\n\tconst point = /* @__PURE__ */ new Vector3();\n\tconst point2 = /* @__PURE__ */ new Vector3();\n\tconst cornerFields = [ 'a', 'b', 'c' ];\n\tconst line1 = /* @__PURE__ */ new Line3();\n\tconst line2 = /* @__PURE__ */ new Line3();\n\n\treturn function distanceToTriangle( other, target1 = null, target2 = null ) {\n\n\t\tconst lineTarget = target1 || target2 ? line1 : null;\n\t\tif ( this.intersectsTriangle( other, lineTarget ) ) {\n\n\t\t\tif ( target1 || target2 ) {\n\n\t\t\t\tif ( target1 ) lineTarget.getCenter( target1 );\n\t\t\t\tif ( target2 ) lineTarget.getCenter( target2 );\n\n\t\t\t}\n\n\t\t\treturn 0;\n\n\t\t}\n\n\t\tlet closestDistanceSq = Infinity;\n\n\t\t// check all point distances\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tlet dist;\n\t\t\tconst field = cornerFields[ i ];\n\t\t\tconst otherVec = other[ field ];\n\t\t\tthis.closestPointToPoint( otherVec, point );\n\n\t\t\tdist = otherVec.distanceToSquared( point );\n\n\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\tif ( target1 ) target1.copy( point );\n\t\t\t\tif ( target2 ) target2.copy( otherVec );\n\n\t\t\t}\n\n\n\t\t\tconst thisVec = this[ field ];\n\t\t\tother.closestPointToPoint( thisVec, point );\n\n\t\t\tdist = thisVec.distanceToSquared( point );\n\n\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\tif ( target1 ) target1.copy( thisVec );\n\t\t\t\tif ( target2 ) target2.copy( point );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst f11 = cornerFields[ i ];\n\t\t\tconst f12 = cornerFields[ ( i + 1 ) % 3 ];\n\t\t\tline1.set( this[ f11 ], this[ f12 ] );\n\t\t\tfor ( let i2 = 0; i2 < 3; i2 ++ ) {\n\n\t\t\t\tconst f21 = cornerFields[ i2 ];\n\t\t\t\tconst f22 = cornerFields[ ( i2 + 1 ) % 3 ];\n\t\t\t\tline2.set( other[ f21 ], other[ f22 ] );\n\n\t\t\t\tclosestPointsSegmentToSegment( line1, line2, point, point2 );\n\n\t\t\t\tconst dist = point.distanceToSquared( point2 );\n\t\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\t\tif ( target1 ) target1.copy( point );\n\t\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn Math.sqrt( closestDistanceSq );\n\n\t};\n\n} )();\n","import { Vector3, Matrix4, Line3 } from 'three';\nimport { SeparatingAxisBounds } from './SeparatingAxisBounds.js';\nimport { ExtendedTriangle } from './ExtendedTriangle.js';\nimport { closestPointsSegmentToSegment } from './MathUtilities.js';\n\nexport class OrientedBox {\n\n\tconstructor( min, max, matrix ) {\n\n\t\tthis.isOrientedBox = true;\n\t\tthis.min = new Vector3();\n\t\tthis.max = new Vector3();\n\t\tthis.matrix = new Matrix4();\n\t\tthis.invMatrix = new Matrix4();\n\t\tthis.points = new Array( 8 ).fill().map( () => new Vector3() );\n\t\tthis.satAxes = new Array( 3 ).fill().map( () => new Vector3() );\n\t\tthis.satBounds = new Array( 3 ).fill().map( () => new SeparatingAxisBounds() );\n\t\tthis.alignedSatBounds = new Array( 3 ).fill().map( () => new SeparatingAxisBounds() );\n\t\tthis.needsUpdate = false;\n\n\t\tif ( min ) this.min.copy( min );\n\t\tif ( max ) this.max.copy( max );\n\t\tif ( matrix ) this.matrix.copy( matrix );\n\n\t}\n\n\tset( min, max, matrix ) {\n\n\t\tthis.min.copy( min );\n\t\tthis.max.copy( max );\n\t\tthis.matrix.copy( matrix );\n\t\tthis.needsUpdate = true;\n\n\t}\n\n\tcopy( other ) {\n\n\t\tthis.min.copy( other.min );\n\t\tthis.max.copy( other.max );\n\t\tthis.matrix.copy( other.matrix );\n\t\tthis.needsUpdate = true;\n\n\t}\n\n}\n\nOrientedBox.prototype.update = ( function () {\n\n\treturn function update() {\n\n\t\tconst matrix = this.matrix;\n\t\tconst min = this.min;\n\t\tconst max = this.max;\n\n\t\tconst points = this.points;\n\t\tfor ( let x = 0; x <= 1; x ++ ) {\n\n\t\t\tfor ( let y = 0; y <= 1; y ++ ) {\n\n\t\t\t\tfor ( let z = 0; z <= 1; z ++ ) {\n\n\t\t\t\t\tconst i = ( ( 1 << 0 ) * x ) | ( ( 1 << 1 ) * y ) | ( ( 1 << 2 ) * z );\n\t\t\t\t\tconst v = points[ i ];\n\t\t\t\t\tv.x = x ? max.x : min.x;\n\t\t\t\t\tv.y = y ? max.y : min.y;\n\t\t\t\t\tv.z = z ? max.z : min.z;\n\n\t\t\t\t\tv.applyMatrix4( matrix );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst satBounds = this.satBounds;\n\t\tconst satAxes = this.satAxes;\n\t\tconst minVec = points[ 0 ];\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst axis = satAxes[ i ];\n\t\t\tconst sb = satBounds[ i ];\n\t\t\tconst index = 1 << i;\n\t\t\tconst pi = points[ index ];\n\n\t\t\taxis.subVectors( minVec, pi );\n\t\t\tsb.setFromPoints( axis, points );\n\n\t\t}\n\n\t\tconst alignedSatBounds = this.alignedSatBounds;\n\t\talignedSatBounds[ 0 ].setFromPointsField( points, 'x' );\n\t\talignedSatBounds[ 1 ].setFromPointsField( points, 'y' );\n\t\talignedSatBounds[ 2 ].setFromPointsField( points, 'z' );\n\n\t\tthis.invMatrix.copy( this.matrix ).invert();\n\t\tthis.needsUpdate = false;\n\n\t};\n\n} )();\n\nOrientedBox.prototype.intersectsBox = ( function () {\n\n\tconst aabbBounds = /* @__PURE__ */ new SeparatingAxisBounds();\n\treturn function intersectsBox( box ) {\n\n\t\t// TODO: should this be doing SAT against the AABB?\n\t\tif ( this.needsUpdate ) {\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\tconst min = box.min;\n\t\tconst max = box.max;\n\t\tconst satBounds = this.satBounds;\n\t\tconst satAxes = this.satAxes;\n\t\tconst alignedSatBounds = this.alignedSatBounds;\n\n\t\taabbBounds.min = min.x;\n\t\taabbBounds.max = max.x;\n\t\tif ( alignedSatBounds[ 0 ].isSeparated( aabbBounds ) ) return false;\n\n\t\taabbBounds.min = min.y;\n\t\taabbBounds.max = max.y;\n\t\tif ( alignedSatBounds[ 1 ].isSeparated( aabbBounds ) ) return false;\n\n\t\taabbBounds.min = min.z;\n\t\taabbBounds.max = max.z;\n\t\tif ( alignedSatBounds[ 2 ].isSeparated( aabbBounds ) ) return false;\n\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst axis = satAxes[ i ];\n\t\t\tconst sb = satBounds[ i ];\n\t\t\taabbBounds.setFromBox( axis, box );\n\t\t\tif ( sb.isSeparated( aabbBounds ) ) return false;\n\n\t\t}\n\n\t\treturn true;\n\n\t};\n\n} )();\n\nOrientedBox.prototype.intersectsTriangle = ( function () {\n\n\tconst saTri = /* @__PURE__ */ new ExtendedTriangle();\n\tconst pointsArr = /* @__PURE__ */ new Array( 3 );\n\tconst cachedSatBounds = /* @__PURE__ */ new SeparatingAxisBounds();\n\tconst cachedSatBounds2 = /* @__PURE__ */ new SeparatingAxisBounds();\n\tconst cachedAxis = /* @__PURE__ */ new Vector3();\n\treturn function intersectsTriangle( triangle ) {\n\n\t\tif ( this.needsUpdate ) {\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\tif ( ! triangle.isExtendedTriangle ) {\n\n\t\t\tsaTri.copy( triangle );\n\t\t\tsaTri.update();\n\t\t\ttriangle = saTri;\n\n\t\t} else if ( triangle.needsUpdate ) {\n\n\t\t\ttriangle.update();\n\n\t\t}\n\n\t\tconst satBounds = this.satBounds;\n\t\tconst satAxes = this.satAxes;\n\n\t\tpointsArr[ 0 ] = triangle.a;\n\t\tpointsArr[ 1 ] = triangle.b;\n\t\tpointsArr[ 2 ] = triangle.c;\n\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst sb = satBounds[ i ];\n\t\t\tconst sa = satAxes[ i ];\n\t\t\tcachedSatBounds.setFromPoints( sa, pointsArr );\n\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\n\n\t\t}\n\n\t\tconst triSatBounds = triangle.satBounds;\n\t\tconst triSatAxes = triangle.satAxes;\n\t\tconst points = this.points;\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst sb = triSatBounds[ i ];\n\t\t\tconst sa = triSatAxes[ i ];\n\t\t\tcachedSatBounds.setFromPoints( sa, points );\n\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\n\n\t\t}\n\n\t\t// check crossed axes\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst sa1 = satAxes[ i ];\n\t\t\tfor ( let i2 = 0; i2 < 4; i2 ++ ) {\n\n\t\t\t\tconst sa2 = triSatAxes[ i2 ];\n\t\t\t\tcachedAxis.crossVectors( sa1, sa2 );\n\t\t\t\tcachedSatBounds.setFromPoints( cachedAxis, pointsArr );\n\t\t\t\tcachedSatBounds2.setFromPoints( cachedAxis, points );\n\t\t\t\tif ( cachedSatBounds.isSeparated( cachedSatBounds2 ) ) return false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t};\n\n} )();\n\nOrientedBox.prototype.closestPointToPoint = ( function () {\n\n\treturn function closestPointToPoint( point, target1 ) {\n\n\t\tif ( this.needsUpdate ) {\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\ttarget1\n\t\t\t.copy( point )\n\t\t\t.applyMatrix4( this.invMatrix )\n\t\t\t.clamp( this.min, this.max )\n\t\t\t.applyMatrix4( this.matrix );\n\n\t\treturn target1;\n\n\t};\n\n} )();\n\nOrientedBox.prototype.distanceToPoint = ( function () {\n\n\tconst target = new Vector3();\n\treturn function distanceToPoint( point ) {\n\n\t\tthis.closestPointToPoint( point, target );\n\t\treturn point.distanceTo( target );\n\n\t};\n\n} )();\n\nOrientedBox.prototype.distanceToBox = ( function () {\n\n\tconst xyzFields = [ 'x', 'y', 'z' ];\n\tconst segments1 = /* @__PURE__ */ new Array( 12 ).fill().map( () => new Line3() );\n\tconst segments2 = /* @__PURE__ */ new Array( 12 ).fill().map( () => new Line3() );\n\n\tconst point1 = /* @__PURE__ */ new Vector3();\n\tconst point2 = /* @__PURE__ */ new Vector3();\n\n\t// early out if we find a value below threshold\n\treturn function distanceToBox( box, threshold = 0, target1 = null, target2 = null ) {\n\n\t\tif ( this.needsUpdate ) {\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\tif ( this.intersectsBox( box ) ) {\n\n\t\t\tif ( target1 || target2 ) {\n\n\t\t\t\tbox.getCenter( point2 );\n\t\t\t\tthis.closestPointToPoint( point2, point1 );\n\t\t\t\tbox.closestPointToPoint( point1, point2 );\n\n\t\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t}\n\n\t\t\treturn 0;\n\n\t\t}\n\n\t\tconst threshold2 = threshold * threshold;\n\t\tconst min = box.min;\n\t\tconst max = box.max;\n\t\tconst points = this.points;\n\n\n\t\t// iterate over every edge and compare distances\n\t\tlet closestDistanceSq = Infinity;\n\n\t\t// check over all these points\n\t\tfor ( let i = 0; i < 8; i ++ ) {\n\n\t\t\tconst p = points[ i ];\n\t\t\tpoint2.copy( p ).clamp( min, max );\n\n\t\t\tconst dist = p.distanceToSquared( point2 );\n\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\tif ( target1 ) target1.copy( p );\n\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t\tif ( dist < threshold2 ) return Math.sqrt( dist );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// generate and check all line segment distances\n\t\tlet count = 0;\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tfor ( let i1 = 0; i1 <= 1; i1 ++ ) {\n\n\t\t\t\tfor ( let i2 = 0; i2 <= 1; i2 ++ ) {\n\n\t\t\t\t\tconst nextIndex = ( i + 1 ) % 3;\n\t\t\t\t\tconst nextIndex2 = ( i + 2 ) % 3;\n\n\t\t\t\t\t// get obb line segments\n\t\t\t\t\tconst index = i1 << nextIndex | i2 << nextIndex2;\n\t\t\t\t\tconst index2 = 1 << i | i1 << nextIndex | i2 << nextIndex2;\n\t\t\t\t\tconst p1 = points[ index ];\n\t\t\t\t\tconst p2 = points[ index2 ];\n\t\t\t\t\tconst line1 = segments1[ count ];\n\t\t\t\t\tline1.set( p1, p2 );\n\n\n\t\t\t\t\t// get aabb line segments\n\t\t\t\t\tconst f1 = xyzFields[ i ];\n\t\t\t\t\tconst f2 = xyzFields[ nextIndex ];\n\t\t\t\t\tconst f3 = xyzFields[ nextIndex2 ];\n\t\t\t\t\tconst line2 = segments2[ count ];\n\t\t\t\t\tconst start = line2.start;\n\t\t\t\t\tconst end = line2.end;\n\n\t\t\t\t\tstart[ f1 ] = min[ f1 ];\n\t\t\t\t\tstart[ f2 ] = i1 ? min[ f2 ] : max[ f2 ];\n\t\t\t\t\tstart[ f3 ] = i2 ? min[ f3 ] : max[ f2 ];\n\n\t\t\t\t\tend[ f1 ] = max[ f1 ];\n\t\t\t\t\tend[ f2 ] = i1 ? min[ f2 ] : max[ f2 ];\n\t\t\t\t\tend[ f3 ] = i2 ? min[ f3 ] : max[ f2 ];\n\n\t\t\t\t\tcount ++;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// check all the other boxes point\n\t\tfor ( let x = 0; x <= 1; x ++ ) {\n\n\t\t\tfor ( let y = 0; y <= 1; y ++ ) {\n\n\t\t\t\tfor ( let z = 0; z <= 1; z ++ ) {\n\n\t\t\t\t\tpoint2.x = x ? max.x : min.x;\n\t\t\t\t\tpoint2.y = y ? max.y : min.y;\n\t\t\t\t\tpoint2.z = z ? max.z : min.z;\n\n\t\t\t\t\tthis.closestPointToPoint( point2, point1 );\n\t\t\t\t\tconst dist = point2.distanceToSquared( point1 );\n\t\t\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t\t\t\tif ( dist < threshold2 ) return Math.sqrt( dist );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( let i = 0; i < 12; i ++ ) {\n\n\t\t\tconst l1 = segments1[ i ];\n\t\t\tfor ( let i2 = 0; i2 < 12; i2 ++ ) {\n\n\t\t\t\tconst l2 = segments2[ i2 ];\n\t\t\t\tclosestPointsSegmentToSegment( l1, l2, point1, point2 );\n\t\t\t\tconst dist = point1.distanceToSquared( point2 );\n\t\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t\t\tif ( dist < threshold2 ) return Math.sqrt( dist );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn Math.sqrt( closestDistanceSq );\n\n\t};\n\n} )();\n","import { ExtendedTriangle } from '../math/ExtendedTriangle.js';\nimport { PrimitivePool } from './PrimitivePool.js';\n\nclass ExtendedTrianglePoolBase extends PrimitivePool {\n\n\tconstructor() {\n\n\t\tsuper( () => new ExtendedTriangle() );\n\n\t}\n\n}\n\nexport const ExtendedTrianglePool = /* @__PURE__ */ new ExtendedTrianglePoolBase();\n","import { Vector3 } from 'three';\n\nconst temp = /* @__PURE__ */ new Vector3();\nconst temp1 = /* @__PURE__ */ new Vector3();\n\nexport function closestPointToPoint(\n\tbvh,\n\tpoint,\n\ttarget = { },\n\tminThreshold = 0,\n\tmaxThreshold = Infinity,\n) {\n\n\t// early out if under minThreshold\n\t// skip checking if over maxThreshold\n\t// set minThreshold = maxThreshold to quickly check if a point is within a threshold\n\t// returns Infinity if no value found\n\tconst minThresholdSq = minThreshold * minThreshold;\n\tconst maxThresholdSq = maxThreshold * maxThreshold;\n\tlet closestDistanceSq = Infinity;\n\tlet closestDistanceTriIndex = null;\n\tbvh.shapecast(\n\n\t\t{\n\n\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\ttemp.copy( point ).clamp( box.min, box.max );\n\t\t\t\treturn temp.distanceToSquared( point );\n\n\t\t\t},\n\n\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\treturn score < closestDistanceSq && score < maxThresholdSq;\n\n\t\t\t},\n\n\t\t\tintersectsTriangle: ( tri, triIndex ) => {\n\n\t\t\t\ttri.closestPointToPoint( point, temp );\n\t\t\t\tconst distSq = point.distanceToSquared( temp );\n\t\t\t\tif ( distSq < closestDistanceSq ) {\n\n\t\t\t\t\ttemp1.copy( temp );\n\t\t\t\t\tclosestDistanceSq = distSq;\n\t\t\t\t\tclosestDistanceTriIndex = triIndex;\n\n\t\t\t\t}\n\n\t\t\t\tif ( distSq < minThresholdSq ) {\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t}\n\n\t);\n\n\tif ( closestDistanceSq === Infinity ) return null;\n\n\tconst closestDistance = Math.sqrt( closestDistanceSq );\n\n\tif ( ! target.point ) target.point = temp1.clone();\n\telse target.point.copy( temp1 );\n\ttarget.distance = closestDistance,\n\ttarget.faceIndex = closestDistanceTriIndex;\n\n\treturn target;\n\n}\n","import { Vector3, Vector2, Triangle, DoubleSide, BackSide, REVISION } from 'three';\n\nconst IS_GT_REVISION_169 = parseInt( REVISION ) >= 169;\nconst IS_LT_REVISION_161 = parseInt( REVISION ) <= 161;\n\n// Ripped and modified From THREE.js Mesh raycast\n// https://github.com/mrdoob/three.js/blob/0aa87c999fe61e216c1133fba7a95772b503eddf/src/objects/Mesh.js#L115\nconst _vA = /* @__PURE__ */ new Vector3();\nconst _vB = /* @__PURE__ */ new Vector3();\nconst _vC = /* @__PURE__ */ new Vector3();\n\nconst _uvA = /* @__PURE__ */ new Vector2();\nconst _uvB = /* @__PURE__ */ new Vector2();\nconst _uvC = /* @__PURE__ */ new Vector2();\n\nconst _normalA = /* @__PURE__ */ new Vector3();\nconst _normalB = /* @__PURE__ */ new Vector3();\nconst _normalC = /* @__PURE__ */ new Vector3();\n\nconst _intersectionPoint = /* @__PURE__ */ new Vector3();\nfunction checkIntersection( ray, pA, pB, pC, point, side, near, far ) {\n\n\tlet intersect;\n\tif ( side === BackSide ) {\n\n\t\tintersect = ray.intersectTriangle( pC, pB, pA, true, point );\n\n\t} else {\n\n\t\tintersect = ray.intersectTriangle( pA, pB, pC, side !== DoubleSide, point );\n\n\t}\n\n\tif ( intersect === null ) return null;\n\n\tconst distance = ray.origin.distanceTo( point );\n\n\tif ( distance < near || distance > far ) return null;\n\n\treturn {\n\n\t\tdistance: distance,\n\t\tpoint: point.clone(),\n\n\t};\n\n}\n\nfunction checkBufferGeometryIntersection( ray, position, normal, uv, uv1, a, b, c, side, near, far ) {\n\n\t_vA.fromBufferAttribute( position, a );\n\t_vB.fromBufferAttribute( position, b );\n\t_vC.fromBufferAttribute( position, c );\n\n\tconst intersection = checkIntersection( ray, _vA, _vB, _vC, _intersectionPoint, side, near, far );\n\n\tif ( intersection ) {\n\n\t\tif ( uv ) {\n\n\t\t\t_uvA.fromBufferAttribute( uv, a );\n\t\t\t_uvB.fromBufferAttribute( uv, b );\n\t\t\t_uvC.fromBufferAttribute( uv, c );\n\n\t\t\tintersection.uv = new Vector2();\n\t\t\tconst res = Triangle.getInterpolation( _intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, intersection.uv );\n\t\t\tif ( ! IS_GT_REVISION_169 ) {\n\n\t\t\t\tintersection.uv = res;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( uv1 ) {\n\n\t\t\t_uvA.fromBufferAttribute( uv1, a );\n\t\t\t_uvB.fromBufferAttribute( uv1, b );\n\t\t\t_uvC.fromBufferAttribute( uv1, c );\n\n\t\t\tintersection.uv1 = new Vector2();\n\t\t\tconst res = Triangle.getInterpolation( _intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, intersection.uv1 );\n\t\t\tif ( ! IS_GT_REVISION_169 ) {\n\n\t\t\t\tintersection.uv1 = res;\n\n\t\t\t}\n\n\t\t\tif ( IS_LT_REVISION_161 ) {\n\n\t\t\t\tintersection.uv2 = intersection.uv1;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( normal ) {\n\n\t\t\t_normalA.fromBufferAttribute( normal, a );\n\t\t\t_normalB.fromBufferAttribute( normal, b );\n\t\t\t_normalC.fromBufferAttribute( normal, c );\n\n\t\t\tintersection.normal = new Vector3();\n\t\t\tconst res = Triangle.getInterpolation( _intersectionPoint, _vA, _vB, _vC, _normalA, _normalB, _normalC, intersection.normal );\n\t\t\tif ( intersection.normal.dot( ray.direction ) > 0 ) {\n\n\t\t\t\tintersection.normal.multiplyScalar( - 1 );\n\n\t\t\t}\n\n\t\t\tif ( ! IS_GT_REVISION_169 ) {\n\n\t\t\t\tintersection.normal = res;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst face = {\n\t\t\ta: a,\n\t\t\tb: b,\n\t\t\tc: c,\n\t\t\tnormal: new Vector3(),\n\t\t\tmaterialIndex: 0\n\t\t};\n\n\t\tTriangle.getNormal( _vA, _vB, _vC, face.normal );\n\n\t\tintersection.face = face;\n\t\tintersection.faceIndex = a;\n\n\t\tif ( IS_GT_REVISION_169 ) {\n\n\t\t\tconst barycoord = new Vector3();\n\t\t\tTriangle.getBarycoord( _intersectionPoint, _vA, _vB, _vC, barycoord );\n\n\t\t\tintersection.barycoord = barycoord;\n\n\t\t}\n\n\t}\n\n\treturn intersection;\n\n}\n\nfunction getSide( materialOrSide ) {\n\n\treturn materialOrSide && materialOrSide.isMaterial ? materialOrSide.side : materialOrSide;\n\n}\n\n// https://github.com/mrdoob/three.js/blob/0aa87c999fe61e216c1133fba7a95772b503eddf/src/objects/Mesh.js#L258\nexport function intersectTri( geometry, materialOrSide, ray, tri, intersections, near, far ) {\n\n\tconst triOffset = tri * 3;\n\tlet a = triOffset + 0;\n\tlet b = triOffset + 1;\n\tlet c = triOffset + 2;\n\n\tconst { index, groups } = geometry;\n\tif ( geometry.index ) {\n\n\t\ta = index.getX( a );\n\t\tb = index.getX( b );\n\t\tc = index.getX( c );\n\n\t}\n\n\tconst { position, normal, uv, uv1 } = geometry.attributes;\n\tif ( Array.isArray( materialOrSide ) ) {\n\n\t\t// check which groups a triangle is present in and run the intersections\n\t\t// TODO: we shouldn't need to run and intersection test multiple times\n\t\tconst firstIndex = tri * 3;\n\t\tfor ( let i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\tconst { start, count, materialIndex } = groups[ i ];\n\t\t\tif ( firstIndex >= start && firstIndex < start + count ) {\n\n\t\t\t\tconst side = getSide( materialOrSide[ materialIndex ] );\n\t\t\t\tconst intersection = checkBufferGeometryIntersection( ray, position, normal, uv, uv1, a, b, c, side, near, far );\n\t\t\t\tif ( intersection ) {\n\n\t\t\t\t\tintersection.faceIndex = tri;\n\t\t\t\t\tintersection.face.materialIndex = materialIndex;\n\n\t\t\t\t\tif ( intersections ) {\n\n\t\t\t\t\t\tintersections.push( intersection );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\treturn intersection;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t} else {\n\n\t\t// run the intersection for the single material\n\t\tconst side = getSide( materialOrSide );\n\t\tconst intersection = checkBufferGeometryIntersection( ray, position, normal, uv, uv1, a, b, c, side, near, far );\n\t\tif ( intersection ) {\n\n\t\t\tintersection.faceIndex = tri;\n\t\t\tintersection.face.materialIndex = 0;\n\n\t\t\tif ( intersections ) {\n\n\t\t\t\tintersections.push( intersection );\n\n\t\t\t} else {\n\n\t\t\t\treturn intersection;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn null;\n\n}\n","\nimport { Vector2, Vector3, Triangle } from 'three';\n\n// sets the vertices of triangle `tri` with the 3 vertices after i\nexport function setTriangle( tri, i, index, pos ) {\n\n\tconst ta = tri.a;\n\tconst tb = tri.b;\n\tconst tc = tri.c;\n\n\tlet i0 = i;\n\tlet i1 = i + 1;\n\tlet i2 = i + 2;\n\tif ( index ) {\n\n\t\ti0 = index.getX( i0 );\n\t\ti1 = index.getX( i1 );\n\t\ti2 = index.getX( i2 );\n\n\t}\n\n\tta.x = pos.getX( i0 );\n\tta.y = pos.getY( i0 );\n\tta.z = pos.getZ( i0 );\n\n\ttb.x = pos.getX( i1 );\n\ttb.y = pos.getY( i1 );\n\ttb.z = pos.getZ( i1 );\n\n\ttc.x = pos.getX( i2 );\n\ttc.y = pos.getY( i2 );\n\ttc.z = pos.getZ( i2 );\n\n}\n\nconst tempV1 = /* @__PURE__ */ new Vector3();\nconst tempV2 = /* @__PURE__ */ new Vector3();\nconst tempV3 = /* @__PURE__ */ new Vector3();\nconst tempUV1 = /* @__PURE__ */ new Vector2();\nconst tempUV2 = /* @__PURE__ */ new Vector2();\nconst tempUV3 = /* @__PURE__ */ new Vector2();\n\nexport function getTriangleHitPointInfo( point, geometry, triangleIndex, target ) {\n\n\tconst indices = geometry.getIndex().array;\n\tconst positions = geometry.getAttribute( 'position' );\n\tconst uvs = geometry.getAttribute( 'uv' );\n\n\tconst a = indices[ triangleIndex * 3 ];\n\tconst b = indices[ triangleIndex * 3 + 1 ];\n\tconst c = indices[ triangleIndex * 3 + 2 ];\n\n\ttempV1.fromBufferAttribute( positions, a );\n\ttempV2.fromBufferAttribute( positions, b );\n\ttempV3.fromBufferAttribute( positions, c );\n\n\t// find the associated material index\n\tlet materialIndex = 0;\n\tconst groups = geometry.groups;\n\tconst firstVertexIndex = triangleIndex * 3;\n\tfor ( let i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\t\tconst { start, count } = group;\n\t\tif ( firstVertexIndex >= start && firstVertexIndex < start + count ) {\n\n\t\t\tmaterialIndex = group.materialIndex;\n\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n\t// extract barycoord\n\tconst barycoord = target && target.barycoord ? target.barycoord : new Vector3();\n\tTriangle.getBarycoord( point, tempV1, tempV2, tempV3, barycoord );\n\n\t// extract uvs\n\tlet uv = null;\n\tif ( uvs ) {\n\n\t\ttempUV1.fromBufferAttribute( uvs, a );\n\t\ttempUV2.fromBufferAttribute( uvs, b );\n\t\ttempUV3.fromBufferAttribute( uvs, c );\n\n\t\tif ( target && target.uv ) uv = target.uv;\n\t\telse uv = new Vector2();\n\n\t\tTriangle.getInterpolation( point, tempV1, tempV2, tempV3, tempUV1, tempUV2, tempUV3, uv );\n\n\t}\n\n\t// adjust the provided target or create a new one\n\tif ( target ) {\n\n\t\tif ( ! target.face ) target.face = { };\n\t\ttarget.face.a = a;\n\t\ttarget.face.b = b;\n\t\ttarget.face.c = c;\n\t\ttarget.face.materialIndex = materialIndex;\n\t\tif ( ! target.face.normal ) target.face.normal = new Vector3();\n\t\tTriangle.getNormal( tempV1, tempV2, tempV3, target.face.normal );\n\n\t\tif ( uv ) target.uv = uv;\n\t\ttarget.barycoord = barycoord;\n\n\t\treturn target;\n\n\t} else {\n\n\t\treturn {\n\t\t\tface: {\n\t\t\t\ta: a,\n\t\t\t\tb: b,\n\t\t\t\tc: c,\n\t\t\t\tmaterialIndex: materialIndex,\n\t\t\t\tnormal: Triangle.getNormal( tempV1, tempV2, tempV3, new Vector3() )\n\t\t\t},\n\t\t\tuv: uv,\n\t\t\tbarycoord: barycoord,\n\t\t};\n\n\t}\n\n}\n","import { intersectTri } from '../../utils/ThreeRayIntersectUtilities.js';\nimport { setTriangle } from '../../utils/TriangleUtilities.js';\n\n/*************************************************************/\n/* This file is generated from \"iterationUtils.template.js\". */\n/*************************************************************/\n\nfunction intersectTris( bvh, materialOrSide, ray, offset, count, intersections, near, far ) {\n\n\tconst { geometry, _indirectBuffer } = bvh;\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\n\t\tintersectTri( geometry, materialOrSide, ray, i, intersections, near, far );\n\n\n\t}\n\n}\n\nfunction intersectClosestTri( bvh, materialOrSide, ray, offset, count, near, far ) {\n\n\tconst { geometry, _indirectBuffer } = bvh;\n\tlet dist = Infinity;\n\tlet res = null;\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\t\tlet intersection;\n\n\t\tintersection = intersectTri( geometry, materialOrSide, ray, i, null, near, far );\n\n\n\t\tif ( intersection && intersection.distance < dist ) {\n\n\t\t\tres = intersection;\n\t\t\tdist = intersection.distance;\n\n\t\t}\n\n\t}\n\n\treturn res;\n\n}\n\nfunction iterateOverTriangles(\n\toffset,\n\tcount,\n\tbvh,\n\tintersectsTriangleFunc,\n\tcontained,\n\tdepth,\n\ttriangle\n) {\n\n\tconst { geometry } = bvh;\n\tconst { index } = geometry;\n\tconst pos = geometry.attributes.position;\n\tfor ( let i = offset, l = count + offset; i < l; i ++ ) {\n\n\t\tlet tri;\n\n\t\ttri = i;\n\n\t\tsetTriangle( triangle, tri * 3, index, pos );\n\t\ttriangle.needsUpdate = true;\n\n\t\tif ( intersectsTriangleFunc( triangle, tri, contained, depth ) ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t}\n\n\treturn false;\n\n}\n\nexport { intersectClosestTri, intersectTris, iterateOverTriangles };\n","import { UINT32_PER_NODE, BYTES_PER_NODE } from '../Constants.js';\nimport { IS_LEAF, OFFSET, COUNT, LEFT_NODE, RIGHT_NODE } from '../utils/nodeBufferUtils.js';\n\n/****************************************************/\n/* This file is generated from \"refit.template.js\". */\n/****************************************************/\n\nfunction refit( bvh, nodeIndices = null ) {\n\n\tif ( nodeIndices && Array.isArray( nodeIndices ) ) {\n\n\t\tnodeIndices = new Set( nodeIndices );\n\n\t}\n\n\tconst geometry = bvh.geometry;\n\tconst indexArr = geometry.index ? geometry.index.array : null;\n\tconst posAttr = geometry.attributes.position;\n\n\tlet buffer, uint32Array, uint16Array, float32Array;\n\tlet byteOffset = 0;\n\tconst roots = bvh._roots;\n\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\tbuffer = roots[ i ];\n\t\tuint32Array = new Uint32Array( buffer );\n\t\tuint16Array = new Uint16Array( buffer );\n\t\tfloat32Array = new Float32Array( buffer );\n\n\t\t_traverse( 0, byteOffset );\n\t\tbyteOffset += buffer.byteLength;\n\n\t}\n\n\tfunction _traverse( nodeIndex32, byteOffset, force = false ) {\n\n\t\tconst nodeIndex16 = nodeIndex32 * 2;\n\t\tif ( IS_LEAF( nodeIndex16, uint16Array ) ) {\n\n\t\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\t\t\tlet minx = Infinity;\n\t\t\tlet miny = Infinity;\n\t\t\tlet minz = Infinity;\n\t\t\tlet maxx = - Infinity;\n\t\t\tlet maxy = - Infinity;\n\t\t\tlet maxz = - Infinity;\n\n\n\t\t\tfor ( let i = 3 * offset, l = 3 * ( offset + count ); i < l; i ++ ) {\n\n\t\t\t\tlet index = indexArr[ i ];\n\t\t\t\tconst x = posAttr.getX( index );\n\t\t\t\tconst y = posAttr.getY( index );\n\t\t\t\tconst z = posAttr.getZ( index );\n\n\t\t\t\tif ( x < minx ) minx = x;\n\t\t\t\tif ( x > maxx ) maxx = x;\n\n\t\t\t\tif ( y < miny ) miny = y;\n\t\t\t\tif ( y > maxy ) maxy = y;\n\n\t\t\t\tif ( z < minz ) minz = z;\n\t\t\t\tif ( z > maxz ) maxz = z;\n\n\t\t\t}\n\n\n\t\t\tif (\n\t\t\t\tfloat32Array[ nodeIndex32 + 0 ] !== minx ||\n\t\t\t\tfloat32Array[ nodeIndex32 + 1 ] !== miny ||\n\t\t\t\tfloat32Array[ nodeIndex32 + 2 ] !== minz ||\n\n\t\t\t\tfloat32Array[ nodeIndex32 + 3 ] !== maxx ||\n\t\t\t\tfloat32Array[ nodeIndex32 + 4 ] !== maxy ||\n\t\t\t\tfloat32Array[ nodeIndex32 + 5 ] !== maxz\n\t\t\t) {\n\n\t\t\t\tfloat32Array[ nodeIndex32 + 0 ] = minx;\n\t\t\t\tfloat32Array[ nodeIndex32 + 1 ] = miny;\n\t\t\t\tfloat32Array[ nodeIndex32 + 2 ] = minz;\n\n\t\t\t\tfloat32Array[ nodeIndex32 + 3 ] = maxx;\n\t\t\t\tfloat32Array[ nodeIndex32 + 4 ] = maxy;\n\t\t\t\tfloat32Array[ nodeIndex32 + 5 ] = maxz;\n\n\t\t\t\treturn true;\n\n\t\t\t} else {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst left = LEFT_NODE( nodeIndex32 );\n\t\t\tconst right = RIGHT_NODE( nodeIndex32, uint32Array );\n\n\t\t\t// the identifying node indices provided by the shapecast function include offsets of all\n\t\t\t// root buffers to guarantee they're unique between roots so offset left and right indices here.\n\t\t\tlet forceChildren = force;\n\t\t\tlet includesLeft = false;\n\t\t\tlet includesRight = false;\n\n\t\t\tif ( nodeIndices ) {\n\n\t\t\t\t// if we see that neither the left or right child are included in the set that need to be updated\n\t\t\t\t// then we assume that all children need to be updated.\n\t\t\t\tif ( ! forceChildren ) {\n\n\t\t\t\t\tconst leftNodeId = left / UINT32_PER_NODE + byteOffset / BYTES_PER_NODE;\n\t\t\t\t\tconst rightNodeId = right / UINT32_PER_NODE + byteOffset / BYTES_PER_NODE;\n\t\t\t\t\tincludesLeft = nodeIndices.has( leftNodeId );\n\t\t\t\t\tincludesRight = nodeIndices.has( rightNodeId );\n\t\t\t\t\tforceChildren = ! includesLeft && ! includesRight;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tincludesLeft = true;\n\t\t\t\tincludesRight = true;\n\n\t\t\t}\n\n\t\t\tconst traverseLeft = forceChildren || includesLeft;\n\t\t\tconst traverseRight = forceChildren || includesRight;\n\n\t\t\tlet leftChange = false;\n\t\t\tif ( traverseLeft ) {\n\n\t\t\t\tleftChange = _traverse( left, byteOffset, forceChildren );\n\n\t\t\t}\n\n\t\t\tlet rightChange = false;\n\t\t\tif ( traverseRight ) {\n\n\t\t\t\trightChange = _traverse( right, byteOffset, forceChildren );\n\n\t\t\t}\n\n\t\t\tconst didChange = leftChange || rightChange;\n\t\t\tif ( didChange ) {\n\n\t\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\tconst left_i = left + i;\n\t\t\t\t\tconst right_i = right + i;\n\t\t\t\t\tconst minLeftValue = float32Array[ left_i ];\n\t\t\t\t\tconst maxLeftValue = float32Array[ left_i + 3 ];\n\t\t\t\t\tconst minRightValue = float32Array[ right_i ];\n\t\t\t\t\tconst maxRightValue = float32Array[ right_i + 3 ];\n\n\t\t\t\t\tfloat32Array[ nodeIndex32 + i ] = minLeftValue < minRightValue ? minLeftValue : minRightValue;\n\t\t\t\t\tfloat32Array[ nodeIndex32 + i + 3 ] = maxLeftValue > maxRightValue ? maxLeftValue : maxRightValue;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn didChange;\n\n\t\t}\n\n\t}\n\n}\n\nexport { refit };\n","/**\n * This function performs intersection tests similar to Ray.intersectBox in three.js,\n * with the difference that the box values are read from an array to improve performance.\n */\nexport function intersectRay( nodeIndex32, array, ray, near, far ) {\n\n\tlet tmin, tmax, tymin, tymax, tzmin, tzmax;\n\n\tconst invdirx = 1 / ray.direction.x,\n\t\tinvdiry = 1 / ray.direction.y,\n\t\tinvdirz = 1 / ray.direction.z;\n\n\tconst ox = ray.origin.x;\n\tconst oy = ray.origin.y;\n\tconst oz = ray.origin.z;\n\n\tlet minx = array[ nodeIndex32 ];\n\tlet maxx = array[ nodeIndex32 + 3 ];\n\n\tlet miny = array[ nodeIndex32 + 1 ];\n\tlet maxy = array[ nodeIndex32 + 3 + 1 ];\n\n\tlet minz = array[ nodeIndex32 + 2 ];\n\tlet maxz = array[ nodeIndex32 + 3 + 2 ];\n\n\tif ( invdirx >= 0 ) {\n\n\t\ttmin = ( minx - ox ) * invdirx;\n\t\ttmax = ( maxx - ox ) * invdirx;\n\n\t} else {\n\n\t\ttmin = ( maxx - ox ) * invdirx;\n\t\ttmax = ( minx - ox ) * invdirx;\n\n\t}\n\n\tif ( invdiry >= 0 ) {\n\n\t\ttymin = ( miny - oy ) * invdiry;\n\t\ttymax = ( maxy - oy ) * invdiry;\n\n\t} else {\n\n\t\ttymin = ( maxy - oy ) * invdiry;\n\t\ttymax = ( miny - oy ) * invdiry;\n\n\t}\n\n\tif ( ( tmin > tymax ) || ( tymin > tmax ) ) return false;\n\n\tif ( tymin > tmin || isNaN( tmin ) ) tmin = tymin;\n\n\tif ( tymax < tmax || isNaN( tmax ) ) tmax = tymax;\n\n\tif ( invdirz >= 0 ) {\n\n\t\ttzmin = ( minz - oz ) * invdirz;\n\t\ttzmax = ( maxz - oz ) * invdirz;\n\n\t} else {\n\n\t\ttzmin = ( maxz - oz ) * invdirz;\n\t\ttzmax = ( minz - oz ) * invdirz;\n\n\t}\n\n\tif ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return false;\n\n\tif ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;\n\n\tif ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;\n\n\t//return point closest to the ray (positive side)\n\n\treturn tmin <= far && tmax >= near;\n\n}\n","import { intersectTri } from '../../utils/ThreeRayIntersectUtilities.js';\nimport { setTriangle } from '../../utils/TriangleUtilities.js';\n\n/*************************************************************/\n/* This file is generated from \"iterationUtils.template.js\". */\n/*************************************************************/\n\nfunction intersectTris_indirect( bvh, materialOrSide, ray, offset, count, intersections, near, far ) {\n\n\tconst { geometry, _indirectBuffer } = bvh;\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\t\tlet vi = _indirectBuffer ? _indirectBuffer[ i ] : i;\n\t\tintersectTri( geometry, materialOrSide, ray, vi, intersections, near, far );\n\n\n\t}\n\n}\n\nfunction intersectClosestTri_indirect( bvh, materialOrSide, ray, offset, count, near, far ) {\n\n\tconst { geometry, _indirectBuffer } = bvh;\n\tlet dist = Infinity;\n\tlet res = null;\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\t\tlet intersection;\n\t\tintersection = intersectTri( geometry, materialOrSide, ray, _indirectBuffer ? _indirectBuffer[ i ] : i, null, near, far );\n\n\n\t\tif ( intersection && intersection.distance < dist ) {\n\n\t\t\tres = intersection;\n\t\t\tdist = intersection.distance;\n\n\t\t}\n\n\t}\n\n\treturn res;\n\n}\n\nfunction iterateOverTriangles_indirect(\n\toffset,\n\tcount,\n\tbvh,\n\tintersectsTriangleFunc,\n\tcontained,\n\tdepth,\n\ttriangle\n) {\n\n\tconst { geometry } = bvh;\n\tconst { index } = geometry;\n\tconst pos = geometry.attributes.position;\n\tfor ( let i = offset, l = count + offset; i < l; i ++ ) {\n\n\t\tlet tri;\n\t\ttri = bvh.resolveTriangleIndex( i );\n\n\t\tsetTriangle( triangle, tri * 3, index, pos );\n\t\ttriangle.needsUpdate = true;\n\n\t\tif ( intersectsTriangleFunc( triangle, tri, contained, depth ) ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t}\n\n\treturn false;\n\n}\n\nexport { intersectClosestTri_indirect, intersectTris_indirect, iterateOverTriangles_indirect };\n","import { intersectRay } from '../utils/intersectUtils.js';\nimport { IS_LEAF, OFFSET, COUNT, LEFT_NODE, RIGHT_NODE } from '../utils/nodeBufferUtils.js';\nimport { BufferStack } from '../utils/BufferStack.js';\nimport { intersectTris } from '../utils/iterationUtils.generated.js';\nimport '../utils/iterationUtils_indirect.generated.js';\n\n/******************************************************/\n/* This file is generated from \"raycast.template.js\". */\n/******************************************************/\n\nfunction raycast( bvh, root, materialOrSide, ray, intersects, near, far ) {\n\n\tBufferStack.setBuffer( bvh._roots[ root ] );\n\t_raycast( 0, bvh, materialOrSide, ray, intersects, near, far );\n\tBufferStack.clearBuffer();\n\n}\n\nfunction _raycast( nodeIndex32, bvh, materialOrSide, ray, intersects, near, far ) {\n\n\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\tconst nodeIndex16 = nodeIndex32 * 2;\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\n\t\tintersectTris( bvh, materialOrSide, ray, offset, count, intersects, near, far );\n\n\n\t} else {\n\n\t\tconst leftIndex = LEFT_NODE( nodeIndex32 );\n\t\tif ( intersectRay( leftIndex, float32Array, ray, near, far ) ) {\n\n\t\t\t_raycast( leftIndex, bvh, materialOrSide, ray, intersects, near, far );\n\n\t\t}\n\n\t\tconst rightIndex = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\tif ( intersectRay( rightIndex, float32Array, ray, near, far ) ) {\n\n\t\t\t_raycast( rightIndex, bvh, materialOrSide, ray, intersects, near, far );\n\n\t\t}\n\n\t}\n\n}\n\nexport { raycast };\n","import { IS_LEAF, OFFSET, COUNT, SPLIT_AXIS, LEFT_NODE, RIGHT_NODE } from '../utils/nodeBufferUtils.js';\nimport { BufferStack } from '../utils/BufferStack.js';\nimport { intersectRay } from '../utils/intersectUtils.js';\nimport { intersectClosestTri } from '../utils/iterationUtils.generated.js';\nimport '../utils/iterationUtils_indirect.generated.js';\n\n/***********************************************************/\n/* This file is generated from \"raycastFirst.template.js\". */\n/***********************************************************/\n\nconst _xyzFields = [ 'x', 'y', 'z' ];\n\nfunction raycastFirst( bvh, root, materialOrSide, ray, near, far ) {\n\n\tBufferStack.setBuffer( bvh._roots[ root ] );\n\tconst result = _raycastFirst( 0, bvh, materialOrSide, ray, near, far );\n\tBufferStack.clearBuffer();\n\n\treturn result;\n\n}\n\nfunction _raycastFirst( nodeIndex32, bvh, materialOrSide, ray, near, far ) {\n\n\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\n\t\t// eslint-disable-next-line no-unreachable\n\t\treturn intersectClosestTri( bvh, materialOrSide, ray, offset, count, near, far );\n\n\n\t} else {\n\n\t\t// consider the position of the split plane with respect to the oncoming ray; whichever direction\n\t\t// the ray is coming from, look for an intersection among that side of the tree first\n\t\tconst splitAxis = SPLIT_AXIS( nodeIndex32, uint32Array );\n\t\tconst xyzAxis = _xyzFields[ splitAxis ];\n\t\tconst rayDir = ray.direction[ xyzAxis ];\n\t\tconst leftToRight = rayDir >= 0;\n\n\t\t// c1 is the child to check first\n\t\tlet c1, c2;\n\t\tif ( leftToRight ) {\n\n\t\t\tc1 = LEFT_NODE( nodeIndex32 );\n\t\t\tc2 = RIGHT_NODE( nodeIndex32, uint32Array );\n\n\t\t} else {\n\n\t\t\tc1 = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\t\tc2 = LEFT_NODE( nodeIndex32 );\n\n\t\t}\n\n\t\tconst c1Intersection = intersectRay( c1, float32Array, ray, near, far );\n\t\tconst c1Result = c1Intersection ? _raycastFirst( c1, bvh, materialOrSide, ray, near, far ) : null;\n\n\t\t// if we got an intersection in the first node and it's closer than the second node's bounding\n\t\t// box, we don't need to consider the second node because it couldn't possibly be a better result\n\t\tif ( c1Result ) {\n\n\t\t\t// check if the point is within the second bounds\n\t\t\t// \"point\" is in the local frame of the bvh\n\t\t\tconst point = c1Result.point[ xyzAxis ];\n\t\t\tconst isOutside = leftToRight ?\n\t\t\t\tpoint <= float32Array[ c2 + splitAxis ] : // min bounding data\n\t\t\t\tpoint >= float32Array[ c2 + splitAxis + 3 ]; // max bounding data\n\n\t\t\tif ( isOutside ) {\n\n\t\t\t\treturn c1Result;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// either there was no intersection in the first node, or there could still be a closer\n\t\t// intersection in the second, so check the second node and then take the better of the two\n\t\tconst c2Intersection = intersectRay( c2, float32Array, ray, near, far );\n\t\tconst c2Result = c2Intersection ? _raycastFirst( c2, bvh, materialOrSide, ray, near, far ) : null;\n\n\t\tif ( c1Result && c2Result ) {\n\n\t\t\treturn c1Result.distance <= c2Result.distance ? c1Result : c2Result;\n\n\t\t} else {\n\n\t\t\treturn c1Result || c2Result || null;\n\n\t\t}\n\n\t}\n\n}\n\nexport { raycastFirst };\n","import { Box3, Matrix4 } from 'three';\nimport { OrientedBox } from '../../math/OrientedBox.js';\nimport { ExtendedTriangle } from '../../math/ExtendedTriangle.js';\nimport { setTriangle } from '../../utils/TriangleUtilities.js';\nimport { arrayToBox } from '../../utils/ArrayBoxUtilities.js';\nimport { IS_LEAF, OFFSET, COUNT, BOUNDING_DATA_INDEX, LEFT_NODE, RIGHT_NODE } from '../utils/nodeBufferUtils.js';\nimport { BufferStack } from '../utils/BufferStack.js';\nimport { getTriCount } from '../build/geometryUtils.js';\n\n/*****************************************************************/\n/* This file is generated from \"intersectsGeometry.template.js\". */\n/*****************************************************************/\n/* eslint-disable indent */\n\nconst boundingBox = /* @__PURE__ */ new Box3();\nconst triangle = /* @__PURE__ */ new ExtendedTriangle();\nconst triangle2 = /* @__PURE__ */ new ExtendedTriangle();\nconst invertedMat = /* @__PURE__ */ new Matrix4();\n\nconst obb = /* @__PURE__ */ new OrientedBox();\nconst obb2 = /* @__PURE__ */ new OrientedBox();\n\nfunction intersectsGeometry( bvh, root, otherGeometry, geometryToBvh ) {\n\n\tBufferStack.setBuffer( bvh._roots[ root ] );\n\tconst result = _intersectsGeometry( 0, bvh, otherGeometry, geometryToBvh );\n\tBufferStack.clearBuffer();\n\n\treturn result;\n\n}\n\nfunction _intersectsGeometry( nodeIndex32, bvh, otherGeometry, geometryToBvh, cachedObb = null ) {\n\n\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\tif ( cachedObb === null ) {\n\n\t\tif ( ! otherGeometry.boundingBox ) {\n\n\t\t\totherGeometry.computeBoundingBox();\n\n\t\t}\n\n\t\tobb.set( otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh );\n\t\tcachedObb = obb;\n\n\t}\n\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst thisGeometry = bvh.geometry;\n\t\tconst thisIndex = thisGeometry.index;\n\t\tconst thisPos = thisGeometry.attributes.position;\n\n\t\tconst otherIndex = otherGeometry.index;\n\t\tconst otherPos = otherGeometry.attributes.position;\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\t\t// get the inverse of the geometry matrix so we can transform our triangles into the\n\t\t// geometry space we're trying to test. We assume there are fewer triangles being checked\n\t\t// here.\n\t\tinvertedMat.copy( geometryToBvh ).invert();\n\n\t\tif ( otherGeometry.boundsTree ) {\n\n\t\t\t// if there's a bounds tree\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( nodeIndex32 ), float32Array, obb2 );\n\t\t\tobb2.matrix.copy( invertedMat );\n\t\t\tobb2.needsUpdate = true;\n\n\t\t\t// TODO: use a triangle iteration function here\n\t\t\tconst res = otherGeometry.boundsTree.shapecast( {\n\n\t\t\t\tintersectsBounds: box => obb2.intersectsBox( box ),\n\n\t\t\t\tintersectsTriangle: tri => {\n\n\t\t\t\t\ttri.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\ttri.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\ttri.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\ttri.needsUpdate = true;\n\n\n\t\t\t\t\tfor ( let i = offset * 3, l = ( count + offset ) * 3; i < l; i += 3 ) {\n\n\t\t\t\t\t\t// this triangle needs to be transformed into the current BVH coordinate frame\n\t\t\t\t\t\tsetTriangle( triangle2, i, thisIndex, thisPos );\n\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\t\t\t\t\t\tif ( tri.intersectsTriangle( triangle2 ) ) {\n\n\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\treturn res;\n\n\t\t} else {\n\n\t\t\t// if we're just dealing with raw geometry\n\t\t\tconst otherTriangleCount = getTriCount( otherGeometry );\n\n\n\t\t\tfor ( let i = offset * 3, l = ( count + offset ) * 3; i < l; i += 3 ) {\n\n\t\t\t\t// this triangle needs to be transformed into the current BVH coordinate frame\n\t\t\t\tsetTriangle( triangle, i, thisIndex, thisPos );\n\n\n\t\t\t\ttriangle.a.applyMatrix4( invertedMat );\n\t\t\t\ttriangle.b.applyMatrix4( invertedMat );\n\t\t\t\ttriangle.c.applyMatrix4( invertedMat );\n\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\tfor ( let i2 = 0, l2 = otherTriangleCount * 3; i2 < l2; i2 += 3 ) {\n\n\t\t\t\t\tsetTriangle( triangle2, i2, otherIndex, otherPos );\n\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\tif ( triangle.intersectsTriangle( triangle2 ) ) {\n\n\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\n\t\t\t}\n\n\n\t\t}\n\n\t} else {\n\n\t\tconst left = LEFT_NODE( nodeIndex32 );\n\t\tconst right = RIGHT_NODE( nodeIndex32, uint32Array );\n\n\t\tarrayToBox( BOUNDING_DATA_INDEX( left ), float32Array, boundingBox );\n\t\tconst leftIntersection =\n\t\t\tcachedObb.intersectsBox( boundingBox ) &&\n\t\t\t_intersectsGeometry( left, bvh, otherGeometry, geometryToBvh, cachedObb );\n\n\t\tif ( leftIntersection ) return true;\n\n\t\tarrayToBox( BOUNDING_DATA_INDEX( right ), float32Array, boundingBox );\n\t\tconst rightIntersection =\n\t\t\tcachedObb.intersectsBox( boundingBox ) &&\n\t\t\t_intersectsGeometry( right, bvh, otherGeometry, geometryToBvh, cachedObb );\n\n\t\tif ( rightIntersection ) return true;\n\n\t\treturn false;\n\n\t}\n\n}\n\nexport { intersectsGeometry };\n","import { Matrix4, Vector3 } from 'three';\nimport { OrientedBox } from '../../math/OrientedBox.js';\nimport { setTriangle } from '../../utils/TriangleUtilities.js';\nimport { getTriCount } from '../build/geometryUtils.js';\nimport { ExtendedTrianglePool } from '../../utils/ExtendedTrianglePool.js';\n\n/*********************************************************************/\n/* This file is generated from \"closestPointToGeometry.template.js\". */\n/*********************************************************************/\n\nconst tempMatrix = /* @__PURE__ */ new Matrix4();\nconst obb = /* @__PURE__ */ new OrientedBox();\nconst obb2 = /* @__PURE__ */ new OrientedBox();\nconst temp1 = /* @__PURE__ */ new Vector3();\nconst temp2 = /* @__PURE__ */ new Vector3();\nconst temp3 = /* @__PURE__ */ new Vector3();\nconst temp4 = /* @__PURE__ */ new Vector3();\n\nfunction closestPointToGeometry(\n\tbvh,\n\totherGeometry,\n\tgeometryToBvh,\n\ttarget1 = { },\n\ttarget2 = { },\n\tminThreshold = 0,\n\tmaxThreshold = Infinity,\n) {\n\n\tif ( ! otherGeometry.boundingBox ) {\n\n\t\totherGeometry.computeBoundingBox();\n\n\t}\n\n\tobb.set( otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh );\n\tobb.needsUpdate = true;\n\n\tconst geometry = bvh.geometry;\n\tconst pos = geometry.attributes.position;\n\tconst index = geometry.index;\n\tconst otherPos = otherGeometry.attributes.position;\n\tconst otherIndex = otherGeometry.index;\n\tconst triangle = ExtendedTrianglePool.getPrimitive();\n\tconst triangle2 = ExtendedTrianglePool.getPrimitive();\n\n\tlet tempTarget1 = temp1;\n\tlet tempTargetDest1 = temp2;\n\tlet tempTarget2 = null;\n\tlet tempTargetDest2 = null;\n\n\tif ( target2 ) {\n\n\t\ttempTarget2 = temp3;\n\t\ttempTargetDest2 = temp4;\n\n\t}\n\n\tlet closestDistance = Infinity;\n\tlet closestDistanceTriIndex = null;\n\tlet closestDistanceOtherTriIndex = null;\n\ttempMatrix.copy( geometryToBvh ).invert();\n\tobb2.matrix.copy( tempMatrix );\n\tbvh.shapecast(\n\t\t{\n\n\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\treturn obb.distanceToBox( box );\n\n\t\t\t},\n\n\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\tif ( score < closestDistance && score < maxThreshold ) {\n\n\t\t\t\t\t// if we know the triangles of this bounds will be intersected next then\n\t\t\t\t\t// save the bounds to use during triangle checks.\n\t\t\t\t\tif ( isLeaf ) {\n\n\t\t\t\t\t\tobb2.min.copy( box.min );\n\t\t\t\t\t\tobb2.max.copy( box.max );\n\t\t\t\t\t\tobb2.needsUpdate = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\n\t\t\t},\n\n\t\t\tintersectsRange: ( offset, count ) => {\n\n\t\t\t\tif ( otherGeometry.boundsTree ) {\n\n\t\t\t\t\t// if the other geometry has a bvh then use the accelerated path where we use shapecast to find\n\t\t\t\t\t// the closest bounds in the other geometry to check.\n\t\t\t\t\tconst otherBvh = otherGeometry.boundsTree;\n\t\t\t\t\treturn otherBvh.shapecast( {\n\t\t\t\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\t\t\t\treturn obb2.distanceToBox( box );\n\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\t\t\t\treturn score < closestDistance && score < maxThreshold;\n\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tintersectsRange: ( otherOffset, otherCount ) => {\n\n\t\t\t\t\t\t\tfor ( let i2 = otherOffset, l2 = otherOffset + otherCount; i2 < l2; i2 ++ ) {\n\n\n\t\t\t\t\t\t\t\tsetTriangle( triangle2, 3 * i2, otherIndex, otherPos );\n\n\t\t\t\t\t\t\t\ttriangle2.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\ttriangle2.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\ttriangle2.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\t\t\t\tfor ( let i = offset, l = offset + count; i < l; i ++ ) {\n\n\n\t\t\t\t\t\t\t\t\tsetTriangle( triangle, 3 * i, index, pos );\n\n\t\t\t\t\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\t\t\t\t\tconst dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );\n\t\t\t\t\t\t\t\t\tif ( dist < closestDistance ) {\n\n\t\t\t\t\t\t\t\t\t\ttempTargetDest1.copy( tempTarget1 );\n\n\t\t\t\t\t\t\t\t\t\tif ( tempTargetDest2 ) {\n\n\t\t\t\t\t\t\t\t\t\t\ttempTargetDest2.copy( tempTarget2 );\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tclosestDistance = dist;\n\t\t\t\t\t\t\t\t\t\tclosestDistanceTriIndex = i;\n\t\t\t\t\t\t\t\t\t\tclosestDistanceOtherTriIndex = i2;\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// stop traversal if we find a point that's under the given threshold\n\t\t\t\t\t\t\t\t\tif ( dist < minThreshold ) {\n\n\t\t\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t},\n\t\t\t\t\t} );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// If no bounds tree then we'll just check every triangle.\n\t\t\t\t\tconst triCount = getTriCount( otherGeometry );\n\t\t\t\t\tfor ( let i2 = 0, l2 = triCount; i2 < l2; i2 ++ ) {\n\n\t\t\t\t\t\tsetTriangle( triangle2, 3 * i2, otherIndex, otherPos );\n\t\t\t\t\t\ttriangle2.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttriangle2.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttriangle2.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\t\tfor ( let i = offset, l = offset + count; i < l; i ++ ) {\n\n\n\t\t\t\t\t\t\tsetTriangle( triangle, 3 * i, index, pos );\n\n\t\t\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\t\t\tconst dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );\n\t\t\t\t\t\t\tif ( dist < closestDistance ) {\n\n\t\t\t\t\t\t\t\ttempTargetDest1.copy( tempTarget1 );\n\n\t\t\t\t\t\t\t\tif ( tempTargetDest2 ) {\n\n\t\t\t\t\t\t\t\t\ttempTargetDest2.copy( tempTarget2 );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tclosestDistance = dist;\n\t\t\t\t\t\t\t\tclosestDistanceTriIndex = i;\n\t\t\t\t\t\t\t\tclosestDistanceOtherTriIndex = i2;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// stop traversal if we find a point that's under the given threshold\n\t\t\t\t\t\t\tif ( dist < minThreshold ) {\n\n\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t}\n\n\t);\n\n\tExtendedTrianglePool.releasePrimitive( triangle );\n\tExtendedTrianglePool.releasePrimitive( triangle2 );\n\n\tif ( closestDistance === Infinity ) {\n\n\t\treturn null;\n\n\t}\n\n\tif ( ! target1.point ) {\n\n\t\ttarget1.point = tempTargetDest1.clone();\n\n\t} else {\n\n\t\ttarget1.point.copy( tempTargetDest1 );\n\n\t}\n\n\ttarget1.distance = closestDistance,\n\ttarget1.faceIndex = closestDistanceTriIndex;\n\n\tif ( target2 ) {\n\n\t\tif ( ! target2.point ) target2.point = tempTargetDest2.clone();\n\t\telse target2.point.copy( tempTargetDest2 );\n\t\ttarget2.point.applyMatrix4( tempMatrix );\n\t\ttempTargetDest1.applyMatrix4( tempMatrix );\n\t\ttarget2.distance = tempTargetDest1.sub( target2.point ).length();\n\t\ttarget2.faceIndex = closestDistanceOtherTriIndex;\n\n\t}\n\n\treturn target1;\n\n}\n\nexport { closestPointToGeometry };\n","import { UINT32_PER_NODE, BYTES_PER_NODE } from '../Constants.js';\nimport { IS_LEAF, OFFSET, COUNT, LEFT_NODE, RIGHT_NODE } from '../utils/nodeBufferUtils.js';\n\n/****************************************************/\n/* This file is generated from \"refit.template.js\". */\n/****************************************************/\n\nfunction refit_indirect( bvh, nodeIndices = null ) {\n\n\tif ( nodeIndices && Array.isArray( nodeIndices ) ) {\n\n\t\tnodeIndices = new Set( nodeIndices );\n\n\t}\n\n\tconst geometry = bvh.geometry;\n\tconst indexArr = geometry.index ? geometry.index.array : null;\n\tconst posAttr = geometry.attributes.position;\n\n\tlet buffer, uint32Array, uint16Array, float32Array;\n\tlet byteOffset = 0;\n\tconst roots = bvh._roots;\n\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\tbuffer = roots[ i ];\n\t\tuint32Array = new Uint32Array( buffer );\n\t\tuint16Array = new Uint16Array( buffer );\n\t\tfloat32Array = new Float32Array( buffer );\n\n\t\t_traverse( 0, byteOffset );\n\t\tbyteOffset += buffer.byteLength;\n\n\t}\n\n\tfunction _traverse( nodeIndex32, byteOffset, force = false ) {\n\n\t\tconst nodeIndex16 = nodeIndex32 * 2;\n\t\tif ( IS_LEAF( nodeIndex16, uint16Array ) ) {\n\n\t\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\t\t\tlet minx = Infinity;\n\t\t\tlet miny = Infinity;\n\t\t\tlet minz = Infinity;\n\t\t\tlet maxx = - Infinity;\n\t\t\tlet maxy = - Infinity;\n\t\t\tlet maxz = - Infinity;\n\n\t\t\tfor ( let i = offset, l = offset + count; i < l; i ++ ) {\n\n\t\t\t\tconst t = 3 * bvh.resolveTriangleIndex( i );\n\t\t\t\tfor ( let j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\tlet index = t + j;\n\t\t\t\t\tindex = indexArr ? indexArr[ index ] : index;\n\n\t\t\t\t\tconst x = posAttr.getX( index );\n\t\t\t\t\tconst y = posAttr.getY( index );\n\t\t\t\t\tconst z = posAttr.getZ( index );\n\n\t\t\t\t\tif ( x < minx ) minx = x;\n\t\t\t\t\tif ( x > maxx ) maxx = x;\n\n\t\t\t\t\tif ( y < miny ) miny = y;\n\t\t\t\t\tif ( y > maxy ) maxy = y;\n\n\t\t\t\t\tif ( z < minz ) minz = z;\n\t\t\t\t\tif ( z > maxz ) maxz = z;\n\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\tif (\n\t\t\t\tfloat32Array[ nodeIndex32 + 0 ] !== minx ||\n\t\t\t\tfloat32Array[ nodeIndex32 + 1 ] !== miny ||\n\t\t\t\tfloat32Array[ nodeIndex32 + 2 ] !== minz ||\n\n\t\t\t\tfloat32Array[ nodeIndex32 + 3 ] !== maxx ||\n\t\t\t\tfloat32Array[ nodeIndex32 + 4 ] !== maxy ||\n\t\t\t\tfloat32Array[ nodeIndex32 + 5 ] !== maxz\n\t\t\t) {\n\n\t\t\t\tfloat32Array[ nodeIndex32 + 0 ] = minx;\n\t\t\t\tfloat32Array[ nodeIndex32 + 1 ] = miny;\n\t\t\t\tfloat32Array[ nodeIndex32 + 2 ] = minz;\n\n\t\t\t\tfloat32Array[ nodeIndex32 + 3 ] = maxx;\n\t\t\t\tfloat32Array[ nodeIndex32 + 4 ] = maxy;\n\t\t\t\tfloat32Array[ nodeIndex32 + 5 ] = maxz;\n\n\t\t\t\treturn true;\n\n\t\t\t} else {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst left = LEFT_NODE( nodeIndex32 );\n\t\t\tconst right = RIGHT_NODE( nodeIndex32, uint32Array );\n\n\t\t\t// the identifying node indices provided by the shapecast function include offsets of all\n\t\t\t// root buffers to guarantee they're unique between roots so offset left and right indices here.\n\t\t\tlet forceChildren = force;\n\t\t\tlet includesLeft = false;\n\t\t\tlet includesRight = false;\n\n\t\t\tif ( nodeIndices ) {\n\n\t\t\t\t// if we see that neither the left or right child are included in the set that need to be updated\n\t\t\t\t// then we assume that all children need to be updated.\n\t\t\t\tif ( ! forceChildren ) {\n\n\t\t\t\t\tconst leftNodeId = left / UINT32_PER_NODE + byteOffset / BYTES_PER_NODE;\n\t\t\t\t\tconst rightNodeId = right / UINT32_PER_NODE + byteOffset / BYTES_PER_NODE;\n\t\t\t\t\tincludesLeft = nodeIndices.has( leftNodeId );\n\t\t\t\t\tincludesRight = nodeIndices.has( rightNodeId );\n\t\t\t\t\tforceChildren = ! includesLeft && ! includesRight;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tincludesLeft = true;\n\t\t\t\tincludesRight = true;\n\n\t\t\t}\n\n\t\t\tconst traverseLeft = forceChildren || includesLeft;\n\t\t\tconst traverseRight = forceChildren || includesRight;\n\n\t\t\tlet leftChange = false;\n\t\t\tif ( traverseLeft ) {\n\n\t\t\t\tleftChange = _traverse( left, byteOffset, forceChildren );\n\n\t\t\t}\n\n\t\t\tlet rightChange = false;\n\t\t\tif ( traverseRight ) {\n\n\t\t\t\trightChange = _traverse( right, byteOffset, forceChildren );\n\n\t\t\t}\n\n\t\t\tconst didChange = leftChange || rightChange;\n\t\t\tif ( didChange ) {\n\n\t\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\tconst left_i = left + i;\n\t\t\t\t\tconst right_i = right + i;\n\t\t\t\t\tconst minLeftValue = float32Array[ left_i ];\n\t\t\t\t\tconst maxLeftValue = float32Array[ left_i + 3 ];\n\t\t\t\t\tconst minRightValue = float32Array[ right_i ];\n\t\t\t\t\tconst maxRightValue = float32Array[ right_i + 3 ];\n\n\t\t\t\t\tfloat32Array[ nodeIndex32 + i ] = minLeftValue < minRightValue ? minLeftValue : minRightValue;\n\t\t\t\t\tfloat32Array[ nodeIndex32 + i + 3 ] = maxLeftValue > maxRightValue ? maxLeftValue : maxRightValue;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn didChange;\n\n\t\t}\n\n\t}\n\n}\n\nexport { refit_indirect };\n","import { intersectRay } from '../utils/intersectUtils.js';\nimport { IS_LEAF, OFFSET, COUNT, LEFT_NODE, RIGHT_NODE } from '../utils/nodeBufferUtils.js';\nimport { BufferStack } from '../utils/BufferStack.js';\nimport '../utils/iterationUtils.generated.js';\nimport { intersectTris_indirect } from '../utils/iterationUtils_indirect.generated.js';\n\n/******************************************************/\n/* This file is generated from \"raycast.template.js\". */\n/******************************************************/\n\nfunction raycast_indirect( bvh, root, materialOrSide, ray, intersects, near, far ) {\n\n\tBufferStack.setBuffer( bvh._roots[ root ] );\n\t_raycast( 0, bvh, materialOrSide, ray, intersects, near, far );\n\tBufferStack.clearBuffer();\n\n}\n\nfunction _raycast( nodeIndex32, bvh, materialOrSide, ray, intersects, near, far ) {\n\n\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\tconst nodeIndex16 = nodeIndex32 * 2;\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\t\tintersectTris_indirect( bvh, materialOrSide, ray, offset, count, intersects, near, far );\n\n\n\t} else {\n\n\t\tconst leftIndex = LEFT_NODE( nodeIndex32 );\n\t\tif ( intersectRay( leftIndex, float32Array, ray, near, far ) ) {\n\n\t\t\t_raycast( leftIndex, bvh, materialOrSide, ray, intersects, near, far );\n\n\t\t}\n\n\t\tconst rightIndex = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\tif ( intersectRay( rightIndex, float32Array, ray, near, far ) ) {\n\n\t\t\t_raycast( rightIndex, bvh, materialOrSide, ray, intersects, near, far );\n\n\t\t}\n\n\t}\n\n}\n\nexport { raycast_indirect };\n","import { IS_LEAF, OFFSET, COUNT, SPLIT_AXIS, LEFT_NODE, RIGHT_NODE } from '../utils/nodeBufferUtils.js';\nimport { BufferStack } from '../utils/BufferStack.js';\nimport { intersectRay } from '../utils/intersectUtils.js';\nimport '../utils/iterationUtils.generated.js';\nimport { intersectClosestTri_indirect } from '../utils/iterationUtils_indirect.generated.js';\n\n/***********************************************************/\n/* This file is generated from \"raycastFirst.template.js\". */\n/***********************************************************/\n\nconst _xyzFields = [ 'x', 'y', 'z' ];\n\nfunction raycastFirst_indirect( bvh, root, materialOrSide, ray, near, far ) {\n\n\tBufferStack.setBuffer( bvh._roots[ root ] );\n\tconst result = _raycastFirst( 0, bvh, materialOrSide, ray, near, far );\n\tBufferStack.clearBuffer();\n\n\treturn result;\n\n}\n\nfunction _raycastFirst( nodeIndex32, bvh, materialOrSide, ray, near, far ) {\n\n\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\t\treturn intersectClosestTri_indirect( bvh, materialOrSide, ray, offset, count, near, far );\n\n\n\t} else {\n\n\t\t// consider the position of the split plane with respect to the oncoming ray; whichever direction\n\t\t// the ray is coming from, look for an intersection among that side of the tree first\n\t\tconst splitAxis = SPLIT_AXIS( nodeIndex32, uint32Array );\n\t\tconst xyzAxis = _xyzFields[ splitAxis ];\n\t\tconst rayDir = ray.direction[ xyzAxis ];\n\t\tconst leftToRight = rayDir >= 0;\n\n\t\t// c1 is the child to check first\n\t\tlet c1, c2;\n\t\tif ( leftToRight ) {\n\n\t\t\tc1 = LEFT_NODE( nodeIndex32 );\n\t\t\tc2 = RIGHT_NODE( nodeIndex32, uint32Array );\n\n\t\t} else {\n\n\t\t\tc1 = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\t\tc2 = LEFT_NODE( nodeIndex32 );\n\n\t\t}\n\n\t\tconst c1Intersection = intersectRay( c1, float32Array, ray, near, far );\n\t\tconst c1Result = c1Intersection ? _raycastFirst( c1, bvh, materialOrSide, ray, near, far ) : null;\n\n\t\t// if we got an intersection in the first node and it's closer than the second node's bounding\n\t\t// box, we don't need to consider the second node because it couldn't possibly be a better result\n\t\tif ( c1Result ) {\n\n\t\t\t// check if the point is within the second bounds\n\t\t\t// \"point\" is in the local frame of the bvh\n\t\t\tconst point = c1Result.point[ xyzAxis ];\n\t\t\tconst isOutside = leftToRight ?\n\t\t\t\tpoint <= float32Array[ c2 + splitAxis ] : // min bounding data\n\t\t\t\tpoint >= float32Array[ c2 + splitAxis + 3 ]; // max bounding data\n\n\t\t\tif ( isOutside ) {\n\n\t\t\t\treturn c1Result;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// either there was no intersection in the first node, or there could still be a closer\n\t\t// intersection in the second, so check the second node and then take the better of the two\n\t\tconst c2Intersection = intersectRay( c2, float32Array, ray, near, far );\n\t\tconst c2Result = c2Intersection ? _raycastFirst( c2, bvh, materialOrSide, ray, near, far ) : null;\n\n\t\tif ( c1Result && c2Result ) {\n\n\t\t\treturn c1Result.distance <= c2Result.distance ? c1Result : c2Result;\n\n\t\t} else {\n\n\t\t\treturn c1Result || c2Result || null;\n\n\t\t}\n\n\t}\n\n}\n\nexport { raycastFirst_indirect };\n","import { Box3, Matrix4 } from 'three';\nimport { OrientedBox } from '../../math/OrientedBox.js';\nimport { ExtendedTriangle } from '../../math/ExtendedTriangle.js';\nimport { setTriangle } from '../../utils/TriangleUtilities.js';\nimport { arrayToBox } from '../../utils/ArrayBoxUtilities.js';\nimport { IS_LEAF, OFFSET, COUNT, BOUNDING_DATA_INDEX, LEFT_NODE, RIGHT_NODE } from '../utils/nodeBufferUtils.js';\nimport { BufferStack } from '../utils/BufferStack.js';\nimport { getTriCount } from '../build/geometryUtils.js';\n\n/*****************************************************************/\n/* This file is generated from \"intersectsGeometry.template.js\". */\n/*****************************************************************/\n/* eslint-disable indent */\n\nconst boundingBox = /* @__PURE__ */ new Box3();\nconst triangle = /* @__PURE__ */ new ExtendedTriangle();\nconst triangle2 = /* @__PURE__ */ new ExtendedTriangle();\nconst invertedMat = /* @__PURE__ */ new Matrix4();\n\nconst obb = /* @__PURE__ */ new OrientedBox();\nconst obb2 = /* @__PURE__ */ new OrientedBox();\n\nfunction intersectsGeometry_indirect( bvh, root, otherGeometry, geometryToBvh ) {\n\n\tBufferStack.setBuffer( bvh._roots[ root ] );\n\tconst result = _intersectsGeometry( 0, bvh, otherGeometry, geometryToBvh );\n\tBufferStack.clearBuffer();\n\n\treturn result;\n\n}\n\nfunction _intersectsGeometry( nodeIndex32, bvh, otherGeometry, geometryToBvh, cachedObb = null ) {\n\n\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\tif ( cachedObb === null ) {\n\n\t\tif ( ! otherGeometry.boundingBox ) {\n\n\t\t\totherGeometry.computeBoundingBox();\n\n\t\t}\n\n\t\tobb.set( otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh );\n\t\tcachedObb = obb;\n\n\t}\n\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst thisGeometry = bvh.geometry;\n\t\tconst thisIndex = thisGeometry.index;\n\t\tconst thisPos = thisGeometry.attributes.position;\n\n\t\tconst otherIndex = otherGeometry.index;\n\t\tconst otherPos = otherGeometry.attributes.position;\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\t\t// get the inverse of the geometry matrix so we can transform our triangles into the\n\t\t// geometry space we're trying to test. We assume there are fewer triangles being checked\n\t\t// here.\n\t\tinvertedMat.copy( geometryToBvh ).invert();\n\n\t\tif ( otherGeometry.boundsTree ) {\n\n\t\t\t// if there's a bounds tree\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( nodeIndex32 ), float32Array, obb2 );\n\t\t\tobb2.matrix.copy( invertedMat );\n\t\t\tobb2.needsUpdate = true;\n\n\t\t\t// TODO: use a triangle iteration function here\n\t\t\tconst res = otherGeometry.boundsTree.shapecast( {\n\n\t\t\t\tintersectsBounds: box => obb2.intersectsBox( box ),\n\n\t\t\t\tintersectsTriangle: tri => {\n\n\t\t\t\t\ttri.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\ttri.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\ttri.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\ttri.needsUpdate = true;\n\n\t\t\t\t\tfor ( let i = offset, l = count + offset; i < l; i ++ ) {\n\n\t\t\t\t\t\t// this triangle needs to be transformed into the current BVH coordinate frame\n\t\t\t\t\t\tsetTriangle( triangle2, 3 * bvh.resolveTriangleIndex( i ), thisIndex, thisPos );\n\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\t\t\t\t\t\tif ( tri.intersectsTriangle( triangle2 ) ) {\n\n\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\treturn res;\n\n\t\t} else {\n\n\t\t\t// if we're just dealing with raw geometry\n\t\t\tconst otherTriangleCount = getTriCount( otherGeometry );\n\n\t\t\tfor ( let i = offset, l = count + offset; i < l; i ++ ) {\n\n\t\t\t\t// this triangle needs to be transformed into the current BVH coordinate frame\n\t\t\t\tconst ti = bvh.resolveTriangleIndex( i );\n\t\t\t\tsetTriangle( triangle, 3 * ti, thisIndex, thisPos );\n\n\n\t\t\t\ttriangle.a.applyMatrix4( invertedMat );\n\t\t\t\ttriangle.b.applyMatrix4( invertedMat );\n\t\t\t\ttriangle.c.applyMatrix4( invertedMat );\n\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\tfor ( let i2 = 0, l2 = otherTriangleCount * 3; i2 < l2; i2 += 3 ) {\n\n\t\t\t\t\tsetTriangle( triangle2, i2, otherIndex, otherPos );\n\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\tif ( triangle.intersectsTriangle( triangle2 ) ) {\n\n\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t}\n\n\t} else {\n\n\t\tconst left = LEFT_NODE( nodeIndex32 );\n\t\tconst right = RIGHT_NODE( nodeIndex32, uint32Array );\n\n\t\tarrayToBox( BOUNDING_DATA_INDEX( left ), float32Array, boundingBox );\n\t\tconst leftIntersection =\n\t\t\tcachedObb.intersectsBox( boundingBox ) &&\n\t\t\t_intersectsGeometry( left, bvh, otherGeometry, geometryToBvh, cachedObb );\n\n\t\tif ( leftIntersection ) return true;\n\n\t\tarrayToBox( BOUNDING_DATA_INDEX( right ), float32Array, boundingBox );\n\t\tconst rightIntersection =\n\t\t\tcachedObb.intersectsBox( boundingBox ) &&\n\t\t\t_intersectsGeometry( right, bvh, otherGeometry, geometryToBvh, cachedObb );\n\n\t\tif ( rightIntersection ) return true;\n\n\t\treturn false;\n\n\t}\n\n}\n\nexport { intersectsGeometry_indirect };\n","import { Matrix4, Vector3 } from 'three';\nimport { OrientedBox } from '../../math/OrientedBox.js';\nimport { setTriangle } from '../../utils/TriangleUtilities.js';\nimport { getTriCount } from '../build/geometryUtils.js';\nimport { ExtendedTrianglePool } from '../../utils/ExtendedTrianglePool.js';\n\n/*********************************************************************/\n/* This file is generated from \"closestPointToGeometry.template.js\". */\n/*********************************************************************/\n\nconst tempMatrix = /* @__PURE__ */ new Matrix4();\nconst obb = /* @__PURE__ */ new OrientedBox();\nconst obb2 = /* @__PURE__ */ new OrientedBox();\nconst temp1 = /* @__PURE__ */ new Vector3();\nconst temp2 = /* @__PURE__ */ new Vector3();\nconst temp3 = /* @__PURE__ */ new Vector3();\nconst temp4 = /* @__PURE__ */ new Vector3();\n\nfunction closestPointToGeometry_indirect(\n\tbvh,\n\totherGeometry,\n\tgeometryToBvh,\n\ttarget1 = { },\n\ttarget2 = { },\n\tminThreshold = 0,\n\tmaxThreshold = Infinity,\n) {\n\n\tif ( ! otherGeometry.boundingBox ) {\n\n\t\totherGeometry.computeBoundingBox();\n\n\t}\n\n\tobb.set( otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh );\n\tobb.needsUpdate = true;\n\n\tconst geometry = bvh.geometry;\n\tconst pos = geometry.attributes.position;\n\tconst index = geometry.index;\n\tconst otherPos = otherGeometry.attributes.position;\n\tconst otherIndex = otherGeometry.index;\n\tconst triangle = ExtendedTrianglePool.getPrimitive();\n\tconst triangle2 = ExtendedTrianglePool.getPrimitive();\n\n\tlet tempTarget1 = temp1;\n\tlet tempTargetDest1 = temp2;\n\tlet tempTarget2 = null;\n\tlet tempTargetDest2 = null;\n\n\tif ( target2 ) {\n\n\t\ttempTarget2 = temp3;\n\t\ttempTargetDest2 = temp4;\n\n\t}\n\n\tlet closestDistance = Infinity;\n\tlet closestDistanceTriIndex = null;\n\tlet closestDistanceOtherTriIndex = null;\n\ttempMatrix.copy( geometryToBvh ).invert();\n\tobb2.matrix.copy( tempMatrix );\n\tbvh.shapecast(\n\t\t{\n\n\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\treturn obb.distanceToBox( box );\n\n\t\t\t},\n\n\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\tif ( score < closestDistance && score < maxThreshold ) {\n\n\t\t\t\t\t// if we know the triangles of this bounds will be intersected next then\n\t\t\t\t\t// save the bounds to use during triangle checks.\n\t\t\t\t\tif ( isLeaf ) {\n\n\t\t\t\t\t\tobb2.min.copy( box.min );\n\t\t\t\t\t\tobb2.max.copy( box.max );\n\t\t\t\t\t\tobb2.needsUpdate = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\n\t\t\t},\n\n\t\t\tintersectsRange: ( offset, count ) => {\n\n\t\t\t\tif ( otherGeometry.boundsTree ) {\n\n\t\t\t\t\t// if the other geometry has a bvh then use the accelerated path where we use shapecast to find\n\t\t\t\t\t// the closest bounds in the other geometry to check.\n\t\t\t\t\tconst otherBvh = otherGeometry.boundsTree;\n\t\t\t\t\treturn otherBvh.shapecast( {\n\t\t\t\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\t\t\t\treturn obb2.distanceToBox( box );\n\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\t\t\t\treturn score < closestDistance && score < maxThreshold;\n\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tintersectsRange: ( otherOffset, otherCount ) => {\n\n\t\t\t\t\t\t\tfor ( let i2 = otherOffset, l2 = otherOffset + otherCount; i2 < l2; i2 ++ ) {\n\n\t\t\t\t\t\t\t\tconst ti2 = otherBvh.resolveTriangleIndex( i2 );\n\t\t\t\t\t\t\t\tsetTriangle( triangle2, 3 * ti2, otherIndex, otherPos );\n\n\t\t\t\t\t\t\t\ttriangle2.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\ttriangle2.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\ttriangle2.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\t\t\t\tfor ( let i = offset, l = offset + count; i < l; i ++ ) {\n\n\t\t\t\t\t\t\t\t\tconst ti = bvh.resolveTriangleIndex( i );\n\t\t\t\t\t\t\t\t\tsetTriangle( triangle, 3 * ti, index, pos );\n\n\t\t\t\t\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\t\t\t\t\tconst dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );\n\t\t\t\t\t\t\t\t\tif ( dist < closestDistance ) {\n\n\t\t\t\t\t\t\t\t\t\ttempTargetDest1.copy( tempTarget1 );\n\n\t\t\t\t\t\t\t\t\t\tif ( tempTargetDest2 ) {\n\n\t\t\t\t\t\t\t\t\t\t\ttempTargetDest2.copy( tempTarget2 );\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tclosestDistance = dist;\n\t\t\t\t\t\t\t\t\t\tclosestDistanceTriIndex = i;\n\t\t\t\t\t\t\t\t\t\tclosestDistanceOtherTriIndex = i2;\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// stop traversal if we find a point that's under the given threshold\n\t\t\t\t\t\t\t\t\tif ( dist < minThreshold ) {\n\n\t\t\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t},\n\t\t\t\t\t} );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// If no bounds tree then we'll just check every triangle.\n\t\t\t\t\tconst triCount = getTriCount( otherGeometry );\n\t\t\t\t\tfor ( let i2 = 0, l2 = triCount; i2 < l2; i2 ++ ) {\n\n\t\t\t\t\t\tsetTriangle( triangle2, 3 * i2, otherIndex, otherPos );\n\t\t\t\t\t\ttriangle2.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttriangle2.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttriangle2.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\t\tfor ( let i = offset, l = offset + count; i < l; i ++ ) {\n\n\t\t\t\t\t\t\tconst ti = bvh.resolveTriangleIndex( i );\n\t\t\t\t\t\t\tsetTriangle( triangle, 3 * ti, index, pos );\n\n\t\t\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\t\t\tconst dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );\n\t\t\t\t\t\t\tif ( dist < closestDistance ) {\n\n\t\t\t\t\t\t\t\ttempTargetDest1.copy( tempTarget1 );\n\n\t\t\t\t\t\t\t\tif ( tempTargetDest2 ) {\n\n\t\t\t\t\t\t\t\t\ttempTargetDest2.copy( tempTarget2 );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tclosestDistance = dist;\n\t\t\t\t\t\t\t\tclosestDistanceTriIndex = i;\n\t\t\t\t\t\t\t\tclosestDistanceOtherTriIndex = i2;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// stop traversal if we find a point that's under the given threshold\n\t\t\t\t\t\t\tif ( dist < minThreshold ) {\n\n\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t}\n\n\t);\n\n\tExtendedTrianglePool.releasePrimitive( triangle );\n\tExtendedTrianglePool.releasePrimitive( triangle2 );\n\n\tif ( closestDistance === Infinity ) {\n\n\t\treturn null;\n\n\t}\n\n\tif ( ! target1.point ) {\n\n\t\ttarget1.point = tempTargetDest1.clone();\n\n\t} else {\n\n\t\ttarget1.point.copy( tempTargetDest1 );\n\n\t}\n\n\ttarget1.distance = closestDistance,\n\ttarget1.faceIndex = closestDistanceTriIndex;\n\n\tif ( target2 ) {\n\n\t\tif ( ! target2.point ) target2.point = tempTargetDest2.clone();\n\t\telse target2.point.copy( tempTargetDest2 );\n\t\ttarget2.point.applyMatrix4( tempMatrix );\n\t\ttempTargetDest1.applyMatrix4( tempMatrix );\n\t\ttarget2.distance = tempTargetDest1.sub( target2.point ).length();\n\t\ttarget2.faceIndex = closestDistanceOtherTriIndex;\n\n\t}\n\n\treturn target1;\n\n}\n\nexport { closestPointToGeometry_indirect };\n","// converts the given BVH raycast intersection to align with the three.js raycast\n// structure (include object, world space distance and point).\nexport function convertRaycastIntersect( hit, object, raycaster ) {\n\n\tif ( hit === null ) {\n\n\t\treturn null;\n\n\t}\n\n\thit.point.applyMatrix4( object.matrixWorld );\n\thit.distance = hit.point.distanceTo( raycaster.ray.origin );\n\thit.object = object;\n\n\treturn hit;\n\n}\n","import { BufferAttribute, FrontSide, Ray, Vector3, Matrix4 } from 'three';\nimport { SKIP_GENERATION, BYTES_PER_NODE, UINT32_PER_NODE, FLOAT32_EPSILON } from './Constants.js';\nimport { OrientedBox } from '../math/OrientedBox.js';\nimport { ExtendedTrianglePool } from '../utils/ExtendedTrianglePool.js';\nimport { closestPointToPoint } from './cast/closestPointToPoint.js';\nimport { IS_LEAF } from './utils/nodeBufferUtils.js';\n\nimport { iterateOverTriangles } from './utils/iterationUtils.generated.js';\nimport { refit } from './cast/refit.generated.js';\nimport { raycast } from './cast/raycast.generated.js';\nimport { raycastFirst } from './cast/raycastFirst.generated.js';\nimport { intersectsGeometry } from './cast/intersectsGeometry.generated.js';\nimport { closestPointToGeometry } from './cast/closestPointToGeometry.generated.js';\n\nimport { iterateOverTriangles_indirect } from './utils/iterationUtils_indirect.generated.js';\nimport { refit_indirect } from './cast/refit_indirect.generated.js';\nimport { raycast_indirect } from './cast/raycast_indirect.generated.js';\nimport { raycastFirst_indirect } from './cast/raycastFirst_indirect.generated.js';\nimport { intersectsGeometry_indirect } from './cast/intersectsGeometry_indirect.generated.js';\nimport { closestPointToGeometry_indirect } from './cast/closestPointToGeometry_indirect.generated.js';\nimport { setTriangle } from '../utils/TriangleUtilities.js';\nimport { convertRaycastIntersect } from '../utils/GeometryRayIntersectUtilities.js';\nimport { GeometryBVH } from './GeometryBVH.js';\n\nconst _obb = /* @__PURE__ */ new OrientedBox();\nconst _ray = /* @__PURE__ */ new Ray();\nconst _direction = /* @__PURE__ */ new Vector3();\nconst _inverseMatrix = /* @__PURE__ */ new Matrix4();\nconst _worldScale = /* @__PURE__ */ new Vector3();\nconst _getters = [ 'getX', 'getY', 'getZ' ];\n\nexport class MeshBVH extends GeometryBVH {\n\n\tstatic serialize( bvh, options = {} ) {\n\n\t\toptions = {\n\t\t\tcloneBuffers: true,\n\t\t\t...options,\n\t\t};\n\n\t\tconst geometry = bvh.geometry;\n\t\tconst rootData = bvh._roots;\n\t\tconst indirectBuffer = bvh._indirectBuffer;\n\t\tconst indexAttribute = geometry.getIndex();\n\t\tconst result = {\n\t\t\tversion: 1,\n\t\t\troots: null,\n\t\t\tindex: null,\n\t\t\tindirectBuffer: null,\n\t\t};\n\t\tif ( options.cloneBuffers ) {\n\n\t\t\tresult.roots = rootData.map( root => root.slice() );\n\t\t\tresult.index = indexAttribute ? indexAttribute.array.slice() : null;\n\t\t\tresult.indirectBuffer = indirectBuffer ? indirectBuffer.slice() : null;\n\n\t\t} else {\n\n\t\t\tresult.roots = rootData;\n\t\t\tresult.index = indexAttribute ? indexAttribute.array : null;\n\t\t\tresult.indirectBuffer = indirectBuffer;\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tstatic deserialize( data, geometry, options = {} ) {\n\n\t\toptions = {\n\t\t\tsetIndex: true,\n\t\t\tindirect: Boolean( data.indirectBuffer ),\n\t\t\t...options,\n\t\t};\n\n\t\tconst { index, roots, indirectBuffer } = data;\n\n\t\t// handle backwards compatibility by fixing up the buffer roots\n\t\t// see issue gkjohnson/three-mesh-bvh#759\n\t\tif ( ! data.version ) {\n\n\t\t\tconsole.warn(\n\t\t\t\t'MeshBVH.deserialize: Serialization format has been changed and will be fixed up. ' +\n\t\t\t\t'It is recommended to regenerate any stored serialized data.'\n\t\t\t);\n\t\t\tfixupVersion0( roots );\n\n\t\t}\n\n\t\tconst bvh = new MeshBVH( geometry, { ...options, [ SKIP_GENERATION ]: true } );\n\t\tbvh._roots = roots;\n\t\tbvh._indirectBuffer = indirectBuffer || null;\n\n\t\tif ( options.setIndex ) {\n\n\t\t\tconst indexAttribute = geometry.getIndex();\n\t\t\tif ( indexAttribute === null ) {\n\n\t\t\t\tconst newIndex = new BufferAttribute( data.index, 1, false );\n\t\t\t\tgeometry.setIndex( newIndex );\n\n\t\t\t} else if ( indexAttribute.array !== index ) {\n\n\t\t\t\tindexAttribute.array.set( index );\n\t\t\t\tindexAttribute.needsUpdate = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn bvh;\n\n\t\t// convert version 0 serialized data (uint32 indices) to version 1 (node indices)\n\t\tfunction fixupVersion0( roots ) {\n\n\t\t\tfor ( let rootIndex = 0; rootIndex < roots.length; rootIndex ++ ) {\n\n\t\t\t\tconst root = roots[ rootIndex ];\n\t\t\t\tconst uint32Array = new Uint32Array( root );\n\t\t\t\tconst uint16Array = new Uint16Array( root );\n\n\t\t\t\t// iterate over nodes and convert right child offsets\n\t\t\t\tfor ( let node = 0, l = root.byteLength / BYTES_PER_NODE; node < l; node ++ ) {\n\n\t\t\t\t\tconst node32Index = UINT32_PER_NODE * node;\n\t\t\t\t\tconst node16Index = 2 * node32Index;\n\t\t\t\t\tif ( ! IS_LEAF( node16Index, uint16Array ) ) {\n\n\t\t\t\t\t\t// convert absolute right child offset to relative offset\n\t\t\t\t\t\tuint32Array[ node32Index + 6 ] = uint32Array[ node32Index + 6 ] / UINT32_PER_NODE - node;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tget primitiveStride() {\n\n\t\treturn 3;\n\n\t}\n\n\tget resolveTriangleIndex() {\n\n\t\treturn this.resolvePrimitiveIndex;\n\n\t}\n\n\tconstructor( geometry, options = {} ) {\n\n\t\tif ( options.maxLeafTris ) {\n\n\t\t\tconsole.warn( 'MeshBVH: \"maxLeafTris\" option has been deprecated. Use maxLeafSize, instead.' );\n\t\t\toptions = {\n\t\t\t\t...options,\n\t\t\t\tmaxLeafSize: options.maxLeafTris,\n\t\t\t};\n\n\t\t}\n\n\t\tsuper( geometry, options );\n\n\t}\n\n\t// implement abstract methods from BVH base class\n\tshiftTriangleOffsets( offset ) {\n\n\t\treturn super.shiftPrimitiveOffsets( offset );\n\n\t}\n\n\t// write primitive bounds to the buffer - used only for validateBounds at the moment\n\twritePrimitiveBounds( i, targetBuffer, baseIndex ) {\n\n\t\tconst geometry = this.geometry;\n\t\tconst indirectBuffer = this._indirectBuffer;\n\t\tconst posAttr = geometry.attributes.position;\n\t\tconst index = geometry.index ? geometry.index.array : null;\n\n\t\tconst tri = indirectBuffer ? indirectBuffer[ i ] : i;\n\t\tconst tri3 = tri * 3;\n\n\t\tlet ai = tri3 + 0;\n\t\tlet bi = tri3 + 1;\n\t\tlet ci = tri3 + 2;\n\n\t\tif ( index ) {\n\n\t\t\tai = index[ ai ];\n\t\t\tbi = index[ bi ];\n\t\t\tci = index[ ci ];\n\n\t\t}\n\n\t\tfor ( let el = 0; el < 3; el ++ ) {\n\n\t\t\tconst a = posAttr[ _getters[ el ] ]( ai );\n\t\t\tconst b = posAttr[ _getters[ el ] ]( bi );\n\t\t\tconst c = posAttr[ _getters[ el ] ]( ci );\n\n\t\t\tlet min = a;\n\t\t\tif ( b < min ) min = b;\n\t\t\tif ( c < min ) min = c;\n\n\t\t\tlet max = a;\n\t\t\tif ( b > max ) max = b;\n\t\t\tif ( c > max ) max = c;\n\n\t\t\t// Write in min/max format [minx, miny, minz, maxx, maxy, maxz]\n\t\t\ttargetBuffer[ baseIndex + el ] = min;\n\t\t\ttargetBuffer[ baseIndex + el + 3 ] = max;\n\n\t\t}\n\n\t\treturn targetBuffer;\n\n\t}\n\n\t// precomputes the bounding box for each triangle; required for quickly calculating tree splits.\n\t// result is an array of size count * 6 where triangle i maps to a\n\t// [x_center, x_delta, y_center, y_delta, z_center, z_delta] tuple starting at index (i - offset) * 6,\n\t// representing the center and half-extent in each dimension of triangle i\n\tcomputePrimitiveBounds( offset, count, targetBuffer ) {\n\n\t\tconst geometry = this.geometry;\n\t\tconst indirectBuffer = this._indirectBuffer;\n\t\tconst posAttr = geometry.attributes.position;\n\t\tconst index = geometry.index ? geometry.index.array : null;\n\t\tconst normalized = posAttr.normalized;\n\n\t\tif ( offset < 0 || count + offset - targetBuffer.offset > targetBuffer.length / 6 ) {\n\n\t\t\tthrow new Error( 'MeshBVH: compute triangle bounds range is invalid.' );\n\n\t\t}\n\n\t\t// used for non-normalized positions\n\t\tconst posArr = posAttr.array;\n\n\t\t// support for an interleaved position buffer\n\t\tconst bufferOffset = posAttr.offset || 0;\n\t\tlet stride = 3;\n\t\tif ( posAttr.isInterleavedBufferAttribute ) {\n\n\t\t\tstride = posAttr.data.stride;\n\n\t\t}\n\n\t\t// used for normalized positions\n\t\tconst getters = [ 'getX', 'getY', 'getZ' ];\n\t\tconst writeOffset = targetBuffer.offset;\n\n\t\t// iterate over the triangle range\n\t\tfor ( let i = offset, l = offset + count; i < l; i ++ ) {\n\n\t\t\tconst tri = indirectBuffer ? indirectBuffer[ i ] : i;\n\t\t\tconst tri3 = tri * 3;\n\t\t\tconst boundsIndexOffset = ( i - writeOffset ) * 6;\n\n\t\t\tlet ai = tri3 + 0;\n\t\t\tlet bi = tri3 + 1;\n\t\t\tlet ci = tri3 + 2;\n\n\t\t\tif ( index ) {\n\n\t\t\t\tai = index[ ai ];\n\t\t\t\tbi = index[ bi ];\n\t\t\t\tci = index[ ci ];\n\n\t\t\t}\n\n\t\t\t// we add the stride and offset here since we access the array directly\n\t\t\t// below for the sake of performance\n\t\t\tif ( ! normalized ) {\n\n\t\t\t\tai = ai * stride + bufferOffset;\n\t\t\t\tbi = bi * stride + bufferOffset;\n\t\t\t\tci = ci * stride + bufferOffset;\n\n\t\t\t}\n\n\t\t\tfor ( let el = 0; el < 3; el ++ ) {\n\n\t\t\t\tlet a, b, c;\n\n\t\t\t\tif ( normalized ) {\n\n\t\t\t\t\ta = posAttr[ getters[ el ] ]( ai );\n\t\t\t\t\tb = posAttr[ getters[ el ] ]( bi );\n\t\t\t\t\tc = posAttr[ getters[ el ] ]( ci );\n\n\t\t\t\t} else {\n\n\t\t\t\t\ta = posArr[ ai + el ];\n\t\t\t\t\tb = posArr[ bi + el ];\n\t\t\t\t\tc = posArr[ ci + el ];\n\n\t\t\t\t}\n\n\t\t\t\tlet min = a;\n\t\t\t\tif ( b < min ) min = b;\n\t\t\t\tif ( c < min ) min = c;\n\n\t\t\t\tlet max = a;\n\t\t\t\tif ( b > max ) max = b;\n\t\t\t\tif ( c > max ) max = c;\n\n\t\t\t\t// Increase the bounds size by float32 epsilon to avoid precision errors when\n\t\t\t\t// converting to 32 bit float. Scale the epsilon by the size of the numbers being\n\t\t\t\t// worked with.\n\t\t\t\tconst halfExtents = ( max - min ) / 2;\n\t\t\t\tconst el2 = el * 2;\n\t\t\t\ttargetBuffer[ boundsIndexOffset + el2 + 0 ] = min + halfExtents;\n\t\t\t\ttargetBuffer[ boundsIndexOffset + el2 + 1 ] = halfExtents + ( Math.abs( min ) + halfExtents ) * FLOAT32_EPSILON;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn targetBuffer;\n\n\t}\n\n\traycastObject3D( object, raycaster, intersects = [] ) {\n\n\t\tconst { material } = object;\n\t\tif ( material === undefined ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t_inverseMatrix.copy( object.matrixWorld ).invert();\n\t\t_ray.copy( raycaster.ray ).applyMatrix4( _inverseMatrix );\n\n\t\t_worldScale.setFromMatrixScale( object.matrixWorld );\n\t\t_direction.copy( _ray.direction ).multiply( _worldScale );\n\n\t\tconst scaleFactor = _direction.length();\n\t\tconst near = raycaster.near / scaleFactor;\n\t\tconst far = raycaster.far / scaleFactor;\n\n\t\tif ( raycaster.firstHitOnly === true ) {\n\n\t\t\tlet hit = this.raycastFirst( _ray, material, near, far );\n\t\t\thit = convertRaycastIntersect( hit, object, raycaster );\n\t\t\tif ( hit ) {\n\n\t\t\t\tintersects.push( hit );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst hits = this.raycast( _ray, material, near, far );\n\t\t\tfor ( let i = 0, l = hits.length; i < l; i ++ ) {\n\n\t\t\t\tconst hit = convertRaycastIntersect( hits[ i ], object, raycaster );\n\t\t\t\tif ( hit ) {\n\n\t\t\t\t\tintersects.push( hit );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn intersects;\n\n\t}\n\n\trefit( nodeIndices = null ) {\n\n\t\tconst refitFunc = this.indirect ? refit_indirect : refit;\n\t\treturn refitFunc( this, nodeIndices );\n\n\t}\n\n\t/* Core Cast Functions */\n\traycast( ray, materialOrSide = FrontSide, near = 0, far = Infinity ) {\n\n\t\tconst roots = this._roots;\n\t\tconst intersects = [];\n\t\tconst raycastFunc = this.indirect ? raycast_indirect : raycast;\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\t\traycastFunc( this, i, materialOrSide, ray, intersects, near, far );\n\n\t\t}\n\n\t\treturn intersects;\n\n\t}\n\n\traycastFirst( ray, materialOrSide = FrontSide, near = 0, far = Infinity ) {\n\n\t\tconst roots = this._roots;\n\t\tlet closestResult = null;\n\n\t\tconst raycastFirstFunc = this.indirect ? raycastFirst_indirect : raycastFirst;\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\t\tconst result = raycastFirstFunc( this, i, materialOrSide, ray, near, far );\n\t\t\tif ( result != null && ( closestResult == null || result.distance < closestResult.distance ) ) {\n\n\t\t\t\tclosestResult = result;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn closestResult;\n\n\t}\n\n\tintersectsGeometry( otherGeometry, geomToMesh ) {\n\n\t\tlet result = false;\n\t\tconst roots = this._roots;\n\t\tconst intersectsGeometryFunc = this.indirect ? intersectsGeometry_indirect : intersectsGeometry;\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\t\tresult = intersectsGeometryFunc( this, i, otherGeometry, geomToMesh );\n\n\t\t\tif ( result ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tshapecast( callbacks ) {\n\n\t\tconst triangle = ExtendedTrianglePool.getPrimitive();\n\t\tconst result = super.shapecast(\n\t\t\t{\n\t\t\t\t...callbacks,\n\t\t\t\tintersectsPrimitive: callbacks.intersectsTriangle,\n\t\t\t\tscratchPrimitive: triangle,\n\n\t\t\t\t// TODO: is the performance significant enough for the added complexity here?\n\t\t\t\t// can we just use one function?\n\t\t\t\titerate: this.indirect ? iterateOverTriangles_indirect : iterateOverTriangles,\n\t\t\t}\n\t\t);\n\t\tExtendedTrianglePool.releasePrimitive( triangle );\n\n\t\treturn result;\n\n\t}\n\n\tbvhcast( otherBvh, matrixToLocal, callbacks ) {\n\n\t\tlet {\n\t\t\tintersectsRanges,\n\t\t\tintersectsTriangles,\n\t\t} = callbacks;\n\n\t\tconst triangle1 = ExtendedTrianglePool.getPrimitive();\n\t\tconst indexAttr1 = this.geometry.index;\n\t\tconst positionAttr1 = this.geometry.attributes.position;\n\t\tconst assignTriangle1 = this.indirect ?\n\t\t\ti1 => {\n\n\n\t\t\t\tconst ti = this.resolveTriangleIndex( i1 );\n\t\t\t\tsetTriangle( triangle1, ti * 3, indexAttr1, positionAttr1 );\n\n\t\t\t} :\n\t\t\ti1 => {\n\n\t\t\t\tsetTriangle( triangle1, i1 * 3, indexAttr1, positionAttr1 );\n\n\t\t\t};\n\n\t\tconst triangle2 = ExtendedTrianglePool.getPrimitive();\n\t\tconst indexAttr2 = otherBvh.geometry.index;\n\t\tconst positionAttr2 = otherBvh.geometry.attributes.position;\n\t\tconst assignTriangle2 = otherBvh.indirect ?\n\t\t\ti2 => {\n\n\t\t\t\tconst ti2 = otherBvh.resolveTriangleIndex( i2 );\n\t\t\t\tsetTriangle( triangle2, ti2 * 3, indexAttr2, positionAttr2 );\n\n\t\t\t} :\n\t\t\ti2 => {\n\n\t\t\t\tsetTriangle( triangle2, i2 * 3, indexAttr2, positionAttr2 );\n\n\t\t\t};\n\n\t\t// generate triangle callback if needed\n\t\tif ( intersectsTriangles ) {\n\n\t\t\tif ( ! ( otherBvh instanceof MeshBVH ) ) {\n\n\t\t\t\tthrow new Error( 'MeshBVH: \"intersectsTriangles\" callback can only be used with another MeshBVH.' );\n\n\t\t\t}\n\n\t\t\tconst iterateOverDoubleTriangles = ( offset1, count1, offset2, count2, depth1, nodeIndex1, depth2, nodeIndex2 ) => {\n\n\t\t\t\tfor ( let i2 = offset2, l2 = offset2 + count2; i2 < l2; i2 ++ ) {\n\n\t\t\t\t\tassignTriangle2( i2 );\n\n\t\t\t\t\ttriangle2.a.applyMatrix4( matrixToLocal );\n\t\t\t\t\ttriangle2.b.applyMatrix4( matrixToLocal );\n\t\t\t\t\ttriangle2.c.applyMatrix4( matrixToLocal );\n\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\tfor ( let i1 = offset1, l1 = offset1 + count1; i1 < l1; i1 ++ ) {\n\n\t\t\t\t\t\tassignTriangle1( i1 );\n\n\t\t\t\t\t\ttriangle1.needsUpdate = true;\n\n\t\t\t\t\t\tif ( intersectsTriangles( triangle1, triangle2, i1, i2, depth1, nodeIndex1, depth2, nodeIndex2 ) ) {\n\n\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\n\t\t\t};\n\n\t\t\tif ( intersectsRanges ) {\n\n\t\t\t\tconst originalIntersectsRanges = intersectsRanges;\n\t\t\t\tintersectsRanges = function ( offset1, count1, offset2, count2, depth1, nodeIndex1, depth2, nodeIndex2 ) {\n\n\t\t\t\t\tif ( ! originalIntersectsRanges( offset1, count1, offset2, count2, depth1, nodeIndex1, depth2, nodeIndex2 ) ) {\n\n\t\t\t\t\t\treturn iterateOverDoubleTriangles( offset1, count1, offset2, count2, depth1, nodeIndex1, depth2, nodeIndex2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t};\n\n\t\t\t} else {\n\n\t\t\t\tintersectsRanges = iterateOverDoubleTriangles;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn super.bvhcast( otherBvh, matrixToLocal, { intersectsRanges } );\n\n\t}\n\n\n\t/* Derived Cast Functions */\n\tintersectsBox( box, boxToMesh ) {\n\n\t\t_obb.set( box.min, box.max, boxToMesh );\n\t\t_obb.needsUpdate = true;\n\n\t\treturn this.shapecast(\n\t\t\t{\n\t\t\t\tintersectsBounds: box => _obb.intersectsBox( box ),\n\t\t\t\tintersectsTriangle: tri => _obb.intersectsTriangle( tri )\n\t\t\t}\n\t\t);\n\n\t}\n\n\tintersectsSphere( sphere ) {\n\n\t\treturn this.shapecast(\n\t\t\t{\n\t\t\t\tintersectsBounds: box => sphere.intersectsBox( box ),\n\t\t\t\tintersectsTriangle: tri => tri.intersectsSphere( sphere )\n\t\t\t}\n\t\t);\n\n\t}\n\n\tclosestPointToGeometry( otherGeometry, geometryToBvh, target1 = { }, target2 = { }, minThreshold = 0, maxThreshold = Infinity ) {\n\n\t\tconst closestPointToGeometryFunc = this.indirect ? closestPointToGeometry_indirect : closestPointToGeometry;\n\t\treturn closestPointToGeometryFunc(\n\t\t\tthis,\n\t\t\totherGeometry,\n\t\t\tgeometryToBvh,\n\t\t\ttarget1,\n\t\t\ttarget2,\n\t\t\tminThreshold,\n\t\t\tmaxThreshold,\n\t\t);\n\n\t}\n\n\tclosestPointToPoint( point, target = { }, minThreshold = 0, maxThreshold = Infinity ) {\n\n\t\treturn closestPointToPoint(\n\t\t\tthis,\n\t\t\tpoint,\n\t\t\ttarget,\n\t\t\tminThreshold,\n\t\t\tmaxThreshold,\n\t\t);\n\n\t}\n\n}\n","const HASH_WIDTH = 1e-6;\nconst HASH_HALF_WIDTH = HASH_WIDTH * 0.5;\nconst HASH_MULTIPLIER = Math.pow( 10, - Math.log10( HASH_WIDTH ) );\nconst HASH_ADDITION = HASH_HALF_WIDTH * HASH_MULTIPLIER;\nexport function hashNumber( v ) {\n\n\treturn ~ ~ ( v * HASH_MULTIPLIER + HASH_ADDITION );\n\n}\n\nexport function hashVertex2( v ) {\n\n\treturn `${ hashNumber( v.x ) },${ hashNumber( v.y ) }`;\n\n}\n\nexport function hashVertex3( v ) {\n\n\treturn `${ hashNumber( v.x ) },${ hashNumber( v.y ) },${ hashNumber( v.z ) }`;\n\n}\n\nexport function hashVertex4( v ) {\n\n\treturn `${ hashNumber( v.x ) },${ hashNumber( v.y ) },${ hashNumber( v.z ) },${ hashNumber( v.w ) }`;\n\n}\n\nexport function hashRay( r ) {\n\n\treturn `${ hashVertex3( r.origin ) }-${ hashVertex3( r.direction ) }`;\n\n}\n\nexport function toNormalizedRay( v0, v1, target ) {\n\n\t// get a normalized direction\n\ttarget\n\t\t.direction\n\t\t.subVectors( v1, v0 )\n\t\t.normalize();\n\n\t// project the origin onto the perpendicular plane that\n\t// passes through 0, 0, 0\n\tconst scalar = v0.dot( target.direction );\n\ttarget.\n\t\torigin\n\t\t.copy( v0 )\n\t\t.addScaledVector( target.direction, - scalar );\n\n\treturn target;\n\n}\n","import { BufferAttribute } from 'three';\n\nexport function areSharedArrayBuffersSupported() {\n\n\treturn typeof SharedArrayBuffer !== 'undefined';\n\n}\n\nexport function convertToSharedArrayBuffer( array ) {\n\n\tif ( array.buffer instanceof SharedArrayBuffer ) {\n\n\t\treturn array;\n\n\t}\n\n\tconst cons = array.constructor;\n\tconst buffer = array.buffer;\n\tconst sharedBuffer = new SharedArrayBuffer( buffer.byteLength );\n\n\tconst uintArray = new Uint8Array( buffer );\n\tconst sharedUintArray = new Uint8Array( sharedBuffer );\n\tsharedUintArray.set( uintArray, 0 );\n\n\treturn new cons( sharedBuffer );\n\n}\n\nexport function getIndexArray( vertexCount, BufferConstructor = ArrayBuffer ) {\n\n\tif ( vertexCount > 65535 ) {\n\n\t\treturn new Uint32Array( new BufferConstructor( 4 * vertexCount ) );\n\n\t} else {\n\n\t\treturn new Uint16Array( new BufferConstructor( 2 * vertexCount ) );\n\n\t}\n\n}\n\nexport function ensureIndex( geo, options ) {\n\n\tif ( ! geo.index ) {\n\n\t\tconst vertexCount = geo.attributes.position.count;\n\t\tconst BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;\n\t\tconst index = getIndexArray( vertexCount, BufferConstructor );\n\t\tgeo.setIndex( new BufferAttribute( index, 1 ) );\n\n\t\tfor ( let i = 0; i < vertexCount; i ++ ) {\n\n\t\t\tindex[ i ] = i;\n\n\t\t}\n\n\t}\n\n}\n\nexport function getVertexCount( geo ) {\n\n\treturn geo.index ? geo.index.count : geo.attributes.position.count;\n\n}\n\nexport function getTriCount( geo ) {\n\n\treturn getVertexCount( geo ) / 3;\n\n}\n","import { Vector3 } from 'three';\n\nconst DEGENERATE_EPSILON = 1e-8;\nconst _tempVec = new Vector3();\n\nexport function toTriIndex( v ) {\n\n\treturn ~ ~ ( v / 3 );\n\n}\n\nexport function toEdgeIndex( v ) {\n\n\treturn v % 3;\n\n}\n\nexport function sortEdgeFunc( a, b ) {\n\n\treturn a.start - b.start;\n\n}\n\nexport function getProjectedDistance( ray, vec ) {\n\n\treturn _tempVec.subVectors( vec, ray.origin ).dot( ray.direction );\n\n}\n\nexport function hasOverlaps( arr ) {\n\n\tarr = [ ...arr ].sort( sortEdgeFunc );\n\tfor ( let i = 0, l = arr.length; i < l - 1; i ++ ) {\n\n\t\tconst info0 = arr[ i ];\n\t\tconst info1 = arr[ i + 1 ];\n\n\t\tif ( info1.start < info0.end && Math.abs( info1.start - info0.end ) > 1e-5 ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t}\n\n\treturn false;\n\n}\n\nexport function getEdgeSetLength( arr ) {\n\n\tlet tot = 0;\n\tarr.forEach( ( { start, end } ) => tot += end - start );\n\treturn tot;\n\n}\n\nexport function matchEdges( forward, reverse, disjointConnectivityMap, eps = DEGENERATE_EPSILON ) {\n\n\tforward.sort( sortEdgeFunc );\n\treverse.sort( sortEdgeFunc );\n\n\tfor ( let i = 0; i < forward.length; i ++ ) {\n\n\t\tconst e0 = forward[ i ];\n\t\tfor ( let o = 0; o < reverse.length; o ++ ) {\n\n\t\t\tconst e1 = reverse[ o ];\n\t\t\tif ( e1.start > e0.end ) {\n\n\t\t\t\t// e2 is completely after e1\n\t\t\t\t// break;\n\n\t\t\t\t// NOTE: there are cases where there are overlaps due to precision issues or\n\t\t\t\t// thin / degenerate triangles. Assuming the sibling side has the same issues\n\t\t\t\t// we let the matching work here. Long term we should remove the degenerate\n\t\t\t\t// triangles before this.\n\n\t\t\t} else if ( e0.end < e1.start || e1.end < e0.start ) {\n\n\t\t\t\t// e1 is completely before e2\n\t\t\t\tcontinue;\n\n\t\t\t} else if ( e0.start <= e1.start && e0.end >= e1.end ) {\n\n\t\t\t\t// e1 is larger than and e2 is completely within e1\n\t\t\t\tif ( ! areDistancesDegenerate( e1.end, e0.end ) ) {\n\n\t\t\t\t\tforward.splice( i + 1, 0, {\n\t\t\t\t\t\tstart: e1.end,\n\t\t\t\t\t\tend: e0.end,\n\t\t\t\t\t\tindex: e0.index,\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t\te0.end = e1.start;\n\n\t\t\t\te1.start = 0;\n\t\t\t\te1.end = 0;\n\n\t\t\t} else if ( e0.start >= e1.start && e0.end <= e1.end ) {\n\n\t\t\t\t// e2 is larger than and e1 is completely within e2\n\t\t\t\tif ( ! areDistancesDegenerate( e0.end, e1.end ) ) {\n\n\t\t\t\t\treverse.splice( o + 1, 0, {\n\t\t\t\t\t\tstart: e0.end,\n\t\t\t\t\t\tend: e1.end,\n\t\t\t\t\t\tindex: e1.index,\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t\te1.end = e0.start;\n\n\t\t\t\te0.start = 0;\n\t\t\t\te0.end = 0;\n\n\t\t\t} else if ( e0.start <= e1.start && e0.end <= e1.end ) {\n\n\t\t\t\t// e1 overlaps e2 at the beginning\n\t\t\t\tconst tmp = e0.end;\n\t\t\t\te0.end = e1.start;\n\t\t\t\te1.start = tmp;\n\n\t\t\t} else if ( e0.start >= e1.start && e0.end >= e1.end ) {\n\n\t\t\t\t// e1 overlaps e2 at the end\n\t\t\t\tconst tmp = e1.end;\n\t\t\t\te1.end = e0.start;\n\t\t\t\te0.start = tmp;\n\n\t\t\t} else {\n\n\t\t\t\tthrow new Error();\n\n\t\t\t}\n\n\t\t\t// Add the connectivity information\n\t\t\tif ( ! disjointConnectivityMap.has( e0.index ) ) {\n\n\t\t\t\tdisjointConnectivityMap.set( e0.index, [] );\n\n\t\t\t}\n\n\t\t\tif ( ! disjointConnectivityMap.has( e1.index ) ) {\n\n\t\t\t\tdisjointConnectivityMap.set( e1.index, [] );\n\n\t\t\t}\n\n\t\t\tdisjointConnectivityMap\n\t\t\t\t.get( e0.index )\n\t\t\t\t.push( e1.index );\n\n\t\t\tdisjointConnectivityMap\n\t\t\t\t.get( e1.index )\n\t\t\t\t.push( e0.index );\n\n\t\t\tif ( isEdgeDegenerate( e1 ) ) {\n\n\t\t\t\treverse.splice( o, 1 );\n\t\t\t\to --;\n\n\t\t\t}\n\n\t\t\tif ( isEdgeDegenerate( e0 ) ) {\n\n\t\t\t\t// and if we have to remove the current original edge then exit this loop\n\t\t\t\t// so we can work on the next one\n\t\t\t\tforward.splice( i, 1 );\n\t\t\t\ti --;\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tcleanUpEdgeSet( forward );\n\tcleanUpEdgeSet( reverse );\n\n\tfunction cleanUpEdgeSet( arr ) {\n\n\t\tfor ( let i = 0; i < arr.length; i ++ ) {\n\n\t\t\tif ( isEdgeDegenerate( arr[ i ] ) ) {\n\n\t\t\t\tarr.splice( i, 1 );\n\t\t\t\ti --;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction areDistancesDegenerate( start, end ) {\n\n\t\treturn Math.abs( end - start ) < eps;\n\n\t}\n\n\tfunction isEdgeDegenerate( e ) {\n\n\t\treturn Math.abs( e.end - e.start ) < eps;\n\n\t}\n\n}\n","const DIST_EPSILON = 1e-5;\nconst ANGLE_EPSILON = 1e-4;\n\nexport class RaySet {\n\n\tconstructor() {\n\n\t\tthis._rays = [];\n\n\t}\n\n\taddRay( ray ) {\n\n\t\tthis._rays.push( ray );\n\n\t}\n\n\tfindClosestRay( ray ) {\n\n\t\tconst rays = this._rays;\n\t\tconst inv = ray.clone();\n\t\tinv.direction.multiplyScalar( - 1 );\n\n\t\tlet bestScore = Infinity;\n\t\tlet bestRay = null;\n\t\tfor ( let i = 0, l = rays.length; i < l; i ++ ) {\n\n\t\t\tconst r = rays[ i ];\n\t\t\tif ( skipRay( r, ray ) && skipRay( r, inv ) ) {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tconst rayScore = scoreRays( r, ray );\n\t\t\tconst invScore = scoreRays( r, inv );\n\t\t\tconst score = Math.min( rayScore, invScore );\n\t\t\tif ( score < bestScore ) {\n\n\t\t\t\tbestScore = score;\n\t\t\t\tbestRay = r;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn bestRay;\n\n\t\tfunction skipRay( r0, r1 ) {\n\n\t\t\tconst distOutOfThreshold = r0.origin.distanceTo( r1.origin ) > DIST_EPSILON;\n\t\t\tconst angleOutOfThreshold = r0.direction.angleTo( r1.direction ) > ANGLE_EPSILON;\n\t\t\treturn angleOutOfThreshold || distOutOfThreshold;\n\n\t\t}\n\n\t\tfunction scoreRays( r0, r1 ) {\n\n\t\t\tconst originDistance = r0.origin.distanceTo( r1.origin );\n\t\t\tconst angleDistance = r0.direction.angleTo( r1.direction );\n\t\t\treturn originDistance / DIST_EPSILON + angleDistance / ANGLE_EPSILON;\n\n\t\t}\n\n\t}\n\n}\n","import { Vector3, Ray } from 'three';\nimport { toEdgeIndex, toTriIndex, matchEdges, getProjectedDistance } from './halfEdgeUtils.js';\nimport { toNormalizedRay } from './hashUtils.js';\nimport { RaySet } from './RaySet.js';\n\nconst _v0 = new Vector3();\nconst _v1 = new Vector3();\nconst _ray = new Ray();\n\nexport function computeDisjointEdges(\n\tgeometry,\n\tunmatchedSet,\n\teps,\n) {\n\n\tconst attributes = geometry.attributes;\n\tconst indexAttr = geometry.index;\n\tconst posAttr = attributes.position;\n\n\tconst disjointConnectivityMap = new Map();\n\tconst fragmentMap = new Map();\n\tconst edges = Array.from( unmatchedSet );\n\tconst rays = new RaySet();\n\n\tfor ( let i = 0, l = edges.length; i < l; i ++ ) {\n\n\t\t// get the triangle edge\n\t\tconst index = edges[ i ];\n\t\tconst triIndex = toTriIndex( index );\n\t\tconst edgeIndex = toEdgeIndex( index );\n\n\t\tlet i0 = 3 * triIndex + edgeIndex;\n\t\tlet i1 = 3 * triIndex + ( edgeIndex + 1 ) % 3;\n\t\tif ( indexAttr ) {\n\n\t\t\ti0 = indexAttr.getX( i0 );\n\t\t\ti1 = indexAttr.getX( i1 );\n\n\t\t}\n\n\t\t_v0.fromBufferAttribute( posAttr, i0 );\n\t\t_v1.fromBufferAttribute( posAttr, i1 );\n\n\t\t// get the ray corresponding to the edge\n\t\ttoNormalizedRay( _v0, _v1, _ray );\n\n\t\t// find the shared ray with other edges\n\t\tlet info;\n\t\tlet commonRay = rays.findClosestRay( _ray );\n\t\tif ( commonRay === null ) {\n\n\t\t\tcommonRay = _ray.clone();\n\t\t\trays.addRay( commonRay );\n\n\t\t}\n\n\t\tif ( ! fragmentMap.has( commonRay ) ) {\n\n\t\t\tfragmentMap.set( commonRay, {\n\n\t\t\t\tforward: [],\n\t\t\t\treverse: [],\n\t\t\t\tray: commonRay,\n\n\t\t\t} );\n\n\t\t}\n\n\t\tinfo = fragmentMap.get( commonRay );\n\n\t\t// store the stride of edge endpoints along the ray\n\t\tlet start = getProjectedDistance( commonRay, _v0 );\n\t\tlet end = getProjectedDistance( commonRay, _v1 );\n\t\tif ( start > end ) {\n\n\t\t\t[ start, end ] = [ end, start ];\n\n\t\t}\n\n\t\tif ( _ray.direction.dot( commonRay.direction ) < 0 ) {\n\n\t\t\tinfo.reverse.push( { start, end, index } );\n\n\t\t} else {\n\n\t\t\tinfo.forward.push( { start, end, index } );\n\n\t\t}\n\n\t}\n\n\t// match the found sibling edges\n\tfragmentMap.forEach( ( { forward, reverse }, ray ) => {\n\n\t\tmatchEdges( forward, reverse, disjointConnectivityMap, eps );\n\n\t\tif ( forward.length === 0 && reverse.length === 0 ) {\n\n\t\t\tfragmentMap.delete( ray );\n\n\t\t}\n\n\t} );\n\n\treturn {\n\t\tdisjointConnectivityMap,\n\t\tfragmentMap,\n\t};\n\n}\n\n","import { Vector2, Vector3, Vector4 } from 'three';\nimport { hashNumber, hashVertex2, hashVertex3, hashVertex4 } from './utils/hashUtils.js';\nimport { getTriCount } from './utils/geometryUtils.js';\nimport { computeDisjointEdges } from './utils/computeDisjointEdges.js';\n\nconst _vec2 = new Vector2();\nconst _vec3 = new Vector3();\nconst _vec4 = new Vector4();\nconst _hashes = [ '', '', '' ];\n\nexport class HalfEdgeMap {\n\n\tconstructor( geometry = null ) {\n\n\t\t// result data\n\t\tthis.data = null;\n\t\tthis.disjointConnections = null;\n\t\tthis.unmatchedDisjointEdges = null;\n\t\tthis.unmatchedEdges = - 1;\n\t\tthis.matchedEdges = - 1;\n\n\t\t// options\n\t\tthis.useDrawRange = true;\n\t\tthis.useAllAttributes = false;\n\t\tthis.matchDisjointEdges = false;\n\t\tthis.degenerateEpsilon = 1e-8;\n\n\t\tif ( geometry ) {\n\n\t\t\tthis.updateFrom( geometry );\n\n\t\t}\n\n\t}\n\n\tgetSiblingTriangleIndex( triIndex, edgeIndex ) {\n\n\t\tconst otherIndex = this.data[ triIndex * 3 + edgeIndex ];\n\t\treturn otherIndex === - 1 ? - 1 : ~ ~ ( otherIndex / 3 );\n\n\t}\n\n\tgetSiblingEdgeIndex( triIndex, edgeIndex ) {\n\n\t\tconst otherIndex = this.data[ triIndex * 3 + edgeIndex ];\n\t\treturn otherIndex === - 1 ? - 1 : ( otherIndex % 3 );\n\n\t}\n\n\tgetDisjointSiblingTriangleIndices( triIndex, edgeIndex ) {\n\n\t\tconst index = triIndex * 3 + edgeIndex;\n\t\tconst arr = this.disjointConnections.get( index );\n\t\treturn arr ? arr.map( i => ~ ~ ( i / 3 ) ) : [];\n\n\t}\n\n\tgetDisjointSiblingEdgeIndices( triIndex, edgeIndex ) {\n\n\t\tconst index = triIndex * 3 + edgeIndex;\n\t\tconst arr = this.disjointConnections.get( index );\n\t\treturn arr ? arr.map( i => i % 3 ) : [];\n\n\t}\n\n\tisFullyConnected() {\n\n\t\treturn this.unmatchedEdges === 0;\n\n\t}\n\n\tupdateFrom( geometry ) {\n\n\t\tconst { useAllAttributes, useDrawRange, matchDisjointEdges, degenerateEpsilon } = this;\n\t\tconst hashFunction = useAllAttributes ? hashAllAttributes : hashPositionAttribute;\n\n\t\t// runs on the assumption that there is a 1 : 1 match of edges\n\t\tconst map = new Map();\n\n\t\t// attributes\n\t\tconst { attributes } = geometry;\n\t\tconst attrKeys = useAllAttributes ? Object.keys( attributes ) : null;\n\t\tconst indexAttr = geometry.index;\n\t\tconst posAttr = attributes.position;\n\n\t\t// get the potential number of triangles\n\t\tlet triCount = getTriCount( geometry );\n\t\tconst maxTriCount = triCount;\n\n\t\t// get the real number of triangles from the based on the draw range\n\t\tlet offset = 0;\n\t\tif ( useDrawRange ) {\n\n\t\t\toffset = geometry.drawRange.start;\n\t\t\tif ( geometry.drawRange.count !== Infinity ) {\n\n\t\t\t\ttriCount = ~ ~ ( geometry.drawRange.count / 3 );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// initialize the connectivity buffer - 1 means no connectivity\n\t\tlet data = this.data;\n\t\tif ( ! data || data.length < 3 * maxTriCount ) {\n\n\t\t\tdata = new Int32Array( 3 * maxTriCount );\n\n\t\t}\n\n\t\tdata.fill( - 1 );\n\n\t\t// iterate over all triangles\n\t\tlet matchedEdges = 0;\n\t\tlet unmatchedSet = new Set();\n\t\tfor ( let i = offset, l = triCount * 3 + offset; i < l; i += 3 ) {\n\n\t\t\tconst i3 = i;\n\t\t\tfor ( let e = 0; e < 3; e ++ ) {\n\n\t\t\t\tlet i0 = i3 + e;\n\t\t\t\tif ( indexAttr ) {\n\n\t\t\t\t\ti0 = indexAttr.getX( i0 );\n\n\t\t\t\t}\n\n\t\t\t\t_hashes[ e ] = hashFunction( i0 );\n\n\t\t\t}\n\n\t\t\tfor ( let e = 0; e < 3; e ++ ) {\n\n\t\t\t\tconst nextE = ( e + 1 ) % 3;\n\t\t\t\tconst vh0 = _hashes[ e ];\n\t\t\t\tconst vh1 = _hashes[ nextE ];\n\n\t\t\t\tconst reverseHash = `${ vh1 }_${ vh0 }`;\n\t\t\t\tif ( map.has( reverseHash ) ) {\n\n\t\t\t\t\t// create a reference between the two triangles and clear the hash\n\t\t\t\t\tconst index = i3 + e;\n\t\t\t\t\tconst otherIndex = map.get( reverseHash );\n\t\t\t\t\tdata[ index ] = otherIndex;\n\t\t\t\t\tdata[ otherIndex ] = index;\n\t\t\t\t\tmap.delete( reverseHash );\n\t\t\t\t\tmatchedEdges += 2;\n\t\t\t\t\tunmatchedSet.delete( otherIndex );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// save the triangle and triangle edge index captured in one value\n\t\t\t\t\t// triIndex = ~ ~ ( i0 / 3 );\n\t\t\t\t\t// edgeIndex = i0 % 3;\n\t\t\t\t\tconst hash = `${ vh0 }_${ vh1 }`;\n\t\t\t\t\tconst index = i3 + e;\n\t\t\t\t\tmap.set( hash, index );\n\t\t\t\t\tunmatchedSet.add( index );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( matchDisjointEdges ) {\n\n\t\t\tconst {\n\t\t\t\tfragmentMap,\n\t\t\t\tdisjointConnectivityMap,\n\t\t\t} = computeDisjointEdges( geometry, unmatchedSet, degenerateEpsilon );\n\n\t\t\tunmatchedSet.clear();\n\t\t\tfragmentMap.forEach( ( { forward, reverse } ) => {\n\n\t\t\t\tforward.forEach( ( { index } ) => unmatchedSet.add( index ) );\n\t\t\t\treverse.forEach( ( { index } ) => unmatchedSet.add( index ) );\n\n\t\t\t} );\n\n\t\t\tthis.unmatchedDisjointEdges = fragmentMap;\n\t\t\tthis.disjointConnections = disjointConnectivityMap;\n\t\t\tmatchedEdges = triCount * 3 - unmatchedSet.size;\n\n\t\t}\n\n\t\tthis.matchedEdges = matchedEdges;\n\t\tthis.unmatchedEdges = unmatchedSet.size;\n\t\tthis.data = data;\n\n\t\tfunction hashPositionAttribute( i ) {\n\n\t\t\t_vec3.fromBufferAttribute( posAttr, i );\n\t\t\treturn hashVertex3( _vec3 );\n\n\t\t}\n\n\t\tfunction hashAllAttributes( i ) {\n\n\t\t\tlet result = '';\n\t\t\tfor ( let k = 0, l = attrKeys.length; k < l; k ++ ) {\n\n\t\t\t\tconst attr = attributes[ attrKeys[ k ] ];\n\t\t\t\tlet str;\n\t\t\t\tswitch ( attr.itemSize ) {\n\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tstr = hashNumber( attr.getX( i ) );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tstr = hashVertex2( _vec2.fromBufferAttribute( attr, i ) );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 3:\n\t\t\t\t\t\tstr = hashVertex3( _vec3.fromBufferAttribute( attr, i ) );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 4:\n\t\t\t\t\t\tstr = hashVertex4( _vec4.fromBufferAttribute( attr, i ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tif ( result !== '' ) {\n\n\t\t\t\t\tresult += '|';\n\n\t\t\t\t}\n\n\t\t\t\tresult += str;\n\n\t\t\t}\n\n\t\t\treturn result;\n\n\t\t}\n\n\t}\n\n}\n","import { Mesh, Matrix4 } from 'three';\nimport { MeshBVH } from 'three-mesh-bvh';\nimport { HalfEdgeMap } from './HalfEdgeMap.js';\nimport { areSharedArrayBuffersSupported, convertToSharedArrayBuffer, ensureIndex, getTriCount } from './utils/geometryUtils.js';\n\nexport class Brush extends Mesh {\n\n\tconstructor( ...args ) {\n\n\t\tsuper( ...args );\n\n\t\tthis.isBrush = true;\n\t\tthis._previousMatrix = new Matrix4();\n\t\tthis._previousMatrix.elements.fill( 0 );\n\n\t}\n\n\tmarkUpdated() {\n\n\t\tthis._previousMatrix.copy( this.matrix );\n\n\t}\n\n\tisDirty() {\n\n\t\tconst { matrix, _previousMatrix } = this;\n\t\tconst el1 = matrix.elements;\n\t\tconst el2 = _previousMatrix.elements;\n\t\tfor ( let i = 0; i < 16; i ++ ) {\n\n\t\t\tif ( el1[ i ] !== el2[ i ] ) {\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\tprepareGeometry() {\n\n\t\t// generate shared array buffers\n\t\tconst geometry = this.geometry;\n\t\tconst attributes = geometry.attributes;\n\t\tconst useSharedArrayBuffer = areSharedArrayBuffersSupported();\n\t\tif ( useSharedArrayBuffer ) {\n\n\t\t\tfor ( const key in attributes ) {\n\n\t\t\t\tconst attribute = attributes[ key ];\n\t\t\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\n\t\t\t\t\tthrow new Error( 'Brush: InterleavedBufferAttributes are not supported.' );\n\n\t\t\t\t}\n\n\t\t\t\tattribute.array = convertToSharedArrayBuffer( attribute.array );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// generate bounds tree\n\t\tif ( ! geometry.boundsTree ) {\n\n\t\t\tensureIndex( geometry, { useSharedArrayBuffer } );\n\t\t\tgeometry.boundsTree = new MeshBVH( geometry, { maxLeafTris: 3, indirect: true, useSharedArrayBuffer } );\n\n\t\t}\n\n\t\t// generate half edges\n\t\tif ( ! geometry.halfEdges ) {\n\n\t\t\tgeometry.halfEdges = new HalfEdgeMap( geometry );\n\n\t\t}\n\n\t\t// save group indices for materials\n\t\tif ( ! geometry.groupIndices ) {\n\n\t\t\tconst triCount = getTriCount( geometry );\n\t\t\tconst array = new Uint16Array( triCount );\n\t\t\tconst groups = geometry.groups;\n\t\t\tfor ( let i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\t\tconst { start, count } = groups[ i ];\n\t\t\t\tfor ( let g = start / 3, lg = ( start + count ) / 3; g < lg; g ++ ) {\n\n\t\t\t\t\tarray[ g ] = i;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tgeometry.groupIndices = array;\n\n\t\t}\n\n\t}\n\n\tdisposeCacheData() {\n\n\t\tconst { geometry } = this;\n\t\tgeometry.halfEdges = null;\n\t\tgeometry.boundsTree = null;\n\t\tgeometry.groupIndices = null;\n\n\t}\n\n}\n","import { Vector3 } from 'three';\n\nconst EPSILON = 1e-14;\nconst _AB = new Vector3();\nconst _AC = new Vector3();\nconst _CB = new Vector3();\n\nexport function isTriDegenerate( tri, eps = EPSILON ) {\n\n\t// compute angles to determine whether they're degenerate\n\t_AB.subVectors( tri.b, tri.a );\n\t_AC.subVectors( tri.c, tri.a );\n\t_CB.subVectors( tri.b, tri.c );\n\n\tconst angle1 = _AB.angleTo( _AC );\t\t\t\t// AB v AC\n\tconst angle2 = _AB.angleTo( _CB );\t\t\t\t// AB v BC\n\tconst angle3 = Math.PI - angle1 - angle2;\t\t// 180deg - angle1 - angle2\n\n\treturn Math.abs( angle1 ) < eps ||\n\t\tMath.abs( angle2 ) < eps ||\n\t\tMath.abs( angle3 ) < eps ||\n\t\ttri.a.distanceToSquared( tri.b ) < eps ||\n\t\ttri.a.distanceToSquared( tri.c ) < eps ||\n\t\ttri.b.distanceToSquared( tri.c ) < eps;\n\n}\n","import { Triangle, Line3, Vector3, Plane } from 'three';\nimport { ExtendedTriangle } from 'three-mesh-bvh';\nimport { isTriDegenerate } from './utils/triangleUtils.js';\n\n// NOTE: these epsilons likely should all be the same since they're used to measure the\n// distance from a point to a plane which needs to be done consistently\nconst EPSILON = 1e-10;\nconst COPLANAR_EPSILON = 1e-10;\nconst PARALLEL_EPSILON = 1e-10;\nconst _edge = new Line3();\nconst _foundEdge = new Line3();\nconst _vec = new Vector3();\nconst _triangleNormal = new Vector3();\nconst _planeNormal = new Vector3();\nconst _plane = new Plane();\nconst _splittingTriangle = new ExtendedTriangle();\n\n// A pool of triangles to avoid unnecessary triangle creation\nclass TrianglePool {\n\n\tconstructor() {\n\n\t\tthis._pool = [];\n\t\tthis._index = 0;\n\n\t}\n\n\tgetTriangle() {\n\n\t\tif ( this._index >= this._pool.length ) {\n\n\t\t\tthis._pool.push( new Triangle() );\n\n\t\t}\n\n\t\treturn this._pool[ this._index ++ ];\n\n\t}\n\n\tclear() {\n\n\t\tthis._index = 0;\n\n\t}\n\n\treset() {\n\n\t\tthis._pool.length = 0;\n\t\tthis._index = 0;\n\n\t}\n\n}\n\n// Utility class for splitting triangles\nexport class TriangleSplitter {\n\n\tconstructor() {\n\n\t\tthis.trianglePool = new TrianglePool();\n\t\tthis.triangles = [];\n\t\tthis.normal = new Vector3();\n\t\tthis.coplanarTriangleUsed = false;\n\n\t}\n\n\t// initialize the class with a triangle\n\tinitialize( tri ) {\n\n\t\tthis.reset();\n\n\t\tconst { triangles, trianglePool, normal } = this;\n\t\tif ( Array.isArray( tri ) ) {\n\n\t\t\tfor ( let i = 0, l = tri.length; i < l; i ++ ) {\n\n\t\t\t\tconst t = tri[ i ];\n\t\t\t\tif ( i === 0 ) {\n\n\t\t\t\t\tt.getNormal( normal );\n\n\t\t\t\t} else if ( Math.abs( 1.0 - t.getNormal( _vec ).dot( normal ) ) > EPSILON ) {\n\n\t\t\t\t\tthrow new Error( 'Triangle Splitter: Cannot initialize with triangles that have different normals.' );\n\n\t\t\t\t}\n\n\t\t\t\tconst poolTri = trianglePool.getTriangle();\n\t\t\t\tpoolTri.copy( t );\n\t\t\t\ttriangles.push( poolTri );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\ttri.getNormal( normal );\n\n\t\t\tconst poolTri = trianglePool.getTriangle();\n\t\t\tpoolTri.copy( tri );\n\t\t\ttriangles.push( poolTri );\n\n\t\t}\n\n\t}\n\n\t// Split the current set of triangles by passing a single triangle in. If the triangle is\n\t// coplanar it will attempt to split by the triangle edge planes\n\tsplitByTriangle( triangle ) {\n\n\t\tconst { normal, triangles } = this;\n\t\ttriangle.getNormal( _triangleNormal ).normalize();\n\n\t\tif ( Math.abs( 1.0 - Math.abs( _triangleNormal.dot( normal ) ) ) < PARALLEL_EPSILON ) {\n\n\t\t\tthis.coplanarTriangleUsed = true;\n\n\t\t\tfor ( let i = 0, l = triangles.length; i < l; i ++ ) {\n\n\t\t\t\tconst t = triangles[ i ];\n\t\t\t\tt.coplanarCount = 0;\n\n\t\t\t}\n\n\t\t\t// if the triangle is coplanar then split by the edge planes\n\t\t\tconst arr = [ triangle.a, triangle.b, triangle.c ];\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\tconst nexti = ( i + 1 ) % 3;\n\n\t\t\t\tconst v0 = arr[ i ];\n\t\t\t\tconst v1 = arr[ nexti ];\n\n\t\t\t\t// plane positive direction is toward triangle center\n\t\t\t\t_vec.subVectors( v1, v0 ).normalize();\n\t\t\t\t_planeNormal.crossVectors( _triangleNormal, _vec );\n\t\t\t\t_plane.setFromNormalAndCoplanarPoint( _planeNormal, v0 );\n\n\t\t\t\tthis.splitByPlane( _plane, triangle );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// otherwise split by the triangle plane\n\t\t\ttriangle.getPlane( _plane );\n\t\t\tthis.splitByPlane( _plane, triangle );\n\n\t\t}\n\n\t}\n\n\t// Split the triangles by the given plan. If a triangle is provided then we ensure we\n\t// intersect the triangle before splitting the plane\n\tsplitByPlane( plane, clippingTriangle ) {\n\n\t\tconst { triangles, trianglePool } = this;\n\n\t\t// init our triangle to check for intersection\n\t\t_splittingTriangle.copy( clippingTriangle );\n\t\t_splittingTriangle.needsUpdate = true;\n\n\t\t// try to split every triangle in the class\n\t\tfor ( let i = 0, l = triangles.length; i < l; i ++ ) {\n\n\t\t\tconst tri = triangles[ i ];\n\n\t\t\t// skip the triangle if we don't intersect with it\n\t\t\tif ( ! _splittingTriangle.intersectsTriangle( tri, _edge, true ) ) {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tconst { a, b, c } = tri;\n\t\t\tlet intersects = 0;\n\t\t\tlet vertexSplitEnd = - 1;\n\t\t\tlet coplanarEdge = false;\n\t\t\tlet posSideVerts = [];\n\t\t\tlet negSideVerts = [];\n\t\t\tconst arr = [ a, b, c ];\n\t\t\tfor ( let t = 0; t < 3; t ++ ) {\n\n\t\t\t\t// get the triangle edge\n\t\t\t\tconst tNext = ( t + 1 ) % 3;\n\t\t\t\t_edge.start.copy( arr[ t ] );\n\t\t\t\t_edge.end.copy( arr[ tNext ] );\n\n\t\t\t\t// track if the start point sits on the plane or if it's on the positive side of it\n\t\t\t\t// so we can use that information to determine whether to split later.\n\t\t\t\tconst startDist = plane.distanceToPoint( _edge.start );\n\t\t\t\tconst endDist = plane.distanceToPoint( _edge.end );\n\t\t\t\tif ( Math.abs( startDist ) < COPLANAR_EPSILON && Math.abs( endDist ) < COPLANAR_EPSILON ) {\n\n\t\t\t\t\tcoplanarEdge = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tif ( startDist > 0 ) {\n\n\t\t\t\t\tposSideVerts.push( t );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tnegSideVerts.push( t );\n\n\t\t\t\t}\n\n\t\t\t\t// we only don't consider this an intersection if the start points hits the plane\n\t\t\t\tif ( Math.abs( startDist ) < COPLANAR_EPSILON ) {\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\t// double check the end point since the \"intersectLine\" function sometimes does not\n\t\t\t\t// return it as an intersection (see issue #28)\n\t\t\t\t// Because we ignore the start point intersection above we have to make sure we check the end\n\t\t\t\t// point intersection here.\n\t\t\t\tlet didIntersect = ! ! plane.intersectLine( _edge, _vec );\n\t\t\t\tif ( ! didIntersect && Math.abs( endDist ) < COPLANAR_EPSILON ) {\n\n\t\t\t\t\t_vec.copy( _edge.end );\n\t\t\t\t\tdidIntersect = true;\n\n\t\t\t\t}\n\n\t\t\t\t// check if we intersect the plane (ignoring the start point so we don't double count)\n\t\t\t\tif ( didIntersect && ! ( _vec.distanceTo( _edge.start ) < EPSILON ) ) {\n\n\t\t\t\t\t// if we intersect at the end point then we track that point as one that we\n\t\t\t\t\t// have to split down the middle\n\t\t\t\t\tif ( _vec.distanceTo( _edge.end ) < EPSILON ) {\n\n\t\t\t\t\t\tvertexSplitEnd = t;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// track the split edge\n\t\t\t\t\tif ( intersects === 0 ) {\n\n\t\t\t\t\t\t_foundEdge.start.copy( _vec );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t_foundEdge.end.copy( _vec );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tintersects ++;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// skip splitting if:\n\t\t\t// - we have two points on the plane then the plane intersects the triangle exactly on an edge\n\t\t\t// - the plane does not intersect on 2 points\n\t\t\t// - the intersection edge is too small\n\t\t\t// - we're not along a coplanar edge\n\t\t\tif ( ! coplanarEdge && intersects === 2 && _foundEdge.distance() > COPLANAR_EPSILON ) {\n\n\t\t\t\tif ( vertexSplitEnd !== - 1 ) {\n\n\t\t\t\t\tvertexSplitEnd = ( vertexSplitEnd + 1 ) % 3;\n\n\t\t\t\t\t// we're splitting along a vertex\n\t\t\t\t\tlet otherVert1 = 0;\n\t\t\t\t\tif ( otherVert1 === vertexSplitEnd ) {\n\n\t\t\t\t\t\totherVert1 = ( otherVert1 + 1 ) % 3;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tlet otherVert2 = otherVert1 + 1;\n\t\t\t\t\tif ( otherVert2 === vertexSplitEnd ) {\n\n\t\t\t\t\t\totherVert2 = ( otherVert2 + 1 ) % 3;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst nextTri = trianglePool.getTriangle();\n\t\t\t\t\tnextTri.a.copy( arr[ otherVert2 ] );\n\t\t\t\t\tnextTri.b.copy( _foundEdge.end );\n\t\t\t\t\tnextTri.c.copy( _foundEdge.start );\n\n\t\t\t\t\tif ( ! isTriDegenerate( nextTri ) ) {\n\n\t\t\t\t\t\ttriangles.push( nextTri );\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttri.a.copy( arr[ otherVert1 ] );\n\t\t\t\t\ttri.b.copy( _foundEdge.start );\n\t\t\t\t\ttri.c.copy( _foundEdge.end );\n\n\t\t\t\t\t// finish off the adjusted triangle\n\t\t\t\t\tif ( isTriDegenerate( tri ) ) {\n\n\t\t\t\t\t\ttriangles.splice( i, 1 );\n\t\t\t\t\t\ti --;\n\t\t\t\t\t\tl --;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// we're splitting with a quad and a triangle\n\t\t\t\t\t// TODO: what happens when we find that about the pos and negative\n\t\t\t\t\t// sides have only a single vertex?\n\t\t\t\t\tconst singleVert =\n\t\t\t\t\t\tposSideVerts.length >= 2 ?\n\t\t\t\t\t\t\tnegSideVerts[ 0 ] :\n\t\t\t\t\t\t\tposSideVerts[ 0 ];\n\n\t\t\t\t\t// swap the direction of the intersection edge depending on which\n\t\t\t\t\t// side of the plane the single vertex is on to align with the\n\t\t\t\t\t// correct winding order.\n\t\t\t\t\tif ( singleVert === 0 ) {\n\n\t\t\t\t\t\tlet tmp = _foundEdge.start;\n\t\t\t\t\t\t_foundEdge.start = _foundEdge.end;\n\t\t\t\t\t\t_foundEdge.end = tmp;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst nextVert1 = ( singleVert + 1 ) % 3;\n\t\t\t\t\tconst nextVert2 = ( singleVert + 2 ) % 3;\n\n\t\t\t\t\tconst nextTri1 = trianglePool.getTriangle();\n\t\t\t\t\tconst nextTri2 = trianglePool.getTriangle();\n\n\t\t\t\t\t// choose the triangle that has the larger areas (shortest split distance)\n\t\t\t\t\tif ( arr[ nextVert1 ].distanceToSquared( _foundEdge.start ) < arr[ nextVert2 ].distanceToSquared( _foundEdge.end ) ) {\n\n\t\t\t\t\t\tnextTri1.a.copy( arr[ nextVert1 ] );\n\t\t\t\t\t\tnextTri1.b.copy( _foundEdge.start );\n\t\t\t\t\t\tnextTri1.c.copy( _foundEdge.end );\n\n\t\t\t\t\t\tnextTri2.a.copy( arr[ nextVert1 ] );\n\t\t\t\t\t\tnextTri2.b.copy( arr[ nextVert2 ] );\n\t\t\t\t\t\tnextTri2.c.copy( _foundEdge.start );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tnextTri1.a.copy( arr[ nextVert2 ] );\n\t\t\t\t\t\tnextTri1.b.copy( _foundEdge.start );\n\t\t\t\t\t\tnextTri1.c.copy( _foundEdge.end );\n\n\t\t\t\t\t\tnextTri2.a.copy( arr[ nextVert1 ] );\n\t\t\t\t\t\tnextTri2.b.copy( arr[ nextVert2 ] );\n\t\t\t\t\t\tnextTri2.c.copy( _foundEdge.end );\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttri.a.copy( arr[ singleVert ] );\n\t\t\t\t\ttri.b.copy( _foundEdge.end );\n\t\t\t\t\ttri.c.copy( _foundEdge.start );\n\n\t\t\t\t\t// don't add degenerate triangles to the list\n\t\t\t\t\tif ( ! isTriDegenerate( nextTri1 ) ) {\n\n\t\t\t\t\t\ttriangles.push( nextTri1 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ! isTriDegenerate( nextTri2 ) ) {\n\n\t\t\t\t\t\ttriangles.push( nextTri2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// finish off the adjusted triangle\n\t\t\t\t\tif ( isTriDegenerate( tri ) ) {\n\n\t\t\t\t\t\ttriangles.splice( i, 1 );\n\t\t\t\t\t\ti --;\n\t\t\t\t\t\tl --;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else if ( intersects === 3 ) {\n\n\t\t\t\tconsole.warn( 'TriangleClipper: Coplanar clip not handled' );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treset() {\n\n\t\tthis.triangles.length = 0;\n\t\tthis.trianglePool.clear();\n\t\tthis.coplanarTriangleUsed = false;\n\n\t}\n\n}\n","import { areSharedArrayBuffersSupported } from './utils/geometryUtils.js';\n\nfunction ceilToFourByteStride( byteLength ) {\n\n\tbyteLength = ~ ~ byteLength;\n\treturn byteLength + 4 - byteLength % 4;\n\n}\n\n// Make a new array wrapper class that more easily affords expansion when reaching it's max capacity\nexport class TypeBackedArray {\n\n\tconstructor( type, initialSize = 500 ) {\n\n\n\t\tthis.expansionFactor = 1.5;\n\t\tthis.type = type;\n\t\tthis.length = 0;\n\t\tthis.array = null;\n\n\t\tthis.setSize( initialSize );\n\n\t}\n\n\tsetType( type ) {\n\n\t\tif ( this.length !== 0 ) {\n\n\t\t\tthrow new Error( 'TypeBackedArray: Cannot change the type while there is used data in the buffer.' );\n\n\t\t}\n\n\t\tconst buffer = this.array.buffer;\n\t\tthis.array = new type( buffer );\n\t\tthis.type = type;\n\n\t}\n\n\tsetSize( size ) {\n\n\t\tif ( this.array && size === this.array.length ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// ceil to the nearest 4 bytes so we can replace the array with any type using the same buffer\n\t\tconst type = this.type;\n\t\tconst bufferType = areSharedArrayBuffersSupported() ? SharedArrayBuffer : ArrayBuffer;\n\t\tconst newArray = new type( new bufferType( ceilToFourByteStride( size * type.BYTES_PER_ELEMENT ) ) );\n\t\tif ( this.array ) {\n\n\t\t\tnewArray.set( this.array, 0 );\n\n\t\t}\n\n\t\tthis.array = newArray;\n\n\t}\n\n\texpand() {\n\n\t\tconst { array, expansionFactor } = this;\n\t\tthis.setSize( array.length * expansionFactor );\n\n\t}\n\n\tpush( ...args ) {\n\n\t\tlet { array, length } = this;\n\t\tif ( length + args.length > array.length ) {\n\n\t\t\tthis.expand();\n\t\t\tarray = this.array;\n\n\t\t}\n\n\t\tfor ( let i = 0, l = args.length; i < l; i ++ ) {\n\n\t\t\tarray[ length + i ] = args[ i ];\n\n\t\t}\n\n\t\tthis.length += args.length;\n\n\t}\n\n\tclear() {\n\n\t\tthis.length = 0;\n\n\t}\n\n}\n","import { TypeBackedArray } from './TypeBackedArray.js';\n\n// Utility class for for tracking attribute data in type-backed arrays for a set\n// of groups. The set of attributes is kept for each group and are expected to be the\n// same buffer type.\nexport class TypedAttributeData {\n\n\tconstructor() {\n\n\t\tthis.groupAttributes = [ {} ];\n\t\tthis.groupCount = 0;\n\n\t}\n\n\t// returns the buffer type for the given attribute\n\tgetType( name ) {\n\n\t\treturn this.groupAttributes[ 0 ][ name ].type;\n\n\t}\n\n\tgetItemSize( name ) {\n\n\t\treturn this.groupAttributes[ 0 ][ name ].itemSize;\n\n\t}\n\n\tgetNormalized( name ) {\n\n\t\treturn this.groupAttributes[ 0 ][ name ].normalized;\n\n\t}\n\n\tgetCount( index ) {\n\n\t\tif ( this.groupCount <= index ) {\n\n\t\t\treturn 0;\n\n\t\t}\n\n\t\tconst pos = this.getGroupAttrArray( 'position', index );\n\t\treturn pos.length / pos.itemSize;\n\n\t}\n\n\t// returns the total length required for all groups for the given attribute\n\tgetTotalLength( name ) {\n\n\t\tconst { groupCount, groupAttributes } = this;\n\n\t\tlet length = 0;\n\t\tfor ( let i = 0; i < groupCount; i ++ ) {\n\n\t\t\tconst attrSet = groupAttributes[ i ];\n\t\t\tlength += attrSet[ name ].length;\n\n\t\t}\n\n\t\treturn length;\n\n\t}\n\n\tgetGroupAttrSet( index = 0 ) {\n\n\t\t// TODO: can this be abstracted?\n\t\t// Return the exiting group set if necessary\n\t\tconst { groupAttributes } = this;\n\t\tif ( groupAttributes[ index ] ) {\n\n\t\t\tthis.groupCount = Math.max( this.groupCount, index + 1 );\n\t\t\treturn groupAttributes[ index ];\n\n\t\t}\n\n\t\t// add any new group sets required\n\t\tconst refAttrSet = groupAttributes[ 0 ];\n\t\tthis.groupCount = Math.max( this.groupCount, index + 1 );\n\t\twhile ( index >= groupAttributes.length ) {\n\n\t\t\tconst newAttrSet = {};\n\t\t\tgroupAttributes.push( newAttrSet );\n\t\t\tfor ( const key in refAttrSet ) {\n\n\t\t\t\tconst refAttr = refAttrSet[ key ];\n\t\t\t\tconst newAttr = new TypeBackedArray( refAttr.type );\n\t\t\t\tnewAttr.itemSize = refAttr.itemSize;\n\t\t\t\tnewAttr.normalized = refAttr.normalized;\n\t\t\t\tnewAttrSet[ key ] = newAttr;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn groupAttributes[ index ];\n\n\t}\n\n\t// Get the raw array for the group set of data\n\tgetGroupAttrArray( name, index = 0 ) {\n\n\t\t// throw an error if we've never\n\t\tconst { groupAttributes } = this;\n\t\tconst referenceAttrSet = groupAttributes[ 0 ];\n\t\tconst referenceAttr = referenceAttrSet[ name ];\n\t\tif ( ! referenceAttr ) {\n\n\t\t\tthrow new Error( `TypedAttributeData: Attribute with \"${ name }\" has not been initialized` );\n\n\t\t}\n\n\t\treturn this.getGroupAttrSet( index )[ name ];\n\n\t}\n\n\t// initializes an attribute array with the given name, type, and size\n\tinitializeArray( name, type, itemSize, normalized ) {\n\n\t\tconst { groupAttributes } = this;\n\t\tconst referenceAttrSet = groupAttributes[ 0 ];\n\t\tconst referenceAttr = referenceAttrSet[ name ];\n\t\tif ( referenceAttr ) {\n\n\t\t\tif ( referenceAttr.type !== type ) {\n\n\t\t\t\tfor ( let i = 0, l = groupAttributes.length; i < l; i ++ ) {\n\n\t\t\t\t\tconst arr = groupAttributes[ i ][ name ];\n\t\t\t\t\tarr.setType( type );\n\t\t\t\t\tarr.itemSize = itemSize;\n\t\t\t\t\tarr.normalized = normalized;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tfor ( let i = 0, l = groupAttributes.length; i < l; i ++ ) {\n\n\t\t\t\tconst arr = new TypeBackedArray( type );\n\t\t\t\tarr.itemSize = itemSize;\n\t\t\t\tarr.normalized = normalized;\n\t\t\t\tgroupAttributes[ i ][ name ] = arr;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// Clear all the data\n\tclear() {\n\n\t\tthis.groupCount = 0;\n\n\t\tconst { groupAttributes } = this;\n\t\tgroupAttributes.forEach( attrSet => {\n\n\t\t\tfor ( const key in attrSet ) {\n\n\t\t\t\tattrSet[ key ].clear();\n\n\t\t\t}\n\n\n\t\t} );\n\n\t}\n\n\t// Remove the given key\n\tdelete( key ) {\n\n\t\tthis.groupAttributes.forEach( attrSet => {\n\n\t\t\tdelete attrSet[ key ];\n\n\t\t} );\n\n\t}\n\n\t// Reset the datasets completely\n\treset() {\n\n\t\tthis.groupAttributes = [];\n\t\tthis.groupCount = 0;\n\n\t}\n\n}\n","export class IntersectionMap {\n\n\tconstructor() {\n\n\t\tthis.intersectionSet = {};\n\t\tthis.ids = [];\n\n\t}\n\n\tadd( id, intersectionId ) {\n\n\t\tconst { intersectionSet, ids } = this;\n\t\tif ( ! intersectionSet[ id ] ) {\n\n\t\t\tintersectionSet[ id ] = [];\n\t\t\tids.push( id );\n\n\t\t}\n\n\t\tintersectionSet[ id ].push( intersectionId );\n\n\t}\n\n}\n","export const ADDITION = 0;\nexport const SUBTRACTION = 1;\nexport const REVERSE_SUBTRACTION = 2;\nexport const INTERSECTION = 3;\nexport const DIFFERENCE = 4;\n\n// guaranteed non manifold results\nexport const HOLLOW_SUBTRACTION = 5;\nexport const HOLLOW_INTERSECTION = 6;\n","import { Ray, Matrix4, DoubleSide, Vector3, Vector4, Triangle, Line3 } from 'three';\nimport { IntersectionMap } from '../IntersectionMap.js';\nimport {\n\tADDITION,\n\tSUBTRACTION,\n\tREVERSE_SUBTRACTION,\n\tINTERSECTION,\n\tDIFFERENCE,\n\tHOLLOW_SUBTRACTION,\n\tHOLLOW_INTERSECTION,\n} from '../constants.js';\nimport { isTriDegenerate } from '../utils/triangleUtils.js';\n\nconst _ray = new Ray();\nconst _matrix = new Matrix4();\nconst _tri = new Triangle();\nconst _vec3 = new Vector3();\nconst _vec4a = new Vector4();\nconst _vec4b = new Vector4();\nconst _vec4c = new Vector4();\nconst _vec4_0 = new Vector4();\nconst _vec4_1 = new Vector4();\nconst _vec4_2 = new Vector4();\nconst _edge = new Line3();\nconst _normal = new Vector3();\nconst JITTER_EPSILON = 1e-8;\nconst OFFSET_EPSILON = 1e-15;\n\nexport const BACK_SIDE = - 1;\nexport const FRONT_SIDE = 1;\nexport const COPLANAR_OPPOSITE = - 2;\nexport const COPLANAR_ALIGNED = 2;\n\nexport const INVERT_TRI = 0;\nexport const ADD_TRI = 1;\nexport const SKIP_TRI = 2;\n\nconst FLOATING_COPLANAR_EPSILON = 1e-14;\n\nlet _debugContext = null;\nexport function setDebugContext( debugData ) {\n\n\t_debugContext = debugData;\n\n}\n\nexport function getHitSide( tri, bvh ) {\n\n\ttri.getMidpoint( _ray.origin );\n\ttri.getNormal( _ray.direction );\n\n\tconst hit = bvh.raycastFirst( _ray, DoubleSide );\n\tconst hitBackSide = Boolean( hit && _ray.direction.dot( hit.face.normal ) > 0 );\n\treturn hitBackSide ? BACK_SIDE : FRONT_SIDE;\n\n}\n\nexport function getHitSideWithCoplanarCheck( tri, bvh ) {\n\n\t// random function that returns [ - 0.5, 0.5 ];\n\tfunction rand() {\n\n\t\treturn Math.random() - 0.5;\n\n\t}\n\n\t// get the ray the check the triangle for\n\ttri.getNormal( _normal );\n\t_ray.direction.copy( _normal );\n\ttri.getMidpoint( _ray.origin );\n\n\tconst total = 3;\n\tlet count = 0;\n\tlet minDistance = Infinity;\n\tfor ( let i = 0; i < total; i ++ ) {\n\n\t\t// jitter the ray slightly\n\t\t_ray.direction.x += rand() * JITTER_EPSILON;\n\t\t_ray.direction.y += rand() * JITTER_EPSILON;\n\t\t_ray.direction.z += rand() * JITTER_EPSILON;\n\n\t\t// and invert it so we can account for floating point error by checking both directions\n\t\t// to catch coplanar distances\n\t\t_ray.direction.multiplyScalar( - 1 );\n\n\t\t// check if the ray hit the backside\n\t\tconst hit = bvh.raycastFirst( _ray, DoubleSide );\n\t\tlet hitBackSide = Boolean( hit && _ray.direction.dot( hit.face.normal ) > 0 );\n\t\tif ( hitBackSide ) {\n\n\t\t\tcount ++;\n\n\t\t}\n\n\t\tif ( hit !== null ) {\n\n\t\t\tminDistance = Math.min( minDistance, hit.distance );\n\n\t\t}\n\n\t\t// if we're right up against another face then we're coplanar\n\t\tif ( minDistance <= OFFSET_EPSILON ) {\n\n\t\t\treturn hit.face.normal.dot( _normal ) > 0 ? COPLANAR_ALIGNED : COPLANAR_OPPOSITE;\n\n\t\t}\n\n\t\t// if our current casts meet our requirements then early out\n\t\tif ( count / total > 0.5 || ( i - count + 1 ) / total > 0.5 ) {\n\n\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n\treturn count / total > 0.5 ? BACK_SIDE : FRONT_SIDE;\n\n}\n\n// returns the intersected triangles and returns objects mapping triangle indices to\n// the other triangles intersected\nexport function collectIntersectingTriangles( a, b ) {\n\n\tconst aIntersections = new IntersectionMap();\n\tconst bIntersections = new IntersectionMap();\n\n\t_matrix\n\t\t.copy( a.matrixWorld )\n\t\t.invert()\n\t\t.multiply( b.matrixWorld );\n\n\ta.geometry.boundsTree.bvhcast( b.geometry.boundsTree, _matrix, {\n\n\t\tintersectsTriangles( triangleA, triangleB, ia, ib ) {\n\n\t\t\tif ( ! isTriDegenerate( triangleA ) && ! isTriDegenerate( triangleB ) ) {\n\n\t\t\t\t// due to floating point error it's possible that we can have two overlapping, coplanar triangles\n\t\t\t\t// that are a _tiny_ fraction of a value away from each other. If we find that case then check the\n\t\t\t\t// distance between triangles and if it's small enough consider them intersecting.\n\t\t\t\tlet intersected = triangleA.intersectsTriangle( triangleB, _edge, true );\n\t\t\t\tif ( ! intersected ) {\n\n\t\t\t\t\tconst pa = triangleA.plane;\n\t\t\t\t\tconst pb = triangleB.plane;\n\t\t\t\t\tconst na = pa.normal;\n\t\t\t\t\tconst nb = pb.normal;\n\n\t\t\t\t\tif ( na.dot( nb ) === 1 && Math.abs( pa.constant - pb.constant ) < FLOATING_COPLANAR_EPSILON ) {\n\n\t\t\t\t\t\tintersected = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( intersected ) {\n\n\t\t\t\t\tlet va = a.geometry.boundsTree.resolveTriangleIndex( ia );\n\t\t\t\t\tlet vb = b.geometry.boundsTree.resolveTriangleIndex( ib );\n\t\t\t\t\taIntersections.add( va, vb );\n\t\t\t\t\tbIntersections.add( vb, va );\n\n\t\t\t\t\tif ( _debugContext ) {\n\n\t\t\t\t\t\t_debugContext.addEdge( _edge );\n\t\t\t\t\t\t_debugContext.addIntersectingTriangles( ia, triangleA, ib, triangleB );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn false;\n\n\t\t}\n\n\t} );\n\n\treturn { aIntersections, bIntersections };\n\n}\n\n// Add the barycentric interpolated values fro the triangle into the new attribute data\nexport function appendAttributeFromTriangle(\n\ttriIndex,\n\tbaryCoordTri,\n\tgeometry,\n\tmatrixWorld,\n\tnormalMatrix,\n\tattributeData,\n\tinvert = false,\n) {\n\n\tconst attributes = geometry.attributes;\n\tconst indexAttr = geometry.index;\n\tconst i3 = triIndex * 3;\n\tconst i0 = indexAttr.getX( i3 + 0 );\n\tconst i1 = indexAttr.getX( i3 + 1 );\n\tconst i2 = indexAttr.getX( i3 + 2 );\n\n\tfor ( const key in attributeData ) {\n\n\t\t// check if the key we're asking for is in the geometry at all\n\t\tconst attr = attributes[ key ];\n\t\tconst arr = attributeData[ key ];\n\t\tif ( ! ( key in attributes ) ) {\n\n\t\t\tthrow new Error( `CSG Operations: Attribute ${ key } not available on geometry.` );\n\n\t\t}\n\n\t\t// handle normals and positions specially because they require transforming\n\t\t// TODO: handle tangents\n\t\tconst itemSize = attr.itemSize;\n\t\tif ( key === 'position' ) {\n\n\t\t\t_tri.a.fromBufferAttribute( attr, i0 ).applyMatrix4( matrixWorld );\n\t\t\t_tri.b.fromBufferAttribute( attr, i1 ).applyMatrix4( matrixWorld );\n\t\t\t_tri.c.fromBufferAttribute( attr, i2 ).applyMatrix4( matrixWorld );\n\n\t\t\tpushBarycoordInterpolatedValues( _tri.a, _tri.b, _tri.c, baryCoordTri, 3, arr, invert );\n\n\t\t} else if ( key === 'normal' ) {\n\n\t\t\t_tri.a.fromBufferAttribute( attr, i0 ).applyNormalMatrix( normalMatrix );\n\t\t\t_tri.b.fromBufferAttribute( attr, i1 ).applyNormalMatrix( normalMatrix );\n\t\t\t_tri.c.fromBufferAttribute( attr, i2 ).applyNormalMatrix( normalMatrix );\n\n\t\t\tif ( invert ) {\n\n\t\t\t\t_tri.a.multiplyScalar( - 1 );\n\t\t\t\t_tri.b.multiplyScalar( - 1 );\n\t\t\t\t_tri.c.multiplyScalar( - 1 );\n\n\t\t\t}\n\n\t\t\tpushBarycoordInterpolatedValues( _tri.a, _tri.b, _tri.c, baryCoordTri, 3, arr, invert, true );\n\n\t\t} else {\n\n\t\t\t_vec4a.fromBufferAttribute( attr, i0 );\n\t\t\t_vec4b.fromBufferAttribute( attr, i1 );\n\t\t\t_vec4c.fromBufferAttribute( attr, i2 );\n\n\t\t\tpushBarycoordInterpolatedValues( _vec4a, _vec4b, _vec4c, baryCoordTri, itemSize, arr, invert );\n\n\t\t}\n\n\t}\n\n}\n\n// Append all the values of the attributes for the triangle onto the new attribute arrays\nexport function appendAttributesFromIndices(\n\ti0,\n\ti1,\n\ti2,\n\tattributes,\n\tmatrixWorld,\n\tnormalMatrix,\n\tattributeData,\n\tinvert = false,\n) {\n\n\tappendAttributeFromIndex( i0, attributes, matrixWorld, normalMatrix, attributeData, invert );\n\tappendAttributeFromIndex( invert ? i2 : i1, attributes, matrixWorld, normalMatrix, attributeData, invert );\n\tappendAttributeFromIndex( invert ? i1 : i2, attributes, matrixWorld, normalMatrix, attributeData, invert );\n\n}\n\n// Returns the triangle to add when performing an operation\nexport function getOperationAction( operation, hitSide, invert = false ) {\n\n\tswitch ( operation ) {\n\n\t\tcase ADDITION:\n\n\t\t\tif ( hitSide === FRONT_SIDE || ( hitSide === COPLANAR_ALIGNED && ! invert ) ) {\n\n\t\t\t\treturn ADD_TRI;\n\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase SUBTRACTION:\n\n\t\t\tif ( invert ) {\n\n\t\t\t\tif ( hitSide === BACK_SIDE ) {\n\n\t\t\t\t\treturn INVERT_TRI;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( hitSide === FRONT_SIDE || hitSide === COPLANAR_OPPOSITE ) {\n\n\t\t\t\t\treturn ADD_TRI;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase REVERSE_SUBTRACTION:\n\n\t\t\tif ( invert ) {\n\n\t\t\t\tif ( hitSide === FRONT_SIDE || hitSide === COPLANAR_OPPOSITE ) {\n\n\t\t\t\t\treturn ADD_TRI;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( hitSide === BACK_SIDE ) {\n\n\t\t\t\t\treturn INVERT_TRI;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase DIFFERENCE:\n\n\t\t\tif ( hitSide === BACK_SIDE ) {\n\n\t\t\t\treturn INVERT_TRI;\n\n\t\t\t} else if ( hitSide === FRONT_SIDE ) {\n\n\t\t\t\treturn ADD_TRI;\n\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase INTERSECTION:\n\t\t\tif ( hitSide === BACK_SIDE || ( hitSide === COPLANAR_ALIGNED && ! invert ) ) {\n\n\t\t\t\treturn ADD_TRI;\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase HOLLOW_SUBTRACTION:\n\t\t\tif ( ! invert && ( hitSide === FRONT_SIDE || hitSide === COPLANAR_OPPOSITE ) ) {\n\n\t\t\t\treturn ADD_TRI;\n\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase HOLLOW_INTERSECTION:\n\t\t\tif ( ! invert && ( hitSide === BACK_SIDE || hitSide === COPLANAR_ALIGNED ) ) {\n\n\t\t\t\treturn ADD_TRI;\n\n\t\t\t}\n\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthrow new Error( `Unrecognized CSG operation enum \"${ operation }\".` );\n\n\t}\n\n\treturn SKIP_TRI;\n\n}\n\n// takes a set of barycentric values in the form of a triangle, a set of vectors, number of components,\n// and whether to invert the result and pushes the new values onto the provided attribute array\nfunction pushBarycoordInterpolatedValues( v0, v1, v2, baryCoordTri, itemSize, attrArr, invert = false, normalize = false ) {\n\n\t// adds the appropriate number of values for the vector onto the array\n\tconst addValues = v => {\n\n\t\tattrArr.push( v.x );\n\t\tif ( itemSize > 1 ) attrArr.push( v.y );\n\t\tif ( itemSize > 2 ) attrArr.push( v.z );\n\t\tif ( itemSize > 3 ) attrArr.push( v.w );\n\n\t};\n\n\t// barycentric interpolate the first component\n\t_vec4_0.set( 0, 0, 0, 0 )\n\t\t.addScaledVector( v0, baryCoordTri.a.x )\n\t\t.addScaledVector( v1, baryCoordTri.a.y )\n\t\t.addScaledVector( v2, baryCoordTri.a.z );\n\n\t_vec4_1.set( 0, 0, 0, 0 )\n\t\t.addScaledVector( v0, baryCoordTri.b.x )\n\t\t.addScaledVector( v1, baryCoordTri.b.y )\n\t\t.addScaledVector( v2, baryCoordTri.b.z );\n\n\t_vec4_2.set( 0, 0, 0, 0 )\n\t\t.addScaledVector( v0, baryCoordTri.c.x )\n\t\t.addScaledVector( v1, baryCoordTri.c.y )\n\t\t.addScaledVector( v2, baryCoordTri.c.z );\n\n\tif ( normalize ) {\n\n\t\t_vec4_0.normalize();\n\t\t_vec4_1.normalize();\n\t\t_vec4_2.normalize();\n\n\t}\n\n\t// if the face is inverted then add the values in an inverted order\n\taddValues( _vec4_0 );\n\n\tif ( invert ) {\n\n\t\taddValues( _vec4_2 );\n\t\taddValues( _vec4_1 );\n\n\t} else {\n\n\t\taddValues( _vec4_1 );\n\t\taddValues( _vec4_2 );\n\n\t}\n\n}\n\n// Adds the values for the given vertex index onto the new attribute arrays\nfunction appendAttributeFromIndex(\n\tindex,\n\tattributes,\n\tmatrixWorld,\n\tnormalMatrix,\n\tattributeData,\n\tinvert = false,\n) {\n\n\tfor ( const key in attributeData ) {\n\n\t\t// check if the key we're asking for is in the geometry at all\n\t\tconst attr = attributes[ key ];\n\t\tconst arr = attributeData[ key ];\n\t\tif ( ! ( key in attributes ) ) {\n\n\t\t\tthrow new Error( `CSG Operations: Attribute ${ key } no available on geometry.` );\n\n\t\t}\n\n\t\t// specially handle the position and normal attributes because they require transforms\n\t\t// TODO: handle tangents\n\t\tconst itemSize = attr.itemSize;\n\t\tif ( key === 'position' ) {\n\n\t\t\t_vec3.fromBufferAttribute( attr, index ).applyMatrix4( matrixWorld );\n\t\t\tarr.push( _vec3.x, _vec3.y, _vec3.z );\n\n\t\t} else if ( key === 'normal' ) {\n\n\t\t\t_vec3.fromBufferAttribute( attr, index ).applyNormalMatrix( normalMatrix );\n\t\t\tif ( invert ) {\n\n\t\t\t\t_vec3.multiplyScalar( - 1 );\n\n\t\t\t}\n\n\t\t\tarr.push( _vec3.x, _vec3.y, _vec3.z );\n\n\t\t} else {\n\n\t\t\tarr.push( attr.getX( index ) );\n\t\t\tif ( itemSize > 1 ) arr.push( attr.getY( index ) );\n\t\t\tif ( itemSize > 2 ) arr.push( attr.getZ( index ) );\n\t\t\tif ( itemSize > 3 ) arr.push( attr.getW( index ) );\n\n\t\t}\n\n\t}\n\n}\n","import { Triangle } from 'three';\nimport { setDebugContext } from '../operations/operationsUtils.js';\n\nclass TriangleIntersectData {\n\n\tconstructor( tri ) {\n\n\t\tthis.triangle = new Triangle().copy( tri );\n\t\tthis.intersects = {};\n\n\t}\n\n\taddTriangle( index, tri ) {\n\n\t\tthis.intersects[ index ] = new Triangle().copy( tri );\n\n\t}\n\n\tgetIntersectArray() {\n\n\t\tconst array = [];\n\t\tconst { intersects } = this;\n\t\tfor ( const key in intersects ) {\n\n\t\t\tarray.push( intersects[ key ] );\n\n\t\t}\n\n\t\treturn array;\n\n\t}\n\n}\n\nclass TriangleIntersectionSets {\n\n\tconstructor() {\n\n\t\tthis.data = {};\n\n\t}\n\n\taddTriangleIntersection( ia, triA, ib, triB ) {\n\n\t\tconst { data } = this;\n\t\tif ( ! data[ ia ] ) {\n\n\t\t\tdata[ ia ] = new TriangleIntersectData( triA );\n\n\t\t}\n\n\t\tdata[ ia ].addTriangle( ib, triB );\n\n\t}\n\n\tgetTrianglesAsArray( id = null ) {\n\n\t\tconst { data } = this;\n\t\tconst arr = [];\n\n\t\tif ( id !== null ) {\n\n\t\t\tif ( id in data ) {\n\n\t\t\t\tarr.push( data[ id ].triangle );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tfor ( const key in data ) {\n\n\t\t\t\tarr.push( data[ key ].triangle );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn arr;\n\n\t}\n\n\tgetTriangleIndices() {\n\n\t\treturn Object.keys( this.data ).map( i => parseInt( i ) );\n\n\t}\n\n\tgetIntersectionIndices( id ) {\n\n\t\tconst { data } = this;\n\t\tif ( ! data[ id ] ) {\n\n\t\t\treturn [];\n\n\t\t} else {\n\n\t\t\treturn Object.keys( data[ id ].intersects ).map( i => parseInt( i ) );\n\n\n\t\t}\n\n\t}\n\n\tgetIntersectionsAsArray( id = null, id2 = null ) {\n\n\t\tconst { data } = this;\n\t\tconst triSet = new Set();\n\t\tconst arr = [];\n\n\t\tconst addTriangles = key => {\n\n\t\t\tif ( ! data[ key ] ) return;\n\n\t\t\tif ( id2 !== null ) {\n\n\t\t\t\tif ( data[ key ].intersects[ id2 ] ) {\n\n\t\t\t\t\tarr.push( data[ key ].intersects[ id2 ] );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tconst intersects = data[ key ].intersects;\n\t\t\t\tfor ( const key2 in intersects ) {\n\n\t\t\t\t\tif ( ! triSet.has( key2 ) ) {\n\n\t\t\t\t\t\ttriSet.add( key2 );\n\t\t\t\t\t\tarr.push( intersects[ key2 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t\tif ( id !== null ) {\n\n\t\t\taddTriangles( id );\n\n\t\t} else {\n\n\t\t\tfor ( const key in data ) {\n\n\t\t\t\taddTriangles( key );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn arr;\n\n\t}\n\n\treset() {\n\n\t\tthis.data = {};\n\n\t}\n\n}\n\nexport class OperationDebugData {\n\n\tconstructor() {\n\n\t\tthis.enabled = false;\n\t\tthis.triangleIntersectsA = new TriangleIntersectionSets();\n\t\tthis.triangleIntersectsB = new TriangleIntersectionSets();\n\t\tthis.intersectionEdges = [];\n\n\t}\n\n\taddIntersectingTriangles( ia, triA, ib, triB ) {\n\n\t\tconst { triangleIntersectsA, triangleIntersectsB } = this;\n\t\ttriangleIntersectsA.addTriangleIntersection( ia, triA, ib, triB );\n\t\ttriangleIntersectsB.addTriangleIntersection( ib, triB, ia, triA );\n\n\t}\n\n\taddEdge( edge ) {\n\n\t\tthis.intersectionEdges.push( edge.clone() );\n\n\t}\n\n\treset() {\n\n\t\tthis.triangleIntersectsA.reset();\n\t\tthis.triangleIntersectsB.reset();\n\t\tthis.intersectionEdges = [];\n\n\t}\n\n\tinit() {\n\n\t\tif ( this.enabled ) {\n\n\t\t\tthis.reset();\n\t\t\tsetDebugContext( this );\n\n\t\t}\n\n\t}\n\n\tcomplete() {\n\n\t\tif ( this.enabled ) {\n\n\t\t\tsetDebugContext( null );\n\n\t\t}\n\n\t}\n\n}\n","import { Matrix4, Matrix3, Triangle } from 'three';\nimport {\n\tgetHitSideWithCoplanarCheck,\n\tgetHitSide,\n\tcollectIntersectingTriangles,\n\tappendAttributeFromTriangle,\n\tappendAttributesFromIndices,\n\tgetOperationAction,\n\tSKIP_TRI, INVERT_TRI,\n} from './operationsUtils.js';\nimport { getTriCount } from '../utils/geometryUtils.js';\nimport { HOLLOW_INTERSECTION, HOLLOW_SUBTRACTION } from '../constants.js';\nimport { isTriDegenerate } from '../utils/triangleUtils.js';\n\nconst _matrix = new Matrix4();\nconst _normalMatrix = new Matrix3();\nconst _triA = new Triangle();\nconst _triB = new Triangle();\nconst _tri = new Triangle();\nconst _barycoordTri = new Triangle();\nconst _attr = [];\nconst _actions = [];\n\nfunction getFirstIdFromSet( set ) {\n\n\tfor ( const id of set ) return id;\n\n}\n\n// runs the given operation against a and b using the splitter and appending data to the\n// attributeData object.\nexport function performOperation(\n\ta,\n\tb,\n\toperations,\n\tsplitter,\n\tattributeData,\n\toptions = {},\n) {\n\n\tconst { useGroups = true } = options;\n\tconst { aIntersections, bIntersections } = collectIntersectingTriangles( a, b );\n\n\tconst resultGroups = [];\n\tlet resultMaterials = null;\n\n\tlet groupOffset;\n\tgroupOffset = useGroups ? 0 : - 1;\n\tperformSplitTriangleOperations( a, b, aIntersections, operations, false, splitter, attributeData, groupOffset );\n\tperformWholeTriangleOperations( a, b, aIntersections, operations, false, attributeData, groupOffset );\n\n\t// find whether the set of operations contains a non-hollow operations. If it does then we need\n\t// to perform the second set of triangle additions\n\tconst nonHollow = operations\n\t\t.findIndex( op => op !== HOLLOW_INTERSECTION && op !== HOLLOW_SUBTRACTION ) !== - 1;\n\n\tif ( nonHollow ) {\n\n\t\tgroupOffset = useGroups ? a.geometry.groups.length || 1 : - 1;\n\t\tperformSplitTriangleOperations( b, a, bIntersections, operations, true, splitter, attributeData, groupOffset );\n\t\tperformWholeTriangleOperations( b, a, bIntersections, operations, true, attributeData, groupOffset );\n\n\t}\n\n\t_attr.length = 0;\n\t_actions.length = 0;\n\n\treturn {\n\t\tgroups: resultGroups,\n\t\tmaterials: resultMaterials\n\t};\n\n}\n\n// perform triangle splitting and CSG operations on the set of split triangles\nfunction performSplitTriangleOperations(\n\ta,\n\tb,\n\tintersectionMap,\n\toperations,\n\tinvert,\n\tsplitter,\n\tattributeData,\n\tgroupOffset = 0,\n) {\n\n\tconst invertedGeometry = a.matrixWorld.determinant() < 0;\n\n\t// transforms into the local frame of matrix b\n\t_matrix\n\t\t.copy( b.matrixWorld )\n\t\t.invert()\n\t\t.multiply( a.matrixWorld );\n\n\t_normalMatrix\n\t\t.getNormalMatrix( a.matrixWorld )\n\t\t.multiplyScalar( invertedGeometry ? - 1 : 1 );\n\n\tconst groupIndices = a.geometry.groupIndices;\n\tconst aIndex = a.geometry.index;\n\tconst aPosition = a.geometry.attributes.position;\n\n\tconst bBVH = b.geometry.boundsTree;\n\tconst bIndex = b.geometry.index;\n\tconst bPosition = b.geometry.attributes.position;\n\tconst splitIds = intersectionMap.ids;\n\tconst intersectionSet = intersectionMap.intersectionSet;\n\n\t// iterate over all split triangle indices\n\tfor ( let i = 0, l = splitIds.length; i < l; i ++ ) {\n\n\t\tconst ia = splitIds[ i ];\n\t\tconst groupIndex = groupOffset === - 1 ? 0 : groupIndices[ ia ] + groupOffset;\n\n\t\t// get the triangle in the geometry B local frame\n\t\tconst ia3 = 3 * ia;\n\t\tconst ia0 = aIndex.getX( ia3 + 0 );\n\t\tconst ia1 = aIndex.getX( ia3 + 1 );\n\t\tconst ia2 = aIndex.getX( ia3 + 2 );\n\t\t_triA.a.fromBufferAttribute( aPosition, ia0 ).applyMatrix4( _matrix );\n\t\t_triA.b.fromBufferAttribute( aPosition, ia1 ).applyMatrix4( _matrix );\n\t\t_triA.c.fromBufferAttribute( aPosition, ia2 ).applyMatrix4( _matrix );\n\n\t\t// initialize the splitter with the triangle from geometry A\n\t\tsplitter.reset();\n\t\tsplitter.initialize( _triA );\n\n\t\t// split the triangle with the intersecting triangles from B\n\t\tconst intersectingIndices = intersectionSet[ ia ];\n\t\tfor ( let ib = 0, l = intersectingIndices.length; ib < l; ib ++ ) {\n\n\t\t\tconst ib3 = 3 * intersectingIndices[ ib ];\n\t\t\tconst ib0 = bIndex.getX( ib3 + 0 );\n\t\t\tconst ib1 = bIndex.getX( ib3 + 1 );\n\t\t\tconst ib2 = bIndex.getX( ib3 + 2 );\n\t\t\t_triB.a.fromBufferAttribute( bPosition, ib0 );\n\t\t\t_triB.b.fromBufferAttribute( bPosition, ib1 );\n\t\t\t_triB.c.fromBufferAttribute( bPosition, ib2 );\n\t\t\tsplitter.splitByTriangle( _triB );\n\n\t\t}\n\n\t\t// for all triangles in the split result\n\t\tconst triangles = splitter.triangles;\n\t\tfor ( let ib = 0, l = triangles.length; ib < l; ib ++ ) {\n\n\t\t\t// get the barycentric coordinates of the clipped triangle to add\n\t\t\tconst clippedTri = triangles[ ib ];\n\n\t\t\t// try to use the side derived from the clipping but if it turns out to be\n\t\t\t// uncertain then fall back to the raycasting approach\n\t\t\tconst hitSide = splitter.coplanarTriangleUsed ?\n\t\t\t\tgetHitSideWithCoplanarCheck( clippedTri, bBVH ) :\n\t\t\t\tgetHitSide( clippedTri, bBVH );\n\n\t\t\t_attr.length = 0;\n\t\t\t_actions.length = 0;\n\t\t\tfor ( let o = 0, lo = operations.length; o < lo; o ++ ) {\n\n\t\t\t\tconst op = getOperationAction( operations[ o ], hitSide, invert );\n\t\t\t\tif ( op !== SKIP_TRI ) {\n\n\t\t\t\t\t_actions.push( op );\n\t\t\t\t\t_attr.push( attributeData[ o ].getGroupAttrSet( groupIndex ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( _attr.length !== 0 ) {\n\n\t\t\t\t_triA.getBarycoord( clippedTri.a, _barycoordTri.a );\n\t\t\t\t_triA.getBarycoord( clippedTri.b, _barycoordTri.b );\n\t\t\t\t_triA.getBarycoord( clippedTri.c, _barycoordTri.c );\n\n\t\t\t\tfor ( let k = 0, lk = _attr.length; k < lk; k ++ ) {\n\n\t\t\t\t\tconst attrSet = _attr[ k ];\n\t\t\t\t\tconst action = _actions[ k ];\n\t\t\t\t\tconst invertTri = action === INVERT_TRI;\n\t\t\t\t\tappendAttributeFromTriangle( ia, _barycoordTri, a.geometry, a.matrixWorld, _normalMatrix, attrSet, invertedGeometry !== invertTri );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn splitIds.length;\n\n}\n\n// perform CSG operations on the set of whole triangles using a half edge structure\n// at the moment this isn't always faster due to overhead of building the half edge structure\n// and degraded connectivity due to split triangles.\n\nfunction performWholeTriangleOperations(\n\ta,\n\tb,\n\tsplitTriSet,\n\toperations,\n\tinvert,\n\tattributeData,\n\tgroupOffset = 0,\n) {\n\n\tconst invertedGeometry = a.matrixWorld.determinant() < 0;\n\n\t// matrix for transforming into the local frame of geometry b\n\t_matrix\n\t\t.copy( b.matrixWorld )\n\t\t.invert()\n\t\t.multiply( a.matrixWorld );\n\n\t_normalMatrix\n\t\t.getNormalMatrix( a.matrixWorld )\n\t\t.multiplyScalar( invertedGeometry ? - 1 : 1 );\n\n\tconst bBVH = b.geometry.boundsTree;\n\tconst groupIndices = a.geometry.groupIndices;\n\tconst aIndex = a.geometry.index;\n\tconst aAttributes = a.geometry.attributes;\n\tconst aPosition = aAttributes.position;\n\n\tconst stack = [];\n\tconst halfEdges = a.geometry.halfEdges;\n\tconst traverseSet = new Set();\n\tconst triCount = getTriCount( a.geometry );\n\tfor ( let i = 0, l = triCount; i < l; i ++ ) {\n\n\t\tif ( ! ( i in splitTriSet.intersectionSet ) ) {\n\n\t\t\ttraverseSet.add( i );\n\n\t\t}\n\n\t}\n\n\twhile ( traverseSet.size > 0 ) {\n\n\t\tconst id = getFirstIdFromSet( traverseSet );\n\t\ttraverseSet.delete( id );\n\n\t\tstack.push( id );\n\n\t\t// get the vertex indices\n\t\tconst i3 = 3 * id;\n\t\tconst i0 = aIndex.getX( i3 + 0 );\n\t\tconst i1 = aIndex.getX( i3 + 1 );\n\t\tconst i2 = aIndex.getX( i3 + 2 );\n\n\t\t// get the vertex position in the frame of geometry b so we can\n\t\t// perform hit testing\n\t\t_tri.a.fromBufferAttribute( aPosition, i0 ).applyMatrix4( _matrix );\n\t\t_tri.b.fromBufferAttribute( aPosition, i1 ).applyMatrix4( _matrix );\n\t\t_tri.c.fromBufferAttribute( aPosition, i2 ).applyMatrix4( _matrix );\n\n\t\t// get the side and decide if we need to cull the triangle based on the operation\n\t\tconst hitSide = getHitSide( _tri, bBVH );\n\n\t\t_actions.length = 0;\n\t\t_attr.length = 0;\n\t\tfor ( let o = 0, lo = operations.length; o < lo; o ++ ) {\n\n\t\t\tconst op = getOperationAction( operations[ o ], hitSide, invert );\n\t\t\tif ( op !== SKIP_TRI ) {\n\n\t\t\t\t_actions.push( op );\n\t\t\t\t_attr.push( attributeData[ o ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\twhile ( stack.length > 0 ) {\n\n\t\t\tconst currId = stack.pop();\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\tconst sid = halfEdges.getSiblingTriangleIndex( currId, i );\n\t\t\t\tif ( sid !== - 1 && traverseSet.has( sid ) ) {\n\n\t\t\t\t\tstack.push( sid );\n\t\t\t\t\ttraverseSet.delete( sid );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( _attr.length !== 0 ) {\n\n\t\t\t\tconst i3 = 3 * currId;\n\t\t\t\tconst i0 = aIndex.getX( i3 + 0 );\n\t\t\t\tconst i1 = aIndex.getX( i3 + 1 );\n\t\t\t\tconst i2 = aIndex.getX( i3 + 2 );\n\t\t\t\tconst groupIndex = groupOffset === - 1 ? 0 : groupIndices[ currId ] + groupOffset;\n\n\t\t\t\t_tri.a.fromBufferAttribute( aPosition, i0 );\n\t\t\t\t_tri.b.fromBufferAttribute( aPosition, i1 );\n\t\t\t\t_tri.c.fromBufferAttribute( aPosition, i2 );\n\t\t\t\tif ( ! isTriDegenerate( _tri ) ) {\n\n\t\t\t\t\tfor ( let k = 0, lk = _attr.length; k < lk; k ++ ) {\n\n\t\t\t\t\t\tconst action = _actions[ k ];\n\t\t\t\t\t\tconst attrSet = _attr[ k ].getGroupAttrSet( groupIndex );\n\t\t\t\t\t\tconst invertTri = action === INVERT_TRI;\n\t\t\t\t\t\tappendAttributesFromIndices( i0, i1, i2, aAttributes, a.matrixWorld, _normalMatrix, attrSet, invertTri !== invertedGeometry );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\n","import { BufferAttribute } from 'three';\nimport { TriangleSplitter } from './TriangleSplitter.js';\nimport { TypedAttributeData } from './TypedAttributeData.js';\nimport { OperationDebugData } from './debug/OperationDebugData.js';\nimport { performOperation } from './operations/operations.js';\nimport { Brush } from './Brush.js';\n\n// merges groups with common material indices in place\nfunction joinGroups( groups ) {\n\n\tfor ( let i = 0; i < groups.length - 1; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\t\tconst nextGroup = groups[ i + 1 ];\n\t\tif ( group.materialIndex === nextGroup.materialIndex ) {\n\n\t\t\tconst start = group.start;\n\t\t\tconst end = nextGroup.start + nextGroup.count;\n\t\t\tnextGroup.start = start;\n\t\t\tnextGroup.count = end - start;\n\n\t\t\tgroups.splice( i, 1 );\n\t\t\ti --;\n\n\t\t}\n\n\t}\n\n}\n\n// initialize the target geometry and attribute data to be based on\n// the given reference geometry\nfunction prepareAttributesData( referenceGeometry, targetGeometry, attributeData, relevantAttributes ) {\n\n\tattributeData.clear();\n\n\t// initialize and clear unused data from the attribute buffers and vice versa\n\tconst aAttributes = referenceGeometry.attributes;\n\tfor ( let i = 0, l = relevantAttributes.length; i < l; i ++ ) {\n\n\t\tconst key = relevantAttributes[ i ];\n\t\tconst aAttr = aAttributes[ key ];\n\t\tattributeData.initializeArray( key, aAttr.array.constructor, aAttr.itemSize, aAttr.normalized );\n\n\t}\n\n\tfor ( const key in attributeData.attributes ) {\n\n\t\tif ( ! relevantAttributes.includes( key ) ) {\n\n\t\t\tattributeData.delete( key );\n\n\t\t}\n\n\t}\n\n\tfor ( const key in targetGeometry.attributes ) {\n\n\t\tif ( ! relevantAttributes.includes( key ) ) {\n\n\t\t\ttargetGeometry.deleteAttribute( key );\n\t\t\ttargetGeometry.dispose();\n\n\t\t}\n\n\t}\n\n}\n\n// Assigns the given tracked attribute data to the geometry and returns whether the\n// geometry needs to be disposed of.\nfunction assignBufferData( geometry, attributeData, groupOrder ) {\n\n\tlet needsDisposal = false;\n\tlet drawRange = - 1;\n\n\t// set the data\n\tconst attributes = geometry.attributes;\n\tconst referenceAttrSet = attributeData.groupAttributes[ 0 ];\n\tfor ( const key in referenceAttrSet ) {\n\n\t\tconst requiredLength = attributeData.getTotalLength( key );\n\t\tconst type = attributeData.getType( key );\n\t\tconst itemSize = attributeData.getItemSize( key );\n\t\tconst normalized = attributeData.getNormalized( key );\n\t\tlet geoAttr = attributes[ key ];\n\t\tif ( ! geoAttr || geoAttr.array.length < requiredLength ) {\n\n\t\t\t// create the attribute if it doesn't exist yet\n\t\t\tgeoAttr = new BufferAttribute( new type( requiredLength ), itemSize, normalized );\n\t\t\tgeometry.setAttribute( key, geoAttr );\n\t\t\tneedsDisposal = true;\n\n\t\t}\n\n\t\t// assign the data to the geometry attribute buffers in the provided order\n\t\t// of the groups list\n\t\tlet offset = 0;\n\t\tfor ( let i = 0, l = Math.min( groupOrder.length, attributeData.groupCount ); i < l; i ++ ) {\n\n\t\t\tconst index = groupOrder[ i ].index;\n\t\t\tconst { array, type, length } = attributeData.groupAttributes[ index ][ key ];\n\t\t\tconst trimmedArray = new type( array.buffer, 0, length );\n\t\t\tgeoAttr.array.set( trimmedArray, offset );\n\t\t\toffset += trimmedArray.length;\n\n\t\t}\n\n\t\tgeoAttr.needsUpdate = true;\n\t\tdrawRange = requiredLength / geoAttr.itemSize;\n\n\t}\n\n\t// remove or update the index appropriately\n\tif ( geometry.index ) {\n\n\t\tconst indexArray = geometry.index.array;\n\t\tif ( indexArray.length < drawRange ) {\n\n\t\t\tgeometry.index = null;\n\t\t\tneedsDisposal = true;\n\n\t\t} else {\n\n\t\t\tfor ( let i = 0, l = indexArray.length; i < l; i ++ ) {\n\n\t\t\t\tindexArray[ i ] = i;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// initialize the groups\n\tlet groupOffset = 0;\n\tgeometry.clearGroups();\n\tfor ( let i = 0, l = Math.min( groupOrder.length, attributeData.groupCount ); i < l; i ++ ) {\n\n\t\tconst { index, materialIndex } = groupOrder[ i ];\n\t\tconst vertCount = attributeData.getCount( index );\n\t\tif ( vertCount !== 0 ) {\n\n\t\t\tgeometry.addGroup( groupOffset, vertCount, materialIndex );\n\t\t\tgroupOffset += vertCount;\n\n\t\t}\n\n\t}\n\n\t// update the draw range\n\tgeometry.setDrawRange( 0, drawRange );\n\n\t// remove the bounds tree if it exists because its now out of date\n\t// TODO: can we have this dispose in the same way that a brush does?\n\t// TODO: why are half edges and group indices not removed here?\n\tgeometry.boundsTree = null;\n\n\tif ( needsDisposal ) {\n\n\t\tgeometry.dispose();\n\n\t}\n\n}\n\n// Returns the list of materials used for the given set of groups\nfunction getMaterialList( groups, materials ) {\n\n\tlet result = materials;\n\tif ( ! Array.isArray( materials ) ) {\n\n\t\tresult = [];\n\t\tgroups.forEach( g => {\n\n\t\t\tresult[ g.materialIndex ] = materials;\n\n\t\t} );\n\n\t}\n\n\treturn result;\n\n}\n\n// Utility class for performing CSG operations\nexport class Evaluator {\n\n\tconstructor() {\n\n\t\tthis.triangleSplitter = new TriangleSplitter();\n\t\tthis.attributeData = [];\n\t\tthis.attributes = [ 'position', 'uv', 'normal' ];\n\t\tthis.useGroups = true;\n\t\tthis.consolidateGroups = true;\n\t\tthis.debug = new OperationDebugData();\n\n\t}\n\n\tgetGroupRanges( geometry ) {\n\n\t\treturn ! this.useGroups || geometry.groups.length === 0 ?\n\t\t\t[ { start: 0, count: Infinity, materialIndex: 0 } ] :\n\t\t\tgeometry.groups.map( group => ( { ...group } ) );\n\n\t}\n\n\tevaluate( a, b, operations, targetBrushes = new Brush() ) {\n\n\t\tlet wasArray = true;\n\t\tif ( ! Array.isArray( operations ) ) {\n\n\t\t\toperations = [ operations ];\n\n\t\t}\n\n\t\tif ( ! Array.isArray( targetBrushes ) ) {\n\n\t\t\ttargetBrushes = [ targetBrushes ];\n\t\t\twasArray = false;\n\n\t\t}\n\n\t\tif ( targetBrushes.length !== operations.length ) {\n\n\t\t\tthrow new Error( 'Evaluator: operations and target array passed as different sizes.' );\n\n\t\t}\n\n\t\ta.prepareGeometry();\n\t\tb.prepareGeometry();\n\n\t\tconst {\n\t\t\ttriangleSplitter,\n\t\t\tattributeData,\n\t\t\tattributes,\n\t\t\tuseGroups,\n\t\t\tconsolidateGroups,\n\t\t\tdebug,\n\t\t} = this;\n\n\t\t// expand the attribute data array to the necessary size\n\t\twhile ( attributeData.length < targetBrushes.length ) {\n\n\t\t\tattributeData.push( new TypedAttributeData() );\n\n\t\t}\n\n\t\t// prepare the attribute data buffer information\n\t\ttargetBrushes.forEach( ( brush, i ) => {\n\n\t\t\tprepareAttributesData( a.geometry, brush.geometry, attributeData[ i ], attributes );\n\n\t\t} );\n\n\t\t// run the operation to fill the list of attribute data\n\t\tdebug.init();\n\t\tperformOperation( a, b, operations, triangleSplitter, attributeData, { useGroups } );\n\t\tdebug.complete();\n\n\t\t// get the materials and group ranges\n\t\tconst aGroups = this.getGroupRanges( a.geometry );\n\t\tconst aMaterials = getMaterialList( aGroups, a.material );\n\n\t\tconst bGroups = this.getGroupRanges( b.geometry );\n\t\tconst bMaterials = getMaterialList( bGroups, b.material );\n\t\tbGroups.forEach( g => g.materialIndex += aMaterials.length );\n\n\t\tlet groups = [ ...aGroups, ...bGroups ]\n\t\t\t.map( ( group, index ) => ( { ...group, index } ) );\n\n\t\t// generate the minimum set of materials needed for the list of groups and adjust the groups\n\t\t// if they're needed\n\t\tif ( useGroups ) {\n\n\t\t\tconst allMaterials = [ ...aMaterials, ...bMaterials ];\n\t\t\tif ( consolidateGroups ) {\n\n\t\t\t\tgroups = groups\n\t\t\t\t\t.map( group => {\n\n\t\t\t\t\t\tconst mat = allMaterials[ group.materialIndex ];\n\t\t\t\t\t\tgroup.materialIndex = allMaterials.indexOf( mat );\n\t\t\t\t\t\treturn group;\n\n\t\t\t\t\t} )\n\t\t\t\t\t.sort( ( a, b ) => {\n\n\t\t\t\t\t\treturn a.materialIndex - b.materialIndex;\n\n\t\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\t// create a map from old to new index and remove materials that aren't used\n\t\t\tconst finalMaterials = [];\n\t\t\tfor ( let i = 0, l = allMaterials.length; i < l; i ++ ) {\n\n\t\t\t\tlet foundGroup = false;\n\t\t\t\tfor ( let g = 0, lg = groups.length; g < lg; g ++ ) {\n\n\t\t\t\t\tconst group = groups[ g ];\n\t\t\t\t\tif ( group.materialIndex === i ) {\n\n\t\t\t\t\t\tfoundGroup = true;\n\t\t\t\t\t\tgroup.materialIndex = finalMaterials.length;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( foundGroup ) {\n\n\t\t\t\t\tfinalMaterials.push( allMaterials[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\ttargetBrushes.forEach( tb => {\n\n\t\t\t\ttb.material = finalMaterials;\n\n\t\t\t} );\n\n\t\t} else {\n\n\t\t\tgroups = [ { start: 0, count: Infinity, index: 0, materialIndex: 0 } ];\n\t\t\ttargetBrushes.forEach( tb => {\n\n\t\t\t\ttb.material = aMaterials[ 0 ];\n\n\t\t\t} );\n\n\t\t}\n\n\t\t// apply groups and attribute data to the geometry\n\t\ttargetBrushes.forEach( ( brush, i ) => {\n\n\t\t\tconst targetGeometry = brush.geometry;\n\t\t\tassignBufferData( targetGeometry, attributeData[ i ], groups );\n\t\t\tif ( consolidateGroups ) {\n\n\t\t\t\tjoinGroups( targetGeometry.groups );\n\n\t\t\t}\n\n\t\t} );\n\n\t\treturn wasArray ? targetBrushes : targetBrushes[ 0 ];\n\n\t}\n\n\t// TODO: fix\n\tevaluateHierarchy( root, target = new Brush() ) {\n\n\t\troot.updateMatrixWorld( true );\n\n\t\tconst flatTraverse = ( obj, cb ) => {\n\n\t\t\tconst children = obj.children;\n\t\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = children[ i ];\n\t\t\t\tif ( child.isOperationGroup ) {\n\n\t\t\t\t\tflatTraverse( child, cb );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcb( child );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\n\t\tconst traverse = brush => {\n\n\t\t\tconst children = brush.children;\n\t\t\tlet didChange = false;\n\t\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = children[ i ];\n\t\t\t\tdidChange = traverse( child ) || didChange;\n\n\t\t\t}\n\n\t\t\tconst isDirty = brush.isDirty();\n\t\t\tif ( isDirty ) {\n\n\t\t\t\tbrush.markUpdated();\n\n\t\t\t}\n\n\t\t\tif ( didChange && ! brush.isOperationGroup ) {\n\n\t\t\t\tlet result;\n\t\t\t\tflatTraverse( brush, child => {\n\n\t\t\t\t\tif ( ! result ) {\n\n\t\t\t\t\t\tresult = this.evaluate( brush, child, child.operation );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tresult = this.evaluate( result, child, child.operation );\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\tbrush._cachedGeometry = result.geometry;\n\t\t\t\tbrush._cachedMaterials = result.material;\n\t\t\t\treturn true;\n\n\t\t\t} else {\n\n\t\t\t\treturn didChange || isDirty;\n\n\t\t\t}\n\n\t\t};\n\n\t\ttraverse( root );\n\n\t\ttarget.geometry = root._cachedGeometry;\n\t\ttarget.material = root._cachedMaterials;\n\n\t\treturn target;\n\n\t}\n\n\treset() {\n\n\t\tthis.triangleSplitter.reset();\n\n\t}\n\n}\n","import * as THREE from 'three';\nimport { SceneManager } from './core/Scene.js';\nimport { CameraManager } from './core/Camera.js';\nimport { RendererManager } from './core/Renderer.js';\nimport { RotationGizmo } from './gizmo/RotationGizmo.js';\nimport { InputHandler } from './core/InputHandler.js';\nimport { ModelLoader } from './utils/ModelLoader.js';\nimport { Brush, Evaluator, SUBTRACTION, INTERSECTION } from 'three-bvh-csg';\n\n/**\n * Main application class for 3D Rotation Gizmo\n * Supports dual viewport (preview + work view)\n */\nclass RotationGizmoApp {\n  constructor() {\n    // Initialize dual viewport renderer\n    this.renderer = new RendererManager();\n\n    // Create PREVIEW scene (top viewport - clean view)\n    this.previewSceneManager = new SceneManager();\n    \n    // Create WORK scene (bottom viewport - with gizmo and helpers)\n    this.workSceneManager = new SceneManager();\n\n    // Initialize model loader\n    this.modelLoader = new ModelLoader();\n    \n    // Objects will be created in async init()\n    this.testObject = null;\n    this.previewObject = null;\n    this.workSphere = null;\n    \n    // Y offset to position gizmo above buttons\n    this.gizmoYOffset = 2.2;\n\n    // Store initial states for reset functionality\n    this.initialRotation = null;\n\n    // Create camera for PREVIEW viewport (left side - 3D perspective)\n    this.previewCameraManager = this.createPreviewCamera();\n\n    // Create cameras for MPR views (right side - 3 orthographic planes)\n    this.transverseCameraManager = this.createTransverseCamera();   // Top-down (axial)\n    this.coronalCameraManager = this.createCoronalCamera();         // Front view\n    this.sagittalCameraManager = this.createSagittalCamera();       // Side view\n    \n    // Create summary gizmos for MPR views (will load heart models asynchronously)\n    this.createTransverseSummaryGizmo();\n    this.createCoronalSummaryGizmo();\n    this.createSagittalSummaryGizmo();\n\n    // Create visual slice indicators for MPR views\n    this.createSliceIndicators();\n\n    // Create camera for WORK viewport (orthographic for isometric view, no distortion)\n    this.workCameraManager = new CameraManager(this.renderer.workRenderer, {\n      type: 'orthographic',\n      frustumSize: 12,  // Larger viewing area to see full gizmo\n      aspect: 1.6       // 1.6:1 aspect ratio for touch screen\n    });\n    this.initialCameraPosition = this.workCameraManager.getCamera().position.clone();\n    this.initialCameraTarget = this.workCameraManager.getControls().target.clone();\n    this.initialCameraZoom = this.workCameraManager.getCamera().zoom || 1;\n    \n    // Gizmo and input handler will be initialized after model loads\n    this.gizmo = null;\n    this.inputHandler = null;\n  }\n\n  /**\n   * Async initialization - loads model and sets up scene\n   */\n  async init() {\n    console.log(' Initializing 3D Rotation Gizmo...');\n    \n    // ===== LOAD YOUR BLENDER MODEL =====\n    // IMPORTANT: Change this path to your actual .glb file!\n    // Example: '/models/your_model.glb'\n    const modelPath = '/models/heart.glb';\n    \n    try {\n      console.log(` Attempting to load Blender model from: ${modelPath}`);\n      \n      // ===== TOUCH SCREEN (Bottom) - Small decolorized model =====\n      this.testObject = await this.modelLoader.loadModel(modelPath, {\n        decolorize: true  // Apply white/gray material\n      });\n      \n      // Keep model SMALL for touch screen (0.8x scale for better visibility)\n      this.testObject.scale.set(0.8, 0.8, 0.8);\n      this.testObject.position.y = this.gizmoYOffset;\n      this.workSceneManager.add(this.testObject);\n      \n      console.log(' Touch screen model loaded (small, decolorized)');\n      \n      // ===== MAIN SCREEN (Top) - Large colored model =====\n      this.previewObject = await this.modelLoader.loadModel(modelPath);\n      \n      // Make model MASSIVE - almost fills main screen (15x scale)\n      this.previewObject.scale.set(15.0, 15.0, 15.0);\n      this.previewSceneManager.add(this.previewObject);\n      \n      // Enable material clipping for thin slab visualization\n      this.enableMaterialClipping();\n      \n      console.log(' Main screen model loaded (large, colored)');\n      console.log('   Generating MPR cross-sections...');\n      \n    } catch (error) {\n      console.warn(' Could not load Blender model, using fallback cubes');\n      console.warn('   Make sure your .glb file is in: public/models/');\n      console.warn('   Error:', error.message);\n      \n      // FALLBACK: Use cubes if model fails to load\n      this.testObject = this.createDecolorizedCube();\n      this.testObject.position.y = this.gizmoYOffset;\n      this.workSceneManager.add(this.testObject);\n      \n      this.previewObject = this.createTestObject();\n      this.previewObject.scale.set(15.0, 15.0, 15.0);\n      this.previewSceneManager.add(this.previewObject);\n      \n      // Enable material clipping for fallback cube\n      this.enableMaterialClipping();\n    }\n    \n    // Create transparent sphere tangent to axis rings (touch screen only)\n    this.workSphere = this.createTransparentSphere();\n    this.workSphere.visible = false; // Hidden by default (cube is default now)\n    this.workSphere.position.y = this.gizmoYOffset;\n    this.workSceneManager.add(this.workSphere);\n\n    // Create transparent cube wireframe (for cube style)\n    this.workCube = this.createTransparentCube();\n    this.workCube.visible = true; // Visible by default (cube is default)\n    this.workCube.position.y = this.gizmoYOffset;\n    this.workSceneManager.add(this.workCube);\n\n    // Store initial rotation for reset functionality\n    this.initialRotation = this.testObject.quaternion.clone();\n\n    // Initialize gizmo (only in work scene) - sized to avoid overlap with UI\n    this.gizmo = new RotationGizmo(this.testObject, {\n      radius: 2.5  // Balanced size for usability without overlap\n    });\n    this.gizmo.applyStyle('cube'); // Set cube as default style\n    const gizmoMesh = this.gizmo.getMesh();\n    this.workSceneManager.add(gizmoMesh);\n\n    // Add grid and helpers (only in work scene)\n    this.addGridHelper();\n\n    // Initialize input handler for gizmo interaction (only in work viewport)\n    this.inputHandler = new InputHandler(\n      this.workCameraManager.getCamera(),\n      this.renderer.domElement,\n      this.gizmo,\n      this // Pass app reference for slice control\n    );\n\n    // Disable orbit controls when interacting with gizmo\n    this.setupOrbitControlsIntegration();\n\n    // Setup reset button\n    this.setupResetButton();\n\n    // Setup style switcher\n    this.setupStyleSwitcher();\n\n    // Setup info panel toggle\n    this.setupInfoToggle();\n\n    // Setup draggable slice plane\n    this.setupDraggablePlane();\n\n    // Setup comprehensive resize handler for all cameras\n    this.setupResizeHandler();\n\n    // Start animation loop\n    this.animate();\n\n    console.log(' 3D Rotation Gizmo initialized');\n    console.log(' Dual viewport mode active');\n    console.log(' Top: Main screen (your 3D model)');\n    console.log(' Bottom: Touch screen (controls)');\n  }\n\n  /**\n   * Setup resize handler to update all cameras and renderers\n   */\n  setupResizeHandler() {\n    const handleResize = () => {\n      // Update work camera aspect ratio\n      this.workCameraManager.handleResize();\n      \n      // Update preview camera aspect ratio (left half)\n      if (this.previewCameraManager && this.previewCameraManager.handleResize) {\n        this.previewCameraManager.handleResize();\n      }\n      \n      // Update MPR plane cameras (right side - 3 views)\n      if (this.transverseCameraManager && this.transverseCameraManager.handleResize) {\n        this.transverseCameraManager.handleResize();\n      }\n      if (this.coronalCameraManager && this.coronalCameraManager.handleResize) {\n        this.coronalCameraManager.handleResize();\n      }\n      if (this.sagittalCameraManager && this.sagittalCameraManager.handleResize) {\n        this.sagittalCameraManager.handleResize();\n      }\n      \n      console.log(' Cameras resized');\n    };\n    \n    // Note: RendererManager already handles renderer resize\n    // This just ensures cameras also update\n    window.addEventListener('resize', handleResize);\n    \n    console.log(' Resize handler initialized');\n  }\n\n  /**\n   * Create preview camera (syncs with work camera)\n   * @returns {Object} Camera manager\n   */\n  createPreviewCamera() {\n    // Canvas is 70vh * 1.6, left half is (70vh * 1.6) / 2 / 70vh = 0.8\n    const camera = new THREE.PerspectiveCamera(\n      75,\n      0.8, // Left half of centered canvas with 1.6:1 aspect ratio\n      0.1,\n      1000\n    );\n    \n    // Initial camera position (will sync with work camera)\n    camera.position.set(4, 4, 4);\n    camera.lookAt(0, 0, 0);\n    \n    // 3D view camera sees all layers (simplified approach)\n    camera.layers.enableAll();\n\n    return {\n      getCamera: () => camera,\n      update: () => {}, // Camera position syncs in main animate loop\n      handleResize: () => {\n        // Canvas is 70vh * 1.6, left half is (70vh * 1.6) / 2 / 70vh = 0.8\n        camera.aspect = 0.8;\n        camera.updateProjectionMatrix();\n      }\n    };\n  }\n\n  /**\n   * Generate all cross-sections for MPR views\n   */\n  async generateAllCrossSections() {\n    if (!this.previewObject) {\n      console.warn('Preview object not ready for cross-section generation');\n      return;\n    }\n\n    console.log(' Generating CSG cross-sections...');\n\n    // Remove old slice indicators if they exist\n    if (this.transverseIndicatorGroup) {\n      this.previewSceneManager.getScene().remove(this.transverseIndicatorGroup);\n    }\n    if (this.coronalIndicatorGroup) {\n      this.previewSceneManager.getScene().remove(this.coronalIndicatorGroup);\n    }\n    if (this.sagittalIndicatorGroup) {\n      this.previewSceneManager.getScene().remove(this.sagittalIndicatorGroup);\n    }\n\n    // Need to traverse the model to find actual meshes\n    const meshes = [];\n    this.previewObject.traverse((child) => {\n      if (child.isMesh) {\n        meshes.push(child);\n      }\n    });\n\n    if (meshes.length === 0) {\n      console.warn('No meshes found in preview object');\n      return;\n    }\n\n    console.log(`Found ${meshes.length} meshes to slice`);\n\n    // Generate cross-sections for each axis using the first mesh (or merge all meshes)\n    const mainMesh = meshes[0];\n    \n    // Transverse (Y-axis) cross-section\n    const transverseSection = this.generateCrossSection(mainMesh, 'y', 0);\n    if (transverseSection) {\n      transverseSection.layers.set(1);\n      this.transverseIndicatorGroup = new THREE.Group();\n      this.transverseIndicatorGroup.add(transverseSection);\n      this.transverseIndicatorGroup.layers.set(1);\n      this.previewSceneManager.add(this.transverseIndicatorGroup);\n      console.log(' Transverse cross-section added');\n    }\n\n    // Coronal (Z-axis) cross-section\n    const coronalSection = this.generateCrossSection(mainMesh, 'z', 0);\n    if (coronalSection) {\n      coronalSection.layers.set(2);\n      this.coronalIndicatorGroup = new THREE.Group();\n      this.coronalIndicatorGroup.add(coronalSection);\n      this.coronalIndicatorGroup.layers.set(2);\n      this.previewSceneManager.add(this.coronalIndicatorGroup);\n      console.log(' Coronal cross-section added');\n    }\n\n    // Sagittal (X-axis) cross-section\n    const sagittalSection = this.generateCrossSection(mainMesh, 'x', 0);\n    if (sagittalSection) {\n      sagittalSection.layers.set(3);\n      this.sagittalIndicatorGroup = new THREE.Group();\n      this.sagittalIndicatorGroup.add(sagittalSection);\n      this.sagittalIndicatorGroup.layers.set(3);\n      this.previewSceneManager.add(this.sagittalIndicatorGroup);\n      console.log(' Sagittal cross-section added');\n    }\n\n    console.log(' All cross-sections generated');\n  }\n\n  /**\n   * Generate cross-section geometry using CSG\n   * @param {THREE.Mesh} mesh - The mesh to slice\n   * @param {string} axis - 'x', 'y', or 'z'\n   * @param {number} position - Position along the axis\n   * @returns {THREE.Mesh} Cross-section mesh\n   */\n  generateCrossSection(mesh, axis, position = 0) {\n    if (!mesh || !mesh.geometry) {\n      console.warn('No valid mesh provided for cross-section');\n      return null;\n    }\n\n    try {\n      const evaluator = new Evaluator();\n      const sliceThickness = 1.0; // Thin slice for cross-section\n      \n      // Create a thin box at the slice position\n      let slicerGeometry;\n      const largeSize = 50; // Large enough to cover the scaled model\n      \n      if (axis === 'y') {\n        // Horizontal slice (transverse)\n        slicerGeometry = new THREE.BoxGeometry(largeSize, sliceThickness, largeSize);\n      } else if (axis === 'z') {\n        // Front-to-back slice (coronal)  \n        slicerGeometry = new THREE.BoxGeometry(largeSize, largeSize, sliceThickness);\n      } else if (axis === 'x') {\n        // Left-to-right slice (sagittal)\n        slicerGeometry = new THREE.BoxGeometry(sliceThickness, largeSize, largeSize);\n      }\n      \n      // Create material for the cross-section\n      const color = axis === 'y' ? 0x00ff00 : (axis === 'z' ? 0x0000ff : 0xff0000);\n      const crossSectionMaterial = new THREE.MeshStandardMaterial({ \n        color: color,\n        side: THREE.DoubleSide,\n        metalness: 0.1,\n        roughness: 0.8\n      });\n      \n      // Convert mesh to Brush (CSG requires Brush objects)\n      const meshBrush = new Brush(mesh.geometry);\n      meshBrush.position.copy(mesh.position);\n      meshBrush.rotation.copy(mesh.rotation);\n      meshBrush.scale.copy(mesh.scale);\n      meshBrush.updateMatrixWorld();\n      \n      // Create slicer brush\n      const slicerBrush = new Brush(slicerGeometry);\n      if (axis === 'y') slicerBrush.position.y = position;\n      else if (axis === 'z') slicerBrush.position.z = position;\n      else if (axis === 'x') slicerBrush.position.x = position;\n      slicerBrush.updateMatrixWorld();\n      \n      // Perform intersection to get the cross-section\n      const result = evaluator.evaluate(meshBrush, slicerBrush, INTERSECTION);\n      result.material = crossSectionMaterial;\n      \n      console.log(` Generated ${axis}-axis cross-section at position ${position}`);\n      return result;\n      \n    } catch (error) {\n      console.error(` Error generating cross-section for ${axis}-axis:`, error);\n      return null;\n    }\n  }\n\n  /**\n   * Enable clipping on all materials in the preview object\n   */\n  enableMaterialClipping() {\n    if (!this.previewObject) return;\n    \n    this.previewObject.traverse((child) => {\n      if (child.isMesh && child.material) {\n        const materials = Array.isArray(child.material) ? child.material : [child.material];\n        materials.forEach(mat => {\n          mat.side = THREE.DoubleSide;\n          mat.needsUpdate = true;\n        });\n      }\n    });\n    \n    console.log(' Materials prepared for clipping');\n  }\n\n  /**\n   * Create dual clipping planes for thin slab visualization\n   * Shows only a thin slice of the model at each plane position\n   */\n  createSliceIndicators() {\n    this.sliceThickness = 4.0; // Thicker slab for better visibility\n    this.transverseYPosition = this.gizmoYOffset; // Initial Y position at model center (0.8)\n    \n    // === TRANSVERSE (Y-axis) - Two planes to create thin horizontal slab ===\n    this.transverseClipPlanes = [\n      new THREE.Plane(new THREE.Vector3(0, -1, 0), this.transverseYPosition + this.sliceThickness / 2),  // Clip below\n      new THREE.Plane(new THREE.Vector3(0, 1, 0), -this.transverseYPosition + this.sliceThickness / 2)    // Clip above\n    ];\n    \n    // === CORONAL (Z-axis) - Two planes to create thin front-to-back slab ===\n    this.coronalClipPlanes = [\n      new THREE.Plane(new THREE.Vector3(0, 0, -1), this.sliceThickness / 2),  // Clip behind\n      new THREE.Plane(new THREE.Vector3(0, 0, 1), this.sliceThickness / 2)    // Clip front\n    ];\n    \n    // === SAGITTAL (X-axis) - Two planes to create thin left-to-right slab ===\n    this.sagittalClipPlanes = [\n      new THREE.Plane(new THREE.Vector3(-1, 0, 0), this.sliceThickness / 2),  // Clip left\n      new THREE.Plane(new THREE.Vector3(1, 0, 0), this.sliceThickness / 2)    // Clip right\n    ];\n    \n    // Create visual indicator for the transverse plane\n    this.createTransversePlaneIndicator();\n    \n    console.log(' Dual clipping planes created for thin slab visualization');\n    console.log(`  Slice thickness: ${this.sliceThickness} units`);\n    console.log('  Draggable transverse plane indicator created');\n  }\n\n  /**\n   * Create a draggable visual indicator for the transverse plane\n   */\n  createTransversePlaneIndicator() {\n    // Create invisible plane for main screen (kept for backward compatibility)\n    const planeSize = 60;\n    const geometry = new THREE.PlaneGeometry(planeSize, planeSize);\n    const material = new THREE.MeshBasicMaterial({\n      color: 0x00ff00,\n      transparent: true,\n      opacity: 0,\n      side: THREE.DoubleSide,\n      depthTest: true,\n      depthWrite: false\n    });\n    \n    this.transversePlaneIndicator = new THREE.Mesh(geometry, material);\n    this.transversePlaneIndicator.rotation.x = Math.PI / 2;\n    this.transversePlaneIndicator.position.y = this.transverseYPosition;\n    this.transversePlaneIndicator.userData = { type: 'draggable-plane', axis: 'y' };\n    this.previewSceneManager.add(this.transversePlaneIndicator);\n    \n    console.log(' Transverse plane indicator created (main screen: invisible)');\n  }\n\n  /**\n   * Update the transverse clipping planes based on the current Y position\n   */\n  updateTransverseClipping(yPosition) {\n    this.transverseYPosition = yPosition;\n    \n    // Update clipping plane constants\n    // The planes are in world space, and the model is centered at Y=0\n    this.transverseClipPlanes[0].constant = yPosition + this.sliceThickness / 2;\n    this.transverseClipPlanes[1].constant = -yPosition + this.sliceThickness / 2;\n    \n    // Update visual indicator position (main screen)\n    if (this.transversePlaneIndicator) {\n      this.transversePlaneIndicator.position.y = yPosition;\n    }\n    \n    // Update the Y-axis position in the gizmo (touch screen)\n    // Works for both cube and circular modes\n    const localY = yPosition - this.gizmoYOffset;\n    \n    // Update square frame position (used in cube mode and for interaction in circular mode)\n    if (this.gizmo && this.gizmo.squareFrames && this.gizmo.squareFrames.y) {\n      this.gizmo.squareFrames.y.position.y = localY;\n    }\n    \n    // Update Y circular ring position (movable XZ plane in circular mode)\n    if (this.gizmo && this.gizmo.axes && this.gizmo.axes.y) {\n      this.gizmo.axes.y.mesh.position.y = localY;\n    }\n    \n    // Also move the highlight planes with the frame\n    if (this.gizmo && this.gizmo.squareHighlightPlanes && this.gizmo.squareHighlightPlanes.y) {\n      this.gizmo.squareHighlightPlanes.y.position.y = localY;\n    }\n    if (this.gizmo && this.gizmo.highlightPlanes && this.gizmo.highlightPlanes.y) {\n      this.gizmo.highlightPlanes.y.position.y = localY;\n    }\n    \n    console.log(` Transverse plane at Y = ${yPosition.toFixed(2)} | Frame local Y = ${(yPosition - this.gizmoYOffset).toFixed(2)}`);\n  }\n\n  /**\n   * Setup custom shader-based clipping on all materials\n   * This modifies materials to support clipping via custom shaders\n   */\n  setupShaderClipping() {\n    if (!this.previewObject) {\n      console.warn(' Preview object not found for shader setup!');\n      return;\n    }\n    \n    let materialCount = 0;\n    \n    this.previewObject.traverse((child) => {\n      if (child.isMesh && child.material) {\n        const materials = Array.isArray(child.material) ? child.material : [child.material];\n        \n        materials.forEach(mat => {\n          // Skip if already set up\n          if (mat.userData.shaderClippingSetup) return;\n          \n          // Set material to show both sides (important for cut surfaces)\n          mat.side = THREE.DoubleSide;\n          \n          // Add clipping uniforms\n          if (!mat.userData.clippingUniforms) {\n            mat.userData.clippingUniforms = {\n              clippingEnabled: { value: 0 },\n              clippingPlaneNormal: { value: new THREE.Vector3(0, 1, 0) },\n              clippingPlaneConstant: { value: 0.0 }\n            };\n          }\n          \n          // Inject custom shader code using onBeforeCompile\n          mat.onBeforeCompile = (shader) => {\n            // Add our uniforms to the shader\n            shader.uniforms.clippingEnabled = mat.userData.clippingUniforms.clippingEnabled;\n            shader.uniforms.clippingPlaneNormal = mat.userData.clippingUniforms.clippingPlaneNormal;\n            shader.uniforms.clippingPlaneConstant = mat.userData.clippingUniforms.clippingPlaneConstant;\n            \n            // Add varying to pass world position from vertex to fragment shader\n            shader.vertexShader = `\n              varying vec3 vWorldPosition;\n              ${shader.vertexShader}\n            `;\n            \n            // Calculate world position in vertex shader (after #include <project_vertex>)\n            shader.vertexShader = shader.vertexShader.replace(\n              '#include <project_vertex>',\n              `#include <project_vertex>\n              vWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;`\n            );\n            \n            // Add uniforms and varying to fragment shader\n            shader.fragmentShader = `\n              uniform int clippingEnabled;\n              uniform vec3 clippingPlaneNormal;\n              uniform float clippingPlaneConstant;\n              varying vec3 vWorldPosition;\n              ${shader.fragmentShader}\n            `;\n            \n            // Inject clipping logic at the start of main() function\n            shader.fragmentShader = shader.fragmentShader.replace(\n              'void main() {',\n              `void main() {\n                // Custom shader-based clipping\n                if (clippingEnabled == 1) {\n                  float distance = dot(vWorldPosition, clippingPlaneNormal) + clippingPlaneConstant;\n                  if (distance < 0.0) {\n                    discard;\n                  }\n                }\n              `\n            );\n            \n            // Store reference to shader for debugging\n            mat.userData.shader = shader;\n          };\n          \n          mat.userData.shaderClippingSetup = true;\n          mat.needsUpdate = true;\n          materialCount++;\n        });\n      }\n    });\n    \n    console.log(` Shader-based clipping setup on ${materialCount} materials`);\n  }\n\n  /**\n   * Update shader clipping uniforms for all materials\n   * @param {Array<THREE.Plane>} planes - Array of clipping planes (or empty for no clipping)\n   */\n  applyClippingToMaterials(planes) {\n    if (!this.previewObject) return;\n    \n    const enabled = planes.length > 0;\n    const plane = enabled ? planes[0] : null;\n    \n    this.previewObject.traverse((child) => {\n      if (child.isMesh && child.material) {\n        const materials = Array.isArray(child.material) ? child.material : [child.material];\n        \n        materials.forEach(mat => {\n          if (mat.userData.clippingUniforms) {\n            mat.userData.clippingUniforms.clippingEnabled.value = enabled ? 1 : 0;\n            \n            if (enabled && plane) {\n              mat.userData.clippingUniforms.clippingPlaneNormal.value.copy(plane.normal);\n              mat.userData.clippingUniforms.clippingPlaneConstant.value = plane.constant;\n            }\n          }\n        });\n      }\n    });\n  }\n\n  /**\n   * Create transverse camera (orthographic top-down view - axial plane)\n   * @returns {Object} Camera manager\n   */\n  createTransverseCamera() {\n    // Canvas is 70vh * 1.6, right half divided by 3: (70vh * 0.8) / (70vh / 3) = 2.4\n    const aspect = 2.4;\n    \n    const frustumSize = 60; // Increased for smaller model appearance\n    \n    const camera = new THREE.OrthographicCamera(\n      frustumSize * aspect / -2,  // left (wider to match aspect)\n      frustumSize * aspect / 2,   // right\n      frustumSize / 2,            // top\n      frustumSize / -2,           // bottom\n      0.1,                        // near\n      1000                        // far\n    );\n    \n    // Position camera looking straight down (transverse/axial plane)\n    camera.position.set(0, 50, 0);\n    camera.lookAt(0, 0, 0);\n    camera.up.set(0, 0, -1); // Orient camera so Z-axis points up in view\n    \n    // Transverse camera sees all layers (simplified approach)\n    camera.layers.enableAll();\n\n    return {\n      getCamera: () => camera,\n      update: () => {},\n      handleResize: () => {\n        // Canvas is 70vh * 1.6, right half divided by 3: (70vh * 0.8) / (70vh / 3) = 2.4\n        const aspect = 2.4;\n        camera.left = frustumSize * aspect / -2;\n        camera.right = frustumSize * aspect / 2;\n        camera.top = frustumSize / 2;\n        camera.bottom = frustumSize / -2;\n        camera.updateProjectionMatrix();\n      }\n    };\n  }\n\n  /**\n   * Create coronal camera (orthographic front view - coronal plane)\n   * @returns {Object} Camera manager\n   */\n  createCoronalCamera() {\n    // Canvas is 70vh * 1.6, right half divided by 3: (70vh * 0.8) / (70vh / 3) = 2.4\n    const aspect = 2.4;\n    const frustumSize = 60; // Increased for smaller model appearance\n    \n    const camera = new THREE.OrthographicCamera(\n      frustumSize * aspect / -2,\n      frustumSize * aspect / 2,\n      frustumSize / 2,\n      frustumSize / -2,\n      0.1,\n      1000\n    );\n    \n    // Position camera looking from front (along Z-axis)\n    camera.position.set(0, 0, 50);\n    camera.lookAt(0, 0, 0);\n    camera.up.set(0, 1, 0); // Y-axis points up\n    \n    // Coronal camera sees all layers (simplified approach)\n    camera.layers.enableAll();\n\n    return {\n      getCamera: () => camera,\n      update: () => {},\n      handleResize: () => {\n        // Canvas is 70vh * 1.6, right half divided by 3: (70vh * 0.8) / (70vh / 3) = 2.4\n        const aspect = 2.4;\n        camera.left = frustumSize * aspect / -2;\n        camera.right = frustumSize * aspect / 2;\n        camera.top = frustumSize / 2;\n        camera.bottom = frustumSize / -2;\n        camera.updateProjectionMatrix();\n      }\n    };\n  }\n\n  /**\n   * Create sagittal camera (orthographic side view - sagittal plane)\n   * @returns {Object} Camera manager\n   */\n  createSagittalCamera() {\n    // Canvas is 70vh * 1.6, right half divided by 3: (70vh * 0.8) / (70vh / 3) = 2.4\n    const aspect = 2.4;\n    const frustumSize = 60; // Increased for smaller model appearance\n    \n    const camera = new THREE.OrthographicCamera(\n      frustumSize * aspect / -2,\n      frustumSize * aspect / 2,\n      frustumSize / 2,\n      frustumSize / -2,\n      0.1,\n      1000\n    );\n    \n    // Position camera looking from right side (along X-axis)\n    camera.position.set(50, 0, 0);\n    camera.lookAt(0, 0, 0);\n    camera.up.set(0, 1, 0); // Y-axis points up\n    \n    // Sagittal camera sees all layers (simplified approach)\n    camera.layers.enableAll();\n\n    return {\n      getCamera: () => camera,\n      update: () => {},\n      handleResize: () => {\n        // Canvas is 70vh * 1.6, right half divided by 3: (70vh * 0.8) / (70vh / 3) = 2.4\n        const aspect = 2.4;\n        camera.left = frustumSize * aspect / -2;\n        camera.right = frustumSize * aspect / 2;\n        camera.top = frustumSize / 2;\n        camera.bottom = frustumSize / -2;\n        camera.updateProjectionMatrix();\n      }\n    };\n  }\n\n\n  /**\n   * Create a test object (cube) for rotation testing\n   * @returns {THREE.Mesh}\n   */\n  createTestObject() {\n    // Create a colorful cube with faces matching axis colors\n    const geometry = new THREE.BoxGeometry(2, 2, 2);\n    \n    // Create materials with colors matching the rotation axis\n    // This ensures clicking X shows red, Y shows green, Z shows blue\n    const materials = [\n      new THREE.MeshStandardMaterial({ color: 0xff0000 }), // Right (+X) - RED (matches X-axis)\n      new THREE.MeshStandardMaterial({ color: 0xff6666 }), // Left (-X) - Light Red\n      new THREE.MeshStandardMaterial({ color: 0x00ff00 }), // Top (+Y) - GREEN (matches Y-axis)\n      new THREE.MeshStandardMaterial({ color: 0x66ff66 }), // Bottom (-Y) - Light Green\n      new THREE.MeshStandardMaterial({ color: 0x0000ff }), // Front (+Z) - BLUE (matches Z-axis)\n      new THREE.MeshStandardMaterial({ color: 0x6666ff })  // Back (-Z) - Light Blue\n    ];\n\n    const cube = new THREE.Mesh(geometry, materials);\n    cube.position.set(0, 0, 0);\n    cube.castShadow = true;\n    cube.receiveShadow = true;\n\n    return cube;\n  }\n\n  /**\n   * Create a decolorized cube for touch screen (white/gray)\n   * Smaller size to not obstruct the axis rings\n   * @returns {THREE.Mesh}\n   */\n  createDecolorizedCube() {\n    // Smaller cube: 1.2x1.2x1.2 instead of 2x2x2\n    const geometry = new THREE.BoxGeometry(1.2, 1.2, 1.2);\n    \n    // White/gray materials for touch screen\n    const materials = [\n      new THREE.MeshStandardMaterial({ color: 0xeeeeee }), // Light gray\n      new THREE.MeshStandardMaterial({ color: 0xdddddd }), // Medium gray\n      new THREE.MeshStandardMaterial({ color: 0xffffff }), // White\n      new THREE.MeshStandardMaterial({ color: 0xcccccc }), // Gray\n      new THREE.MeshStandardMaterial({ color: 0xeeeeee }), // Light gray\n      new THREE.MeshStandardMaterial({ color: 0xdddddd })  // Medium gray\n    ];\n\n    const cube = new THREE.Mesh(geometry, materials);\n    cube.position.set(0, 0, 0);\n    cube.castShadow = true;\n    cube.receiveShadow = true;\n\n    return cube;\n  }\n\n  /**\n   * Create a transparent sphere tangent to the axis rings\n   * @returns {THREE.Mesh}\n   */\n  createTransparentSphere() {\n    // Sphere radius matches circular ring radius (2.5) to be perfectly tangent\n    const geometry = new THREE.SphereGeometry(2.5, 64, 64);\n    \n    // Transparent material that won't hide the rings\n    const material = new THREE.MeshBasicMaterial({\n      color: 0x888888,      // Gray color\n      transparent: true,\n      opacity: 0.15,        // Very transparent\n      side: THREE.DoubleSide,\n      depthWrite: false     // Don't write to depth buffer (won't hide rings)\n    });\n\n    const sphere = new THREE.Mesh(geometry, material);\n    sphere.position.set(0, 0, 0);\n\n    return sphere;\n  }\n\n  /**\n   * Create summary gizmo for transverse view (left side of split)\n   * Shows all gizmo components except axis buttons and lines\n   * Highlights the XZ plane (transverse cutting plane)\n   */\n  async createTransverseSummaryGizmo() {\n    // Create a separate scene and camera for the summary gizmo\n    this.summarySceneManager = new SceneManager();\n    \n    // Create isometric camera for summary (match touch screen exactly)\n    const frustumSize = 8; // Smaller frustum = more zoomed in for better legibility (was 12)\n    const aspect = 1; // Square viewport (1:1 ratio)\n    \n    // Create orthographic camera manually for precise control\n    this.summaryCamera = new THREE.OrthographicCamera(\n      frustumSize * aspect / -2,    // Left\n      frustumSize * aspect / 2,     // Right\n      frustumSize / 2,              // Top\n      frustumSize / -2,             // Bottom\n      0.1,                          // Near\n      1000                          // Far\n    );\n    \n    // Position camera to look at gizmo center\n    this.summaryCamera.position.set(5, 5 + this.gizmoYOffset, 5);\n    this.summaryCamera.lookAt(0, this.gizmoYOffset, 0);\n    \n    // Store frustum size for potential resize handling\n    this.summaryFrustumSize = frustumSize;\n    \n    // Add lighting\n    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);\n    this.summarySceneManager.add(ambientLight);\n    \n    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.4);\n    directionalLight.position.set(5, 10, 5);\n    this.summarySceneManager.add(directionalLight);\n    \n    // Load heart model for summary (scaled down)\n    try {\n      const model = await this.modelLoader.loadModel('/models/heart.glb');\n      this.summaryCube = model.clone(); // Clone to avoid sharing between scenes\n      this.summaryCube.scale.set(0.9, 0.9, 0.9); // Bigger scale (90% for better visibility)\n      this.summaryCube.position.y = this.gizmoYOffset;\n      \n      // Ensure all materials render properly\n      this.summaryCube.traverse((child) => {\n        if (child.isMesh) {\n          child.material.depthWrite = true;\n          child.material.depthTest = true;\n        }\n      });\n      \n      this.summarySceneManager.add(this.summaryCube);\n      console.log(' Heart model loaded for transverse summary');\n    } catch (error) {\n      console.warn(' Failed to load heart for summary, using cube fallback:', error);\n      // Fallback to gray cube\n      const cubeGeometry = new THREE.BoxGeometry(1.2, 1.2, 1.2);\n      const cubeMaterials = [\n        new THREE.MeshStandardMaterial({ color: 0xeeeeee }),\n        new THREE.MeshStandardMaterial({ color: 0xdddddd }),\n        new THREE.MeshStandardMaterial({ color: 0xffffff }),\n        new THREE.MeshStandardMaterial({ color: 0xcccccc }),\n        new THREE.MeshStandardMaterial({ color: 0xeeeeee }),\n        new THREE.MeshStandardMaterial({ color: 0xdddddd })\n      ];\n      this.summaryCube = new THREE.Mesh(cubeGeometry, cubeMaterials);\n      this.summaryCube.position.y = this.gizmoYOffset;\n      this.summarySceneManager.add(this.summaryCube);\n    }\n    \n    // Create transparent sphere/cube (synced with main gizmo style)\n    this.summarySphere = new THREE.Mesh(\n      new THREE.SphereGeometry(2.5, 64, 64),\n      new THREE.MeshBasicMaterial({\n        color: 0x888888,\n        transparent: true,\n        opacity: 0.15,\n        side: THREE.DoubleSide,\n        depthWrite: false\n      })\n    );\n    this.summarySphere.position.y = this.gizmoYOffset;\n    this.summarySphere.visible = false;\n    this.summarySceneManager.add(this.summarySphere);\n    \n    this.summaryTransparentCube = new THREE.Mesh(\n      new THREE.BoxGeometry(3.6, 3.6, 3.6),\n      new THREE.MeshBasicMaterial({\n        color: 0x888888,\n        transparent: true,\n        opacity: 0.15,\n        side: THREE.DoubleSide,\n        depthWrite: false\n      })\n    );\n    this.summaryTransparentCube.position.y = this.gizmoYOffset;\n    this.summaryTransparentCube.visible = true;\n    this.summarySceneManager.add(this.summaryTransparentCube);\n    \n    // Create plane outlines (circular and square) - but WITHOUT axis lines and buttons\n    this.createSummaryPlaneOutlines();\n    \n    // Create semi-transparent plane highlights (both square and circular)\n    const planeMaterial = new THREE.MeshBasicMaterial({\n      color: 0x00ff00,  // Green for transverse\n      transparent: true,\n      opacity: 0.15,    // More subtle (was 0.3)\n      side: THREE.DoubleSide,\n      depthTest: false\n    });\n    \n    // Square highlight\n    const squarePlaneGeometry = new THREE.PlaneGeometry(3.0, 3.0);\n    this.summaryPlaneHighlight = new THREE.Mesh(squarePlaneGeometry, planeMaterial);\n    this.summaryPlaneHighlight.rotation.x = Math.PI / 2; // Rotate to be XZ plane\n    this.summaryPlaneHighlight.position.y = this.gizmoYOffset;\n    this.summaryPlaneHighlight.visible = false; // Start hidden (cube style default)\n    this.summarySceneManager.add(this.summaryPlaneHighlight);\n    \n    // Circular highlight\n    const circularPlaneGeometry = new THREE.CircleGeometry(1.5, 64);\n    this.summaryPlaneHighlightCircular = new THREE.Mesh(circularPlaneGeometry, planeMaterial.clone());\n    this.summaryPlaneHighlightCircular.rotation.x = Math.PI / 2; // Rotate to be XZ plane\n    this.summaryPlaneHighlightCircular.position.y = this.gizmoYOffset;\n    this.summaryPlaneHighlightCircular.visible = false; // Start hidden\n    this.summarySceneManager.add(this.summaryPlaneHighlightCircular);\n    \n    console.log(' Transverse summary gizmo created');\n  }\n  \n  /**\n   * Create summary gizmo for coronal view (highlights YZ plane)\n   */\n  async createCoronalSummaryGizmo() {\n    this.coronalSummarySceneManager = new SceneManager();\n    \n    // Create orthographic camera (zoomed in for better legibility)\n    const frustumSize = 8; // Smaller frustum = more zoomed in (was 12)\n    const aspect = 1;\n    \n    this.coronalSummaryCamera = new THREE.OrthographicCamera(\n      frustumSize * aspect / -2,\n      frustumSize * aspect / 2,\n      frustumSize / 2,\n      frustumSize / -2,\n      0.1,\n      1000\n    );\n    \n    this.coronalSummaryCamera.position.set(5, 5 + this.gizmoYOffset, 5);\n    this.coronalSummaryCamera.lookAt(0, this.gizmoYOffset, 0);\n    \n    // Add lighting\n    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);\n    this.coronalSummarySceneManager.add(ambientLight);\n    \n    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.4);\n    directionalLight.position.set(5, 10, 5);\n    this.coronalSummarySceneManager.add(directionalLight);\n    \n    // Load heart model for coronal summary (scaled down)\n    try {\n      const model = await this.modelLoader.loadModel('/models/heart.glb');\n      this.coronalSummaryCube = model.clone(); // Clone to avoid sharing between scenes\n      this.coronalSummaryCube.scale.set(0.9, 0.9, 0.9); // Bigger scale (90% for better visibility)\n      this.coronalSummaryCube.position.y = this.gizmoYOffset;\n      \n      // Ensure all materials render properly\n      this.coronalSummaryCube.traverse((child) => {\n        if (child.isMesh) {\n          child.material.depthWrite = true;\n          child.material.depthTest = true;\n        }\n      });\n      \n      this.coronalSummarySceneManager.add(this.coronalSummaryCube);\n      console.log(' Heart model loaded for coronal summary');\n    } catch (error) {\n      console.warn(' Failed to load heart for coronal summary, using cube fallback:', error);\n      // Fallback to gray cube\n      const cubeGeometry = new THREE.BoxGeometry(1.2, 1.2, 1.2);\n      const cubeMaterials = [\n        new THREE.MeshStandardMaterial({ color: 0xeeeeee }),\n        new THREE.MeshStandardMaterial({ color: 0xdddddd }),\n        new THREE.MeshStandardMaterial({ color: 0xffffff }),\n        new THREE.MeshStandardMaterial({ color: 0xcccccc }),\n        new THREE.MeshStandardMaterial({ color: 0xeeeeee }),\n        new THREE.MeshStandardMaterial({ color: 0xdddddd })\n      ];\n      this.coronalSummaryCube = new THREE.Mesh(cubeGeometry, cubeMaterials);\n      this.coronalSummaryCube.position.y = this.gizmoYOffset;\n      this.coronalSummarySceneManager.add(this.coronalSummaryCube);\n    }\n    \n    // Create transparent sphere/cube\n    this.coronalSummarySphere = new THREE.Mesh(\n      new THREE.SphereGeometry(2.5, 64, 64),\n      new THREE.MeshBasicMaterial({\n        color: 0x888888,\n        transparent: true,\n        opacity: 0.15,\n        side: THREE.DoubleSide,\n        depthWrite: false\n      })\n    );\n    this.coronalSummarySphere.position.y = this.gizmoYOffset;\n    this.coronalSummarySphere.visible = false;\n    this.coronalSummarySceneManager.add(this.coronalSummarySphere);\n    \n    this.coronalSummaryTransparentCube = new THREE.Mesh(\n      new THREE.BoxGeometry(3.6, 3.6, 3.6),\n      new THREE.MeshBasicMaterial({\n        color: 0x888888,\n        transparent: true,\n        opacity: 0.15,\n        side: THREE.DoubleSide,\n        depthWrite: false\n      })\n    );\n    this.coronalSummaryTransparentCube.position.y = this.gizmoYOffset;\n    this.coronalSummaryTransparentCube.visible = true;\n    this.coronalSummarySceneManager.add(this.coronalSummaryTransparentCube);\n    \n    // Create plane outlines highlighting YZ (coronal)\n    this.createCoronalSummaryPlaneOutlines();\n    \n    // Create semi-transparent plane highlights (both square and circular)\n    const planeMaterial = new THREE.MeshBasicMaterial({\n      color: 0xff0000,  // Red for coronal\n      transparent: true,\n      opacity: 0.15,    // More subtle (was 0.3)\n      side: THREE.DoubleSide,\n      depthTest: false\n    });\n    \n    // Square highlight\n    const squarePlaneGeometry = new THREE.PlaneGeometry(3.0, 3.0);\n    this.coronalPlaneHighlight = new THREE.Mesh(squarePlaneGeometry, planeMaterial);\n    this.coronalPlaneHighlight.rotation.y = Math.PI / 2; // Rotate to be YZ plane\n    this.coronalPlaneHighlight.position.y = this.gizmoYOffset;\n    this.coronalPlaneHighlight.visible = false; // Start hidden (cube style default)\n    this.coronalSummarySceneManager.add(this.coronalPlaneHighlight);\n    \n    // Circular highlight\n    const circularPlaneGeometry = new THREE.CircleGeometry(1.5, 64);\n    this.coronalPlaneHighlightCircular = new THREE.Mesh(circularPlaneGeometry, planeMaterial.clone());\n    this.coronalPlaneHighlightCircular.rotation.y = Math.PI / 2; // Rotate to be YZ plane\n    this.coronalPlaneHighlightCircular.position.y = this.gizmoYOffset;\n    this.coronalPlaneHighlightCircular.visible = false; // Start hidden\n    this.coronalSummarySceneManager.add(this.coronalPlaneHighlightCircular);\n    \n    console.log(' Coronal summary gizmo created');\n  }\n  \n  /**\n   * Create summary gizmo for sagittal view (highlights XY plane)\n   */\n  async createSagittalSummaryGizmo() {\n    this.sagittalSummarySceneManager = new SceneManager();\n    \n    // Create orthographic camera (zoomed in for better legibility)\n    const frustumSize = 8; // Smaller frustum = more zoomed in (was 12)\n    const aspect = 1;\n    \n    this.sagittalSummaryCamera = new THREE.OrthographicCamera(\n      frustumSize * aspect / -2,\n      frustumSize * aspect / 2,\n      frustumSize / 2,\n      frustumSize / -2,\n      0.1,\n      1000\n    );\n    \n    this.sagittalSummaryCamera.position.set(5, 5 + this.gizmoYOffset, 5);\n    this.sagittalSummaryCamera.lookAt(0, this.gizmoYOffset, 0);\n    \n    // Add lighting\n    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);\n    this.sagittalSummarySceneManager.add(ambientLight);\n    \n    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.4);\n    directionalLight.position.set(5, 10, 5);\n    this.sagittalSummarySceneManager.add(directionalLight);\n    \n    // Load heart model for sagittal summary (scaled down)\n    try {\n      const model = await this.modelLoader.loadModel('/models/heart.glb');\n      this.sagittalSummaryCube = model.clone(); // Clone to avoid sharing between scenes\n      this.sagittalSummaryCube.scale.set(0.9, 0.9, 0.9); // Bigger scale (90% for better visibility)\n      this.sagittalSummaryCube.position.y = this.gizmoYOffset;\n      \n      // Ensure all materials render properly\n      this.sagittalSummaryCube.traverse((child) => {\n        if (child.isMesh) {\n          child.material.depthWrite = true;\n          child.material.depthTest = true;\n        }\n      });\n      \n      this.sagittalSummarySceneManager.add(this.sagittalSummaryCube);\n      console.log(' Heart model loaded for sagittal summary');\n    } catch (error) {\n      console.warn(' Failed to load heart for sagittal summary, using cube fallback:', error);\n      // Fallback to gray cube\n      const cubeGeometry = new THREE.BoxGeometry(1.2, 1.2, 1.2);\n      const cubeMaterials = [\n        new THREE.MeshStandardMaterial({ color: 0xeeeeee }),\n        new THREE.MeshStandardMaterial({ color: 0xdddddd }),\n        new THREE.MeshStandardMaterial({ color: 0xffffff }),\n        new THREE.MeshStandardMaterial({ color: 0xcccccc }),\n        new THREE.MeshStandardMaterial({ color: 0xeeeeee }),\n        new THREE.MeshStandardMaterial({ color: 0xdddddd })\n      ];\n      this.sagittalSummaryCube = new THREE.Mesh(cubeGeometry, cubeMaterials);\n      this.sagittalSummaryCube.position.y = this.gizmoYOffset;\n      this.sagittalSummarySceneManager.add(this.sagittalSummaryCube);\n    }\n    \n    // Create transparent sphere/cube\n    this.sagittalSummarySphere = new THREE.Mesh(\n      new THREE.SphereGeometry(2.5, 64, 64),\n      new THREE.MeshBasicMaterial({\n        color: 0x888888,\n        transparent: true,\n        opacity: 0.15,\n        side: THREE.DoubleSide,\n        depthWrite: false\n      })\n    );\n    this.sagittalSummarySphere.position.y = this.gizmoYOffset;\n    this.sagittalSummarySphere.visible = false;\n    this.sagittalSummarySceneManager.add(this.sagittalSummarySphere);\n    \n    this.sagittalSummaryTransparentCube = new THREE.Mesh(\n      new THREE.BoxGeometry(3.6, 3.6, 3.6),\n      new THREE.MeshBasicMaterial({\n        color: 0x888888,\n        transparent: true,\n        opacity: 0.15,\n        side: THREE.DoubleSide,\n        depthWrite: false\n      })\n    );\n    this.sagittalSummaryTransparentCube.position.y = this.gizmoYOffset;\n    this.sagittalSummaryTransparentCube.visible = true;\n    this.sagittalSummarySceneManager.add(this.sagittalSummaryTransparentCube);\n    \n    // Create plane outlines highlighting XY (sagittal)\n    this.createSagittalSummaryPlaneOutlines();\n    \n    // Create semi-transparent plane highlights (both square and circular)\n    const planeMaterial = new THREE.MeshBasicMaterial({\n      color: 0x0000ff,  // Blue for sagittal\n      transparent: true,\n      opacity: 0.15,    // More subtle (was 0.3)\n      side: THREE.DoubleSide,\n      depthTest: false\n    });\n    \n    // Square highlight\n    const squarePlaneGeometry = new THREE.PlaneGeometry(3.0, 3.0);\n    this.sagittalPlaneHighlight = new THREE.Mesh(squarePlaneGeometry, planeMaterial);\n    this.sagittalPlaneHighlight.position.y = this.gizmoYOffset; // XY plane (no rotation needed)\n    this.sagittalPlaneHighlight.visible = false; // Start hidden (cube style default)\n    this.sagittalSummarySceneManager.add(this.sagittalPlaneHighlight);\n    \n    // Circular highlight\n    const circularPlaneGeometry = new THREE.CircleGeometry(1.5, 64);\n    this.sagittalPlaneHighlightCircular = new THREE.Mesh(circularPlaneGeometry, planeMaterial.clone());\n    this.sagittalPlaneHighlightCircular.position.y = this.gizmoYOffset; // XY plane (no rotation needed)\n    this.sagittalPlaneHighlightCircular.visible = false; // Start hidden\n    this.sagittalSummarySceneManager.add(this.sagittalPlaneHighlightCircular);\n    \n    console.log(' Sagittal summary gizmo created');\n  }\n  \n  /**\n   * Create plane outlines for summary gizmo (XY, YZ, ZX)\n   * Always highlights the XZ plane (transverse cutting plane)\n   */\n  createSummaryPlaneOutlines() {\n    const radius = 2.5; // Match circular gizmo\n    const squareSize = 3.6; // Match cube gizmo\n    \n    // Circular plane outlines (for circular style)\n    this.summaryCircularPlanes = {\n      xy: this.createCircularPlaneOutline(radius, 0x0000ff, false), // Blue, not highlighted\n      yz: this.createCircularPlaneOutline(radius, 0xff0000, false), // Red, not highlighted\n      zx: this.createCircularPlaneOutline(radius, 0x00ff00, true)   // Green, HIGHLIGHTED (transverse)\n    };\n    \n    // Position circular planes\n    this.summaryCircularPlanes.xy.position.y = this.gizmoYOffset;\n    this.summaryCircularPlanes.yz.rotation.y = Math.PI / 2;\n    this.summaryCircularPlanes.yz.position.y = this.gizmoYOffset;\n    this.summaryCircularPlanes.zx.rotation.x = Math.PI / 2;\n    this.summaryCircularPlanes.zx.position.y = this.gizmoYOffset;\n    \n    this.summaryCircularPlanes.xy.visible = false; // Hidden by default (cube is default)\n    this.summaryCircularPlanes.yz.visible = false;\n    this.summaryCircularPlanes.zx.visible = false;\n    \n    this.summarySceneManager.add(this.summaryCircularPlanes.xy);\n    this.summarySceneManager.add(this.summaryCircularPlanes.yz);\n    this.summarySceneManager.add(this.summaryCircularPlanes.zx);\n    \n    // Square plane outlines (for cube style)\n    this.summarySquarePlanes = {\n      xy: this.createSquarePlaneOutline(squareSize, 0x0000ff, false), // Blue, not highlighted\n      yz: this.createSquarePlaneOutline(squareSize, 0xff0000, false), // Red, not highlighted\n      zx: this.createSquarePlaneOutline(squareSize, 0x00ff00, true)   // Green, HIGHLIGHTED (transverse)\n    };\n    \n    // Position square planes\n    this.summarySquarePlanes.xy.position.y = this.gizmoYOffset;\n    this.summarySquarePlanes.yz.rotation.y = Math.PI / 2;\n    this.summarySquarePlanes.yz.position.y = this.gizmoYOffset;\n    this.summarySquarePlanes.zx.rotation.x = Math.PI / 2;\n    this.summarySquarePlanes.zx.position.y = this.gizmoYOffset;\n    \n    this.summarySquarePlanes.xy.visible = true; // Visible by default (cube is default)\n    this.summarySquarePlanes.yz.visible = true;\n    this.summarySquarePlanes.zx.visible = true;\n    \n    this.summarySceneManager.add(this.summarySquarePlanes.xy);\n    this.summarySceneManager.add(this.summarySquarePlanes.yz);\n    this.summarySceneManager.add(this.summarySquarePlanes.zx);\n  }\n  \n  /**\n   * Create plane outlines for coronal summary gizmo\n   * Highlights YZ plane (coronal cutting plane - RED)\n   */\n  createCoronalSummaryPlaneOutlines() {\n    const radius = 2.5;\n    const squareSize = 3.6;\n    \n    // Circular planes\n    this.coronalSummaryCircularPlanes = {\n      xy: this.createCircularPlaneOutline(radius, 0x0000ff, false), // Blue, not highlighted\n      yz: this.createCircularPlaneOutline(radius, 0xff0000, true),  // Red, HIGHLIGHTED (coronal)\n      zx: this.createCircularPlaneOutline(radius, 0x00ff00, false)  // Green, not highlighted\n    };\n    \n    this.coronalSummaryCircularPlanes.xy.position.y = this.gizmoYOffset;\n    this.coronalSummaryCircularPlanes.yz.rotation.y = Math.PI / 2;\n    this.coronalSummaryCircularPlanes.yz.position.y = this.gizmoYOffset;\n    this.coronalSummaryCircularPlanes.zx.rotation.x = Math.PI / 2;\n    this.coronalSummaryCircularPlanes.zx.position.y = this.gizmoYOffset;\n    \n    this.coronalSummaryCircularPlanes.xy.visible = false;\n    this.coronalSummaryCircularPlanes.yz.visible = false;\n    this.coronalSummaryCircularPlanes.zx.visible = false;\n    \n    this.coronalSummarySceneManager.add(this.coronalSummaryCircularPlanes.xy);\n    this.coronalSummarySceneManager.add(this.coronalSummaryCircularPlanes.yz);\n    this.coronalSummarySceneManager.add(this.coronalSummaryCircularPlanes.zx);\n    \n    // Square planes\n    this.coronalSummarySquarePlanes = {\n      xy: this.createSquarePlaneOutline(squareSize, 0x0000ff, false), // Blue, not highlighted\n      yz: this.createSquarePlaneOutline(squareSize, 0xff0000, true),  // Red, HIGHLIGHTED (coronal)\n      zx: this.createSquarePlaneOutline(squareSize, 0x00ff00, false)  // Green, not highlighted\n    };\n    \n    this.coronalSummarySquarePlanes.xy.position.y = this.gizmoYOffset;\n    this.coronalSummarySquarePlanes.yz.rotation.y = Math.PI / 2;\n    this.coronalSummarySquarePlanes.yz.position.y = this.gizmoYOffset;\n    this.coronalSummarySquarePlanes.zx.rotation.x = Math.PI / 2;\n    this.coronalSummarySquarePlanes.zx.position.y = this.gizmoYOffset;\n    \n    this.coronalSummarySquarePlanes.xy.visible = true;\n    this.coronalSummarySquarePlanes.yz.visible = true;\n    this.coronalSummarySquarePlanes.zx.visible = true;\n    \n    this.coronalSummarySceneManager.add(this.coronalSummarySquarePlanes.xy);\n    this.coronalSummarySceneManager.add(this.coronalSummarySquarePlanes.yz);\n    this.coronalSummarySceneManager.add(this.coronalSummarySquarePlanes.zx);\n  }\n  \n  /**\n   * Create plane outlines for sagittal summary gizmo\n   * Highlights XY plane (sagittal cutting plane - BLUE)\n   */\n  createSagittalSummaryPlaneOutlines() {\n    const radius = 2.5;\n    const squareSize = 3.6;\n    \n    // Circular planes\n    this.sagittalSummaryCircularPlanes = {\n      xy: this.createCircularPlaneOutline(radius, 0x0000ff, true),  // Blue, HIGHLIGHTED (sagittal)\n      yz: this.createCircularPlaneOutline(radius, 0xff0000, false), // Red, not highlighted\n      zx: this.createCircularPlaneOutline(radius, 0x00ff00, false)  // Green, not highlighted\n    };\n    \n    this.sagittalSummaryCircularPlanes.xy.position.y = this.gizmoYOffset;\n    this.sagittalSummaryCircularPlanes.yz.rotation.y = Math.PI / 2;\n    this.sagittalSummaryCircularPlanes.yz.position.y = this.gizmoYOffset;\n    this.sagittalSummaryCircularPlanes.zx.rotation.x = Math.PI / 2;\n    this.sagittalSummaryCircularPlanes.zx.position.y = this.gizmoYOffset;\n    \n    this.sagittalSummaryCircularPlanes.xy.visible = false;\n    this.sagittalSummaryCircularPlanes.yz.visible = false;\n    this.sagittalSummaryCircularPlanes.zx.visible = false;\n    \n    this.sagittalSummarySceneManager.add(this.sagittalSummaryCircularPlanes.xy);\n    this.sagittalSummarySceneManager.add(this.sagittalSummaryCircularPlanes.yz);\n    this.sagittalSummarySceneManager.add(this.sagittalSummaryCircularPlanes.zx);\n    \n    // Square planes\n    this.sagittalSummarySquarePlanes = {\n      xy: this.createSquarePlaneOutline(squareSize, 0x0000ff, true),  // Blue, HIGHLIGHTED (sagittal)\n      yz: this.createSquarePlaneOutline(squareSize, 0xff0000, false), // Red, not highlighted\n      zx: this.createSquarePlaneOutline(squareSize, 0x00ff00, false)  // Green, not highlighted\n    };\n    \n    this.sagittalSummarySquarePlanes.xy.position.y = this.gizmoYOffset;\n    this.sagittalSummarySquarePlanes.yz.rotation.y = Math.PI / 2;\n    this.sagittalSummarySquarePlanes.yz.position.y = this.gizmoYOffset;\n    this.sagittalSummarySquarePlanes.zx.rotation.x = Math.PI / 2;\n    this.sagittalSummarySquarePlanes.zx.position.y = this.gizmoYOffset;\n    \n    this.sagittalSummarySquarePlanes.xy.visible = true;\n    this.sagittalSummarySquarePlanes.yz.visible = true;\n    this.sagittalSummarySquarePlanes.zx.visible = true;\n    \n    this.sagittalSummarySceneManager.add(this.sagittalSummarySquarePlanes.xy);\n    this.sagittalSummarySceneManager.add(this.sagittalSummarySquarePlanes.yz);\n    this.sagittalSummarySceneManager.add(this.sagittalSummarySquarePlanes.zx);\n  }\n  \n  /**\n   * Create circular plane outline\n   */\n  createCircularPlaneOutline(radius, color, highlighted) {\n    const segments = 64;\n    const geometry = new THREE.BufferGeometry();\n    const positions = [];\n    \n    for (let i = 0; i <= segments; i++) {\n      const theta = (i / segments) * Math.PI * 2;\n      positions.push(\n        Math.cos(theta) * radius,\n        Math.sin(theta) * radius,\n        0\n      );\n    }\n    \n    geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));\n    \n    const material = new THREE.LineDashedMaterial({\n      color: highlighted ? color : 0x333333,\n      linewidth: highlighted ? 3 : 1,\n      opacity: highlighted ? 1.0 : 0.2,\n      transparent: true,\n      dashSize: 0.2,\n      gapSize: 0.1\n    });\n    \n    const line = new THREE.Line(geometry, material);\n    line.computeLineDistances();\n    \n    return line;\n  }\n  \n  /**\n   * Create square plane outline\n   */\n  createSquarePlaneOutline(size, color, highlighted) {\n    const halfSize = size / 2;\n    const geometry = new THREE.BufferGeometry();\n    const positions = [\n      -halfSize, -halfSize, 0,\n      halfSize, -halfSize, 0,\n      halfSize, halfSize, 0,\n      -halfSize, halfSize, 0,\n      -halfSize, -halfSize, 0\n    ];\n    \n    geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));\n    \n    const material = new THREE.LineDashedMaterial({\n      color: highlighted ? color : 0x333333,\n      linewidth: highlighted ? 3 : 1,\n      opacity: highlighted ? 1.0 : 0.2,\n      transparent: true,\n      dashSize: 0.2,\n      gapSize: 0.1\n    });\n    \n    const line = new THREE.Line(geometry, material);\n    line.computeLineDistances();\n    \n    return line;\n  }\n\n  /**\n   * Create a transparent filled cube\n   * @returns {THREE.Mesh}\n   */\n  createTransparentCube() {\n    // Size matches square frames (3.6) to be tangent to the XY/YZ/ZX planes\n    const size = 3.6;  // Tangent to square frames\n    const geometry = new THREE.BoxGeometry(size, size, size);\n    \n    // Transparent filled material\n    const material = new THREE.MeshBasicMaterial({\n      color: 0x888888,      // Gray color\n      transparent: true,\n      opacity: 0.15,        // Half-transparent like the sphere\n      side: THREE.DoubleSide,\n      depthWrite: false     // Don't write to depth buffer\n    });\n    \n    const cube = new THREE.Mesh(geometry, material);\n    \n    return cube;\n  }\n\n  /**\n   * Setup integration between orbit controls and gizmo input\n   */\n  setupOrbitControlsIntegration() {\n    const controls = this.workCameraManager.getControls();\n    \n    // Store reference to check if we should disable controls\n    this.inputHandler.onGizmoInteractionStart = () => {\n      controls.enabled = false;\n    };\n\n    this.inputHandler.onGizmoInteractionEnd = () => {\n      controls.enabled = true;\n    };\n  }\n\n  /**\n   * Setup reset button to return object to initial rotation\n   */\n  /**\n   * Setup style switcher buttons for gizmo visual testing\n   */\n  setupStyleSwitcher() {\n    const styleButtons = document.querySelectorAll('.style-button');\n    \n    styleButtons.forEach(button => {\n      button.addEventListener('click', () => {\n        // Remove active class from all buttons\n        styleButtons.forEach(btn => btn.classList.remove('active'));\n        \n        // Add active class to clicked button\n        button.classList.add('active');\n        \n        // Get style name and apply it\n        const styleName = button.getAttribute('data-style');\n        this.gizmo.applyStyle(styleName);\n        \n        // Show/hide sphere and cube based on style (main gizmo)\n        if (this.workSphere) {\n          if (styleName === 'circular') {\n            this.workSphere.visible = true;\n            this.workCube.visible = false;\n            console.log(' Sphere visible, cube hidden');\n          } else if (styleName === 'linear') {\n            this.workSphere.visible = false;\n            this.workCube.visible = false;\n            console.log(' Sphere hidden, cube hidden');\n          } else if (styleName === 'cube') {\n            this.workSphere.visible = false;\n            this.workCube.visible = true;\n            console.log(' Sphere hidden, cube visible');\n          }\n        }\n        \n        // Update summary gizmo shapes visibility\n        if (this.summaryTransparentCube && this.summarySphere) {\n          if (styleName === 'cube') {\n            this.summaryTransparentCube.visible = true;\n            this.summarySphere.visible = false;\n            // Show square planes, hide circular\n            if (this.summarySquarePlanes) {\n              this.summarySquarePlanes.xy.visible = true;\n              this.summarySquarePlanes.yz.visible = true;\n              this.summarySquarePlanes.zx.visible = true;\n            }\n            if (this.summaryCircularPlanes) {\n              this.summaryCircularPlanes.xy.visible = false;\n              this.summaryCircularPlanes.yz.visible = false;\n              this.summaryCircularPlanes.zx.visible = false;\n            }\n            // Show square highlights, hide circular\n            if (this.summaryPlaneHighlight) this.summaryPlaneHighlight.visible = true;\n            if (this.summaryPlaneHighlightCircular) this.summaryPlaneHighlightCircular.visible = false;\n          } else if (styleName === 'circular') {\n            this.summaryTransparentCube.visible = false;\n            this.summarySphere.visible = true;\n            // Show circular planes, hide square\n            if (this.summarySquarePlanes) {\n              this.summarySquarePlanes.xy.visible = false;\n              this.summarySquarePlanes.yz.visible = false;\n              this.summarySquarePlanes.zx.visible = false;\n            }\n            if (this.summaryCircularPlanes) {\n              this.summaryCircularPlanes.xy.visible = true;\n              this.summaryCircularPlanes.yz.visible = true;\n              this.summaryCircularPlanes.zx.visible = true;\n            }\n            // Show circular highlights, hide square\n            if (this.summaryPlaneHighlight) this.summaryPlaneHighlight.visible = false;\n            if (this.summaryPlaneHighlightCircular) this.summaryPlaneHighlightCircular.visible = true;\n          }\n        }\n        \n        // Update coronal summary gizmo shapes\n        if (this.coronalSummaryTransparentCube && this.coronalSummarySphere) {\n          if (styleName === 'cube') {\n            this.coronalSummaryTransparentCube.visible = true;\n            this.coronalSummarySphere.visible = false;\n            if (this.coronalSummarySquarePlanes) {\n              this.coronalSummarySquarePlanes.xy.visible = true;\n              this.coronalSummarySquarePlanes.yz.visible = true;\n              this.coronalSummarySquarePlanes.zx.visible = true;\n            }\n            if (this.coronalSummaryCircularPlanes) {\n              this.coronalSummaryCircularPlanes.xy.visible = false;\n              this.coronalSummaryCircularPlanes.yz.visible = false;\n              this.coronalSummaryCircularPlanes.zx.visible = false;\n            }\n            // Show square highlights, hide circular\n            if (this.coronalPlaneHighlight) this.coronalPlaneHighlight.visible = true;\n            if (this.coronalPlaneHighlightCircular) this.coronalPlaneHighlightCircular.visible = false;\n          } else if (styleName === 'circular') {\n            this.coronalSummaryTransparentCube.visible = false;\n            this.coronalSummarySphere.visible = true;\n            if (this.coronalSummarySquarePlanes) {\n              this.coronalSummarySquarePlanes.xy.visible = false;\n              this.coronalSummarySquarePlanes.yz.visible = false;\n              this.coronalSummarySquarePlanes.zx.visible = false;\n            }\n            if (this.coronalSummaryCircularPlanes) {\n              this.coronalSummaryCircularPlanes.xy.visible = true;\n              this.coronalSummaryCircularPlanes.yz.visible = true;\n              this.coronalSummaryCircularPlanes.zx.visible = true;\n            }\n            // Show circular highlights, hide square\n            if (this.coronalPlaneHighlight) this.coronalPlaneHighlight.visible = false;\n            if (this.coronalPlaneHighlightCircular) this.coronalPlaneHighlightCircular.visible = true;\n          }\n        }\n        \n        // Update sagittal summary gizmo shapes\n        if (this.sagittalSummaryTransparentCube && this.sagittalSummarySphere) {\n          if (styleName === 'cube') {\n            this.sagittalSummaryTransparentCube.visible = true;\n            this.sagittalSummarySphere.visible = false;\n            if (this.sagittalSummarySquarePlanes) {\n              this.sagittalSummarySquarePlanes.xy.visible = true;\n              this.sagittalSummarySquarePlanes.yz.visible = true;\n              this.sagittalSummarySquarePlanes.zx.visible = true;\n            }\n            if (this.sagittalSummaryCircularPlanes) {\n              this.sagittalSummaryCircularPlanes.xy.visible = false;\n              this.sagittalSummaryCircularPlanes.yz.visible = false;\n              this.sagittalSummaryCircularPlanes.zx.visible = false;\n            }\n            // Show square highlights, hide circular\n            if (this.sagittalPlaneHighlight) this.sagittalPlaneHighlight.visible = true;\n            if (this.sagittalPlaneHighlightCircular) this.sagittalPlaneHighlightCircular.visible = false;\n          } else if (styleName === 'circular') {\n            this.sagittalSummaryTransparentCube.visible = false;\n            this.sagittalSummarySphere.visible = true;\n            if (this.sagittalSummarySquarePlanes) {\n              this.sagittalSummarySquarePlanes.xy.visible = false;\n              this.sagittalSummarySquarePlanes.yz.visible = false;\n              this.sagittalSummarySquarePlanes.zx.visible = false;\n            }\n            if (this.sagittalSummaryCircularPlanes) {\n              this.sagittalSummaryCircularPlanes.xy.visible = true;\n              this.sagittalSummaryCircularPlanes.yz.visible = true;\n              this.sagittalSummaryCircularPlanes.zx.visible = true;\n            }\n            // Show circular highlights, hide square\n            if (this.sagittalPlaneHighlight) this.sagittalPlaneHighlight.visible = false;\n            if (this.sagittalPlaneHighlightCircular) this.sagittalPlaneHighlightCircular.visible = true;\n          }\n        }\n        \n        console.log(` Style switched to: ${styleName}`);\n      });\n    });\n    \n    console.log(' Style switcher initialized');\n  }\n\n  /**\n   * Setup reset button functionality\n   */\n  setupResetButton() {\n    const resetButton = document.getElementById('reset-button');\n    \n    if (resetButton) {\n      resetButton.addEventListener('click', () => {\n        this.resetRotation();\n      });\n    }\n    \n    console.log(' Reset button initialized');\n  }\n\n  /**\n   * Make info panels draggable while preserving their default CSS position\n   */\n  makeDraggable(element) {\n    const header = element.querySelector('.info-header');\n    \n    if (!header) {\n      console.warn(' Info header not found for draggable element');\n      return;\n    }\n    \n    let isDragging = false;\n    let currentX = 0;\n    let currentY = 0;\n    let initialX = 0;\n    let initialY = 0;\n    let xOffset = 0;\n    let yOffset = 0;\n\n    header.style.cursor = 'move';\n    header.style.userSelect = 'none';\n    \n    // Initialize with no transform (keeps CSS default position)\n    element.style.transform = 'translate(0px, 0px)';\n    \n    const dragStart = (e) => {\n      // Only drag if clicking on the header (not the chevron area)\n      if (e.target.classList.contains('chevron')) {\n        return;\n      }\n      \n      initialX = e.clientX - xOffset;\n      initialY = e.clientY - yOffset;\n\n      if (e.target === header || e.target.tagName === 'H1' || header.contains(e.target)) {\n        isDragging = true;\n      }\n    };\n\n    const drag = (e) => {\n      if (isDragging) {\n        e.preventDefault();\n        \n        currentX = e.clientX - initialX;\n        currentY = e.clientY - initialY;\n\n        xOffset = currentX;\n        yOffset = currentY;\n\n        element.style.transform = `translate(${currentX}px, ${currentY}px)`;\n      }\n    };\n\n    const dragEnd = (e) => {\n      initialX = currentX;\n      initialY = currentY;\n      isDragging = false;\n    };\n    \n    header.addEventListener('mousedown', dragStart);\n    document.addEventListener('mousemove', drag);\n    document.addEventListener('mouseup', dragEnd);\n    \n    console.log(` Panel draggable at default position: ${element.id}`);\n  }\n\n  /**\n   * Setup info panel toggle functionality\n   */\n  setupInfoToggle() {\n    // Setup toggle for both info panels\n    const panels = ['main-screen-info', 'touch-screen-info'];\n    \n    panels.forEach(panelId => {\n      const panel = document.getElementById(panelId);\n      if (!panel) {\n        console.warn(` ${panelId} panel not found`);\n        return;\n      }\n      \n      // Make panel draggable\n      this.makeDraggable(panel);\n      \n      const infoHeader = panel.querySelector('.info-header');\n      const infoContent = panel.querySelector('.info-content');\n      const chevron = panel.querySelector('.chevron');\n      \n      if (!infoHeader || !infoContent || !chevron) {\n        console.warn(` ${panelId} elements not found`);\n        return;\n      }\n      \n      // Toggle on chevron click\n      chevron.addEventListener('click', (e) => {\n        e.stopPropagation();\n        const isCollapsed = infoContent.classList.contains('collapsed');\n        \n        if (isCollapsed) {\n          // Expand\n          infoContent.classList.remove('collapsed');\n          chevron.classList.remove('collapsed');\n          chevron.textContent = '';  // Up arrow when expanded\n        } else {\n          // Collapse\n          infoContent.classList.add('collapsed');\n          chevron.classList.add('collapsed');\n          chevron.textContent = '';  // Down arrow when collapsed\n        }\n      });\n    });\n    \n    console.log(' Info panel toggles initialized');\n  }\n\n  /**\n   * Setup draggable plane interaction for MPR slice control\n   * This modifies the InputHandler to support transverse slice control\n   */\n  setupDraggablePlane() {\n    // Store reference to app instance for use in InputHandler\n    this.isControllingSlice = false;\n    this.sliceDragStartY = 0;\n    this.sliceStartPosition = 0;\n    \n    console.log(' Transverse slice control ready (drag Y-axis to control)');\n  }\n\n  /**\n   * Reset object rotation and camera to initial state with smooth animation\n   */\n  resetRotation() {\n    console.log(' Resetting rotation, camera, and slice planes to initial state');\n    \n    // Reset gizmo style to cube immediately (no need to animate this)\n    this.gizmo.applyStyle('cube');\n    \n    // Update style buttons\n    const styleButtons = document.querySelectorAll('.style-button');\n    styleButtons.forEach(btn => {\n      if (btn.getAttribute('data-style') === 'cube') {\n        btn.classList.add('active');\n      } else {\n        btn.classList.remove('active');\n      }\n    });\n    \n    // Show/hide sphere and cube based on cube style (work scene)\n    if (this.workSphere) {\n      this.workSphere.visible = false;\n      this.workCube.visible = true;\n    }\n    \n    // Update touch screen gizmo shapes (preview scene)\n    if (this.previewSphere && this.previewCube) {\n      this.previewSphere.visible = false;\n      this.previewCube.visible = true;\n    }\n    \n    // Update summary gizmo shapes visibility for cube style\n    if (this.summaryTransparentCube && this.summarySphere) {\n      this.summaryTransparentCube.visible = true;\n      this.summarySphere.visible = false;\n      if (this.summarySquarePlanes) {\n        this.summarySquarePlanes.xy.visible = true;\n        this.summarySquarePlanes.yz.visible = true;\n        this.summarySquarePlanes.zx.visible = true;\n      }\n      if (this.summaryCircularPlanes) {\n        this.summaryCircularPlanes.xy.visible = false;\n        this.summaryCircularPlanes.yz.visible = false;\n        this.summaryCircularPlanes.zx.visible = false;\n      }\n      if (this.summaryPlaneHighlight) this.summaryPlaneHighlight.visible = true;\n      if (this.summaryPlaneHighlightCircular) this.summaryPlaneHighlightCircular.visible = false;\n    }\n    \n    // Update coronal summary gizmo shapes\n    if (this.coronalSummaryTransparentCube && this.coronalSummarySphere) {\n      this.coronalSummaryTransparentCube.visible = true;\n      this.coronalSummarySphere.visible = false;\n      if (this.coronalSummarySquarePlanes) {\n        this.coronalSummarySquarePlanes.xy.visible = true;\n        this.coronalSummarySquarePlanes.yz.visible = true;\n        this.coronalSummarySquarePlanes.zx.visible = true;\n      }\n      if (this.coronalSummaryCircularPlanes) {\n        this.coronalSummaryCircularPlanes.xy.visible = false;\n        this.coronalSummaryCircularPlanes.yz.visible = false;\n        this.coronalSummaryCircularPlanes.zx.visible = false;\n      }\n      if (this.coronalPlaneHighlight) this.coronalPlaneHighlight.visible = true;\n      if (this.coronalPlaneHighlightCircular) this.coronalPlaneHighlightCircular.visible = false;\n    }\n    \n    // Update sagittal summary gizmo shapes\n    if (this.sagittalSummaryTransparentCube && this.sagittalSummarySphere) {\n      this.sagittalSummaryTransparentCube.visible = true;\n      this.sagittalSummarySphere.visible = false;\n      if (this.sagittalSummarySquarePlanes) {\n        this.sagittalSummarySquarePlanes.xy.visible = true;\n        this.sagittalSummarySquarePlanes.yz.visible = true;\n        this.sagittalSummarySquarePlanes.zx.visible = true;\n      }\n      if (this.sagittalSummaryCircularPlanes) {\n        this.sagittalSummaryCircularPlanes.xy.visible = false;\n        this.sagittalSummaryCircularPlanes.yz.visible = false;\n        this.sagittalSummaryCircularPlanes.zx.visible = false;\n      }\n      if (this.sagittalPlaneHighlight) this.sagittalPlaneHighlight.visible = true;\n      if (this.sagittalPlaneHighlightCircular) this.sagittalPlaneHighlightCircular.visible = false;\n    }\n    \n    // Disable orbit controls during reset to prevent interference\n    const controls = this.workCameraManager.getControls();\n    controls.enabled = false;\n    \n    // Store start states\n    const duration = 800; // milliseconds (longer for smoother appearance)\n    const startTime = Date.now();\n    const camera = this.workCameraManager.getCamera();\n    const startRotation = this.testObject.quaternion.clone();\n    const startCameraPosition = camera.position.clone();\n    const startCameraTarget = controls.target.clone();\n    const startCameraZoom = camera.zoom || 1;\n    const startTransverseY = this.transverseYPosition || 0;\n    \n    const animate = () => {\n      const elapsed = Date.now() - startTime;\n      const progress = Math.min(elapsed / duration, 1);\n      \n      // Smooth ease-in-out (sine wave) for more natural motion\n      const eased = 0.5 - Math.cos(progress * Math.PI) / 2;\n      \n      // Interpolate object rotation (quaternion)\n      this.testObject.quaternion.slerpQuaternions(\n        startRotation,\n        this.initialRotation,\n        eased\n      );\n      \n      // Interpolate camera position (work viewport only)\n      this.workCameraManager.getCamera().position.lerpVectors(\n        startCameraPosition,\n        this.initialCameraPosition,\n        eased\n      );\n      \n      // Interpolate camera target (where it's looking)\n      controls.target.lerpVectors(\n        startCameraTarget,\n        this.initialCameraTarget,\n        eased\n      );\n      \n      // Interpolate camera zoom (for OrthographicCamera)\n      if (camera.isOrthographicCamera) {\n        camera.zoom = startCameraZoom + (this.initialCameraZoom - startCameraZoom) * eased;\n        camera.updateProjectionMatrix();\n      }\n      \n      // Interpolate transverse slice position back to center (gizmoYOffset)\n      const targetY = this.gizmoYOffset;\n      const newTransverseY = startTransverseY + (targetY - startTransverseY) * eased;\n      this.updateTransverseClipping(newTransverseY);\n      \n      // Update controls without enabling them yet\n      controls.update();\n      \n      if (progress < 1) {\n        requestAnimationFrame(animate);\n      } else {\n        // Re-enable controls after animation completes\n        controls.enabled = true;\n        console.log(' Reset complete - rotation, camera (position, target, zoom), style (cube), and slice planes restored');\n      }\n    };\n    \n    animate();\n  }\n\n  /**\n   * Add a grid helper for spatial reference (only in work viewport)\n   * Currently hidden as per user request\n   */\n  addGridHelper() {\n    // Grid and axis helpers hidden for cleaner touch screen\n    // Uncomment below if needed:\n    // const gridHelper = new THREE.GridHelper(20, 20, 0x444444, 0x222222);\n    // this.workSceneManager.add(gridHelper);\n    // const axesHelper = new THREE.AxesHelper(5);\n    // this.workSceneManager.add(axesHelper);\n  }\n\n  /**\n   * Animation loop (renders both viewports)\n   */\n  animate() {\n    requestAnimationFrame(() => this.animate());\n\n    // Update work camera controls\n    this.workCameraManager.update();\n\n    // Sync preview camera with work camera\n    const workCamera = this.workCameraManager.getCamera();\n    const previewCamera = this.previewCameraManager.getCamera();\n    const workControls = this.workCameraManager.getControls();\n    \n    // Get work camera's position relative to target\n    const target = workControls.target.clone();\n    const direction = new THREE.Vector3().subVectors(workCamera.position, target);\n    const distance = direction.length();\n    \n    // Scale up the distance LESS than cube scale to make cube appear BIGGER\n    // Cube is 15x but camera only 8x away = cube appears much larger!\n    const scaledDistance = distance * 8.0;\n    direction.normalize().multiplyScalar(scaledDistance);\n    \n    // Set preview camera position (same angle, closer than cube scale)\n    previewCamera.position.copy(target).add(direction);\n    \n    // Add vertical offset to look higher (makes model appear lower in viewport)\n    const adjustedTarget = target.clone();\n    adjustedTarget.y += 2.0; // Look 2 units higher to move heart down\n    \n    previewCamera.lookAt(adjustedTarget);\n    previewCamera.zoom = workCamera.zoom;\n    previewCamera.updateProjectionMatrix();\n\n    // Sync preview object rotation with work object (hidden in touch screen)\n    this.previewObject.quaternion.copy(this.testObject.quaternion);\n\n    // Sync work sphere rotation with work object\n    if (this.workSphere) {\n      this.workSphere.quaternion.copy(this.testObject.quaternion);\n    }\n\n    // Update gizmo position (follows model which is already at gizmoYOffset)\n    this.gizmo.update();\n    \n    // Sync all summary gizmos with main gizmo rotation\n    if (this.summaryCube) {\n      this.summaryCube.quaternion.copy(this.testObject.quaternion);\n    }\n    if (this.coronalSummaryCube) {\n      this.coronalSummaryCube.quaternion.copy(this.testObject.quaternion);\n    }\n    if (this.sagittalSummaryCube) {\n      this.sagittalSummaryCube.quaternion.copy(this.testObject.quaternion);\n    }\n    \n    // Sync transverse summary plane position with transverse slice\n    if (this.summarySquarePlanes && this.summarySquarePlanes.zx) {\n      const localY = this.transverseYPosition - this.gizmoYOffset;\n      this.summarySquarePlanes.zx.position.y = this.gizmoYOffset + localY;\n    }\n    if (this.summaryCircularPlanes && this.summaryCircularPlanes.zx) {\n      const localY = this.transverseYPosition - this.gizmoYOffset;\n      this.summaryCircularPlanes.zx.position.y = this.gizmoYOffset + localY;\n    }\n    \n    // Sync plane highlights with slice positions\n    if (this.summaryPlaneHighlight) {\n      const localY = this.transverseYPosition - this.gizmoYOffset;\n      this.summaryPlaneHighlight.position.y = this.gizmoYOffset + localY;\n    }\n    if (this.summaryPlaneHighlightCircular) {\n      const localY = this.transverseYPosition - this.gizmoYOffset;\n      this.summaryPlaneHighlightCircular.position.y = this.gizmoYOffset + localY;\n    }\n    if (this.coronalPlaneHighlight) {\n      // Coronal plane position (would need to track if we add coronal dragging)\n      // For now, stays at center\n    }\n    if (this.coronalPlaneHighlightCircular) {\n      // Coronal plane position (would need to track if we add coronal dragging)\n      // For now, stays at center\n    }\n    if (this.sagittalPlaneHighlight) {\n      // Sagittal plane position (would need to track if we add sagittal dragging)\n      // For now, stays at center\n    }\n    if (this.sagittalPlaneHighlightCircular) {\n      // Sagittal plane position (would need to track if we add sagittal dragging)\n      // For now, stays at center\n    }\n\n    // Render all viewports with thin slab clipping for cross-section views\n    this.renderer.render(\n      this.previewSceneManager.getScene(),\n      this.previewCameraManager.getCamera(),\n      this.transverseCameraManager.getCamera(),\n      this.coronalCameraManager.getCamera(),\n      this.sagittalCameraManager.getCamera(),\n      this.transverseClipPlanes,\n      this.coronalClipPlanes,\n      this.sagittalClipPlanes,\n      this.workSceneManager.getScene(),\n      this.workCameraManager.getCamera(),\n      this.summarySceneManager.getScene(),\n      this.summaryCamera,\n      this.coronalSummarySceneManager.getScene(),\n      this.coronalSummaryCamera,\n      this.sagittalSummarySceneManager.getScene(),\n      this.sagittalSummaryCamera\n    );\n  }\n}\n\n// Initialize application when DOM is ready\nif (document.readyState === 'loading') {\n  document.addEventListener('DOMContentLoaded', async () => {\n    const app = new RotationGizmoApp();\n    await app.init();\n  });\n} else {\n  const app = new RotationGizmoApp();\n  app.init();\n}\n\n"],"names":["SceneManager","THREE.Scene","THREE.Color","ambientLight","THREE.AmbientLight","directionalLight","THREE.DirectionalLight","fillLight","object","_changeEvent","_startEvent","_endEvent","_ray","Ray","_plane","Plane","_TILT_LIMIT","MathUtils","_v","Vector3","_twoPI","_STATE","_EPS","OrbitControls","Controls","domElement","MOUSE","TOUCH","Quaternion","Spherical","Vector2","onPointerMove","onPointerDown","onPointerUp","onContextMenu","onMouseWheel","onKeyDown","onTouchStart","onTouchMove","onMouseDown","onMouseMove","interceptControlDown","interceptControlUp","element","deltaTime","position","min","max","zoomChanged","prevRadius","newRadius","radiusDelta","mouseBefore","prevZoom","mouseAfter","delta","normalizedDelta","angle","distance","objectMatrix","deltaX","deltaY","targetDistance","dollyScale","x","y","rect","dx","dy","w","h","dist","event","needsUpdate","centerX","centerY","i","pointerId","mode","newEvent","mouseAction","CameraManager","renderer","options","cameraType","frustumSize","THREE.OrthographicCamera","THREE.PerspectiveCamera","RendererManager","THREE.WebGLRenderer","THREE.PCFSoftShadowMap","previewContainer","workContainer","previewHeight","workHeight","previewWidth","workWidth","previewScene","previewCamera","transverseCamera","coronalCamera","sagittalCamera","transverseClipPlanes","coronalClipPlanes","sagittalClipPlanes","workScene","workCamera","summaryScene","summaryCamera","coronalSummaryScene","coronalSummaryCamera","sagittalSummaryScene","sagittalSummaryCamera","width","halfWidth","thirdHeight","overlaySize","overlayX","overlayY","size","elementId","border","canvasWidth","canvasOffsetX","cssY","cssX","RotationGizmo","targetObject","THREE.Group","labelDistance","THREE.Vector3","axisName","color","points","THREE.EllipseCurve","geometry","THREE.BufferGeometry","material","THREE.LineDashedMaterial","mesh","THREE.Line","axisVector","text","canvas","context","radius","darkColor","texture","THREE.CanvasTexture","spriteMaterial","THREE.SpriteMaterial","sprite","THREE.Sprite","shape","THREE.PlaneGeometry","THREE.CircleGeometry","THREE.MeshBasicMaterial","THREE.DoubleSide","plane","THREE.Mesh","axis","worldAxis","key","meshes","styleName","lineLength","lineWidth","xGeometry","THREE.CylinderGeometry","xMaterial","xLine","yGeometry","yMaterial","yLine","zGeometry","zMaterial","zLine","halfSize","createSquareFrame","group","edges","edge","line","planeSize","xPlane","yPlane","zPlane","label","rayPlaneIntersection","ray","target","intersection","signedAngle","v1","v2","cross","sign","quaternionFromAxisAngle","quaternion","THREE.Quaternion","createRotationPlane","point","THREE.Plane","InputHandler","camera","gizmo","app","THREE.Raycaster","THREE.Vector2","pickingMeshes","intersects","userData","checkObject","isLabel","type","hit","timeDiff","mouseDist","cameraDirection","targetPosition","originalAxis","cameraUp","fallbackAxis","newY","clampedY","currentHitPoint","pivot","startVector","currentVector","startLength","currentLength","deltaRotation","degrees","duration","startTime","startPosition","animate","elapsed","progress","eased","toTrianglesDrawMode","drawMode","TrianglesDrawMode","TriangleFanDrawMode","TriangleStripDrawMode","index","indices","numberOfTriangles","newIndices","newGeometry","GLTFLoader","Loader","manager","parser","GLTFMaterialsClearcoatExtension","GLTFMaterialsDispersionExtension","GLTFTextureBasisUExtension","GLTFTextureWebPExtension","GLTFTextureAVIFExtension","GLTFMaterialsSheenExtension","GLTFMaterialsTransmissionExtension","GLTFMaterialsVolumeExtension","GLTFMaterialsIorExtension","GLTFMaterialsEmissiveStrengthExtension","GLTFMaterialsSpecularExtension","GLTFMaterialsIridescenceExtension","GLTFMaterialsAnisotropyExtension","GLTFMaterialsBumpExtension","GLTFLightsExtension","GLTFMeshoptCompression","GLTFMeshGpuInstancing","url","onLoad","onProgress","onError","scope","resourcePath","relativeUrl","LoaderUtils","_onError","e","loader","FileLoader","data","gltf","dracoLoader","ktx2Loader","meshoptDecoder","callback","path","json","extensions","plugins","textDecoder","BINARY_EXTENSION_HEADER_MAGIC","EXTENSIONS","GLTFBinaryExtension","error","GLTFParser","plugin","extensionName","extensionsRequired","GLTFMaterialsUnlitExtension","GLTFDracoMeshCompressionExtension","GLTFTextureTransformExtension","GLTFMeshQuantizationExtension","resolve","reject","GLTFRegistry","objects","nodeDefs","nodeIndex","nodeLength","nodeDef","lightIndex","cacheKey","dependency","lightDef","lightNode","Color","LinearSRGBColorSpace","range","DirectionalLight","PointLight","SpotLight","assignExtrasToUserData","self","light","MeshBasicMaterial","materialParams","materialDef","pending","metallicRoughness","array","SRGBColorSpace","materialIndex","emissiveStrength","MeshPhysicalMaterial","extension","scale","colorFactor","colorArray","textureIndex","textureDef","name","source","handler","bufferView","extensionDef","buffer","decoder","res","byteOffset","byteLength","count","stride","result","meshDef","primitive","WEBGL_CONSTANTS","attributesDef","attributes","accessor","results","nodeObject","instancedMeshes","m","Matrix4","p","q","s","instancedMesh","InstancedMesh","attributeName","attr","InstancedBufferAttribute","Object3D","BINARY_EXTENSION_HEADER_LENGTH","BINARY_EXTENSION_CHUNK_TYPES","headerView","chunkContentsLength","chunkView","chunkIndex","chunkLength","chunkType","contentArray","bufferViewIndex","gltfAttributeMap","threeAttributeMap","attributeNormalizedMap","attributeTypeMap","threeAttributeName","ATTRIBUTES","accessorDef","componentType","WEBGL_COMPONENT_TYPES","attribute","normalized","transform","GLTFCubicSplineInterpolant","Interpolant","parameterPositions","sampleValues","sampleSize","resultBuffer","values","valueSize","offset","i1","t0","t","t1","stride2","stride3","td","pp","ppp","offset1","offset0","s2","s3","s0","s1","p0","m0","p1","m1","_quaternion","GLTFCubicSplineQuaternionInterpolant","WEBGL_FILTERS","NearestFilter","LinearFilter","NearestMipmapNearestFilter","LinearMipmapNearestFilter","NearestMipmapLinearFilter","LinearMipmapLinearFilter","WEBGL_WRAPPINGS","ClampToEdgeWrapping","MirroredRepeatWrapping","RepeatWrapping","WEBGL_TYPE_SIZES","PATH_PROPERTIES","INTERPOLATION","InterpolateLinear","InterpolateDiscrete","ALPHA_MODES","createDefaultMaterial","cache","MeshStandardMaterial","FrontSide","addUnknownExtensionsToUserData","knownExtensions","objectDef","gltfDef","addMorphTargets","targets","hasMorphPosition","hasMorphNormal","hasMorphColor","il","pendingPositionAccessors","pendingNormalAccessors","pendingColorAccessors","pendingAccessor","accessors","morphPositions","morphNormals","morphColors","updateMorphTargets","targetNames","createPrimitiveKey","primitiveDef","geometryKey","dracoExtension","createAttributesKey","attributesKey","keys","getNormalizedComponentScale","constructor","getImageURIMimeType","uri","_identityMatrix","isSafari","safariVersion","isFirefox","firefoxVersion","userAgent","safariMatch","TextureLoader","ImageBitmapLoader","ext","dependencies","scene","skinDefs","meshDefs","skinIndex","skinLength","joints","ref","updateMappings","original","clone","mappings","child","func","defs","def","bufferIndex","bufferDef","bufferViewDef","accessorIndex","itemSize","TypedArray","BufferAttribute","pendingBufferViews","bufferViews","elementBytes","itemBytes","byteStride","bufferAttribute","ibSlice","ibCacheKey","ib","InterleavedBuffer","InterleavedBufferAttribute","itemSizeIndices","TypedArrayIndices","byteOffsetIndices","byteOffsetValues","sparseIndices","sparseValues","sourceIndex","sourceDef","promise","sampler","URL","sourceURI","isObjectURL","blob","imageBitmap","Texture","mapName","mapDef","colorSpace","gltfReference","useDerivativeTangents","useVertexColors","useFlatShading","pointsMaterial","PointsMaterial","Material","lineMaterial","LineBasicMaterial","cachedMaterial","materialType","materialExtensions","kmuExtension","DoubleSide","alphaMode","emissiveFactor","originalName","sanitizedName","PropertyBinding","primitives","createDracoPrimitive","addPrimitiveAttributes","cached","geometryPromise","BufferGeometry","meshIndex","materials","geometries","SkinnedMesh","Mesh","LineSegments","Line","LineLoop","Points","Group","cameraIndex","cameraDef","params","PerspectiveCamera","OrthographicCamera","skinDef","inverseBindMatrices","jointNodes","bones","boneInverses","jointNode","mat","Skeleton","animationIndex","animationDef","animationName","pendingNodes","pendingInputAccessors","pendingOutputAccessors","pendingSamplers","pendingTargets","channel","input","output","nodes","inputAccessors","outputAccessors","samplers","tracks","node","inputAccessor","outputAccessor","createdTracks","k","animation","AnimationClip","o","nodePending","childPending","childrenDef","skeletonPending","children","skeleton","nodeName","meshPromise","Bone","matrix","mapping","sceneIndex","sceneDef","nodeIds","reduceAssociations","reducedAssociations","value","targetName","TypedKeyframeTrack","NumberKeyframeTrack","QuaternionKeyframeTrack","VectorKeyframeTrack","interpolation","outputArray","j","jl","track","scaled","interpolantType","computeBounds","box","Box3","boxScale","maxDisplacement","vector","sphere","Sphere","assignAttributeAccessor","gltfAttributeName","ColorManagement","ModelLoader","model","THREE.Box3","center","gray","lightGray","percent","CENTER","AVERAGE","SAH","CONTAINED","PRIMITIVE_INTERSECT_COST","TRAVERSAL_COST","BYTES_PER_NODE","UINT32_PER_NODE","IS_LEAFNODE_FLAG","FLOAT32_EPSILON","SKIP_GENERATION","DEFAULT_OPTIONS","arrayToBox","nodeIndex32","getLongestEdgeIndex","bounds","splitDimIdx","splitDist","copyBounds","unionBounds","b","aVal","bVal","d","d3","expandByPrimitiveBounds","startIndex","primitiveBounds","tCenter","tHalf","tMin","tMax","computeSurfaceArea","d0","d1","d2","IS_LEAF","n16","uint16Array","OFFSET","n32","uint32Array","COUNT","LEFT_NODE","RIGHT_NODE","relativeOffset","SPLIT_AXIS","getBounds","centroidTarget","minx","miny","minz","maxx","maxy","maxz","cminx","cminy","cminz","cmaxx","cmaxy","cmaxz","boundsOffset","end","cx","hx","lx","rx","cy","hy","ly","ry","cz","hz","lz","rz","BIN_COUNT","binsSort","sahBins","leftBounds","getOptimalSplit","nodeBoundingData","centroidBoundingData","strategy","pos","getAverage","rootSurfaceArea","bestCost","cStart","cEnd","a","axisLeft","binWidth","truncatedBins","c","bin","leftCacheBounds","rightCacheBounds","splitCount","bi","leftCount","rightCount","rightBounds","leftProb","rightProb","cost","binIndex","lastBin","nextBin","binCount","avg","BVHNode","partition","split","left","right","axisOffset","l","r","tb","float32Array","uint8Array","MAX_POINTER","countNodes","populateBuffer","_populateBuffer","node32Index","node16Index","isLeaf","boundingData","splitAxis","leftByteOffset","rightByteOffset","currentNodeIndex","relativeRightIndex","buildTree","bvh","maxDepth","verbose","maxLeafSize","partitionBuffer","partitionStride","cacheCentroidBoundingData","reachedMaxDepth","root","splitNode","triggerProgress","primitivesProcessed","depth","splitOffset","lstart","lcount","rstart","rcount","buildPackedTree","BufferConstructor","rootRanges","firstRange","lastRange","fullRange","nodeCount","PrimitivePool","getNewPrimitive","_BufferStack","stack","prevBuffer","BufferStack","_box1","_box2","boxStack","boxPool","shapecast","intersectsBounds","intersectsRange","boundsTraverseOrder","nodeOffset","shapecastTraverse","length","intersectsBoundsFunc","intersectsRangeFunc","nodeScoreFunc","nodeIndexOffset","nodeIndex16","getLeftOffset","getRightEndOffset","c1","c2","score1","score2","box1","box2","temp","isC1Leaf","c1Intersection","c1StopTraversal","isC2Leaf","c2Intersection","c2StopTraversal","_bufferStack1","_bufferStack2","_boxPool","_leftBox1","_rightBox1","_leftBox2","_rightBox2","_active","bvhcast","otherBvh","matrixToLocal","intersectsRanges","roots","otherRoots","nodeOffset1","nodeOffset2","invMat","localBox","_traverse","node1Index32","node2Index32","matrix2to1","matrix1to2","intersectsRangesFunc","node1IndexOffset","node2IndexOffset","depth1","depth2","currBox","reversed","bufferStack1","bufferStack2","float32Array1","uint32Array1","uint16Array1","float32Array2","uint32Array2","uint16Array2","node1Index16","node2Index16","isLeaf1","isLeaf2","newBox","cl1","cr1","intersectCl1","intersectCr1","cl2","cr2","leftIntersects","rightIntersects","_tempBox","_tempBuffer","BVH","targetBuffer","baseIndex","minX","minY","minZ","maxX","maxY","maxZ","indirectBuffer","rootIndex","totalNodes","rootCount","leftMin","leftMax","rightMin","rightMax","callbacks","intersectsPrimitive","scratchPrimitive","iterate","originalIntersectsRange","contained","shapecastFunc","isSharedArrayBufferSupported","getVertexCount","geo","getTriCount","getIndexArray","vertexCount","ensureIndex","getFullPrimitiveRange","primitiveCount","drawRange","start","getPrimitiveGroupRanges","getRootPrimitiveRanges","primitiveRanges","ranges","drawRangeStart","drawRangeEnd","events","groupStart","groupCount","groupEnd","activeGroups","lastPos","newPos","generateIndirectBuffer","useSharedArrayBuffer","useUint32","acc","val","byteCount","GeometryBVH","v","primitiveStride","SeparatingAxisBounds","field","other","boxMin","boxMax","z","closestPointLineToLine","dir1","dir2","v02","l1","l2","v0","v10","v32","d0232","d3210","d3232","d0210","denom","closestPointsSegmentToSegment","paramResult","temp1","temp2","target1","target2","p2","closestPoint","closestPoint2","sphereIntersectTriangle","closestPointTemp","projectedPointTemp","planeTemp","lineTemp","Line3","triangle","componentKeys","ZERO_EPSILON","ZERO_EPSILON_SQR","isNearZero","ExtendedTriangle","Triangle","args","satAxes","satBounds","axis0","sab0","axis1","sab1","axis2","sab2","axis3","sab3","lengthAB","lengthBC","lengthCA","point1","point2","segment","distSq","closestDistanceSq","nexti","saTri2","cachedSatBounds","cachedSatBounds2","tmpVec","tempDir","edge1","edge2","tempPoint","bounds1","bounds2","coplanarIntersectsTriangle","suppressLog","planeNormal","satBounds1","satAxes1","sb","sa","satBounds2","satAxes2","findSingleBounds","aProj","bProj","cProj","aDist","bDist","cDist","findIntersectionLineBounds","abDist","acDist","intersectTriangleSegment","degenerateTriangle","startDist","endDist","intersectTrianglePoint","intersectSegmentPoint","segmentTri","pointTri","handleDegenerateCases","segment1","segment2","delta1","delta2","startDelta","u","z1","z2","plane1","plane2","a1Dist","b1Dist","c1Dist","a1b1Dist","a1c1Dist","a2Dist","b2Dist","c2Dist","a2b2Dist","a2c2Dist","intersectionLine","componentIndex","maxComponent","comp1","a1Proj","b1Proj","c1Proj","a2Proj","b2Proj","c2Proj","tmp","cornerFields","line1","line2","lineTarget","otherVec","thisVec","f11","f12","i2","f21","f22","OrientedBox","minVec","pi","alignedSatBounds","aabbBounds","saTri","pointsArr","cachedAxis","triSatBounds","triSatAxes","sa1","sa2","xyzFields","segments1","segments2","threshold","threshold2","nextIndex","nextIndex2","index2","f1","f2","f3","ExtendedTrianglePoolBase","ExtendedTrianglePool","closestPointToPoint","minThreshold","maxThreshold","minThresholdSq","maxThresholdSq","closestDistanceTriIndex","score","tri","triIndex","closestDistance","IS_GT_REVISION_169","REVISION","IS_LT_REVISION_161","_vA","_vB","_vC","_uvA","_uvB","_uvC","_normalA","_normalB","_normalC","_intersectionPoint","checkIntersection","pA","pB","pC","side","near","far","intersect","BackSide","checkBufferGeometryIntersection","normal","uv","uv1","face","barycoord","getSide","materialOrSide","intersectTri","intersections","triOffset","groups","firstIndex","setTriangle","ta","tc","i0","intersectTris","_indirectBuffer","intersectClosestTri","iterateOverTriangles","intersectsTriangleFunc","refit","nodeIndices","indexArr","posAttr","force","forceChildren","includesLeft","includesRight","leftNodeId","rightNodeId","traverseLeft","traverseRight","leftChange","rightChange","didChange","left_i","right_i","minLeftValue","maxLeftValue","minRightValue","maxRightValue","intersectRay","tmin","tmax","tymin","tymax","tzmin","tzmax","invdirx","invdiry","invdirz","ox","oy","oz","intersectTris_indirect","vi","intersectClosestTri_indirect","iterateOverTriangles_indirect","raycast","_raycast","leftIndex","rightIndex","_xyzFields","raycastFirst","_raycastFirst","xyzAxis","leftToRight","c1Result","c2Result","boundingBox","triangle2","invertedMat","obb","obb2","intersectsGeometry","otherGeometry","geometryToBvh","_intersectsGeometry","cachedObb","thisGeometry","thisIndex","thisPos","otherIndex","otherPos","otherTriangleCount","tempMatrix","temp3","temp4","closestPointToGeometry","tempTarget1","tempTargetDest1","tempTarget2","tempTargetDest2","closestDistanceOtherTriIndex","otherOffset","otherCount","triCount","refit_indirect","raycast_indirect","raycastFirst_indirect","intersectsGeometry_indirect","ti","closestPointToGeometry_indirect","ti2","convertRaycastIntersect","raycaster","_obb","_direction","_inverseMatrix","_worldScale","_getters","MeshBVH","rootData","indexAttribute","fixupVersion0","newIndex","tri3","ai","ci","el","posArr","bufferOffset","getters","writeOffset","boundsIndexOffset","halfExtents","el2","scaleFactor","hits","raycastFunc","closestResult","raycastFirstFunc","geomToMesh","intersectsGeometryFunc","intersectsTriangles","triangle1","indexAttr1","positionAttr1","assignTriangle1","indexAttr2","positionAttr2","assignTriangle2","iterateOverDoubleTriangles","count1","offset2","count2","nodeIndex1","nodeIndex2","originalIntersectsRanges","boxToMesh","HASH_WIDTH","HASH_HALF_WIDTH","HASH_MULTIPLIER","HASH_ADDITION","hashNumber","hashVertex2","hashVertex3","hashVertex4","toNormalizedRay","scalar","areSharedArrayBuffersSupported","convertToSharedArrayBuffer","cons","sharedBuffer","uintArray","DEGENERATE_EPSILON","_tempVec","toTriIndex","toEdgeIndex","sortEdgeFunc","getProjectedDistance","vec","matchEdges","forward","reverse","disjointConnectivityMap","eps","e0","e1","areDistancesDegenerate","isEdgeDegenerate","cleanUpEdgeSet","arr","DIST_EPSILON","ANGLE_EPSILON","RaySet","rays","inv","bestScore","bestRay","skipRay","rayScore","scoreRays","invScore","r0","r1","distOutOfThreshold","originDistance","angleDistance","_v0","_v1","computeDisjointEdges","unmatchedSet","indexAttr","fragmentMap","edgeIndex","info","commonRay","_vec2","_vec3","_vec4","Vector4","_hashes","HalfEdgeMap","useAllAttributes","useDrawRange","matchDisjointEdges","degenerateEpsilon","hashFunction","hashAllAttributes","hashPositionAttribute","map","attrKeys","maxTriCount","matchedEdges","i3","nextE","vh0","vh1","reverseHash","hash","str","Brush","_previousMatrix","el1","g","lg","EPSILON","_AB","_AC","_CB","isTriDegenerate","angle1","angle2","angle3","COPLANAR_EPSILON","PARALLEL_EPSILON","_edge","_foundEdge","_vec","_triangleNormal","_planeNormal","_splittingTriangle","TrianglePool","TriangleSplitter","triangles","trianglePool","poolTri","clippingTriangle","vertexSplitEnd","coplanarEdge","posSideVerts","negSideVerts","tNext","didIntersect","otherVert1","otherVert2","nextTri","singleVert","nextVert1","nextVert2","nextTri1","nextTri2","ceilToFourByteStride","TypeBackedArray","initialSize","bufferType","newArray","expansionFactor","TypedAttributeData","groupAttributes","attrSet","refAttrSet","newAttrSet","refAttr","newAttr","referenceAttr","IntersectionMap","id","intersectionId","intersectionSet","ids","ADDITION","SUBTRACTION","REVERSE_SUBTRACTION","INTERSECTION","DIFFERENCE","HOLLOW_SUBTRACTION","HOLLOW_INTERSECTION","_matrix","_tri","_vec4a","_vec4b","_vec4c","_vec4_0","_vec4_1","_vec4_2","_normal","JITTER_EPSILON","OFFSET_EPSILON","BACK_SIDE","FRONT_SIDE","COPLANAR_OPPOSITE","COPLANAR_ALIGNED","INVERT_TRI","ADD_TRI","SKIP_TRI","FLOATING_COPLANAR_EPSILON","_debugContext","setDebugContext","debugData","getHitSide","getHitSideWithCoplanarCheck","rand","total","minDistance","collectIntersectingTriangles","aIntersections","bIntersections","triangleA","triangleB","ia","intersected","pa","pb","na","nb","va","vb","appendAttributeFromTriangle","baryCoordTri","matrixWorld","normalMatrix","attributeData","invert","pushBarycoordInterpolatedValues","appendAttributesFromIndices","appendAttributeFromIndex","getOperationAction","operation","hitSide","attrArr","normalize","addValues","TriangleIntersectData","TriangleIntersectionSets","triA","triB","id2","triSet","addTriangles","key2","OperationDebugData","triangleIntersectsA","triangleIntersectsB","_normalMatrix","Matrix3","_triA","_triB","_barycoordTri","_attr","_actions","getFirstIdFromSet","set","performOperation","operations","splitter","useGroups","resultGroups","resultMaterials","groupOffset","performSplitTriangleOperations","performWholeTriangleOperations","op","intersectionMap","invertedGeometry","groupIndices","aIndex","aPosition","bBVH","bIndex","bPosition","splitIds","groupIndex","ia3","ia0","ia1","ia2","intersectingIndices","ib3","ib0","ib1","ib2","clippedTri","lo","lk","invertTri","splitTriSet","aAttributes","halfEdges","traverseSet","currId","sid","action","joinGroups","nextGroup","prepareAttributesData","referenceGeometry","targetGeometry","relevantAttributes","aAttr","assignBufferData","groupOrder","needsDisposal","referenceAttrSet","requiredLength","geoAttr","trimmedArray","indexArray","vertCount","getMaterialList","Evaluator","targetBrushes","wasArray","triangleSplitter","consolidateGroups","debug","brush","aGroups","aMaterials","bGroups","bMaterials","allMaterials","finalMaterials","foundGroup","flatTraverse","obj","cb","traverse","isDirty","RotationGizmoApp","modelPath","gizmoMesh","handleResize","mainMesh","transverseSection","coronalSection","sagittalSection","evaluator","sliceThickness","slicerGeometry","largeSize","THREE.BoxGeometry","crossSectionMaterial","THREE.MeshStandardMaterial","meshBrush","slicerBrush","yPosition","localY","materialCount","shader","planes","enabled","cube","THREE.SphereGeometry","aspect","cubeGeometry","cubeMaterials","planeMaterial","squarePlaneGeometry","circularPlaneGeometry","highlighted","positions","theta","THREE.Float32BufferAttribute","controls","styleButtons","button","btn","resetButton","header","isDragging","currentX","currentY","initialX","initialY","xOffset","yOffset","dragStart","drag","dragEnd","panelId","panel","infoHeader","infoContent","chevron","startRotation","startCameraPosition","startCameraTarget","startCameraZoom","startTransverseY","targetY","newTransverseY","direction","scaledDistance","adjustedTarget"],"mappings":"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","x_google_ignoreList":[1,7,8,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66]}